"<!DOCTYPE html><html lang=\"en\"><head><meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1,maximum-scale=1'><style>\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/components/LightBox/Modal.esbuild-svelte-fake-css */\nnav.cols.svelte-1nxttb1.svelte-1nxttb1 {\n  --cols-gap:0;\n}\n.cols.svelte-1nxttb1 span.svelte-1nxttb1 {\n  flex: auto;\n  text-align: left;\n  max-width: calc(100% - (var(--gap)));\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/components/LightBox/Thumb.esbuild-svelte-fake-css */\na.svelte-kjjj8o {\n  color: transparent;\n  background-size: cover;\n  text-indent: -999px;\n  height: 2.5em;\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/data/record/file.esbuild-svelte-fake-css */\nul[role=listbox].svelte-i8zzmi li.svelte-i8zzmi {\n  margin: var(--gap-sm) 0;\n}\n.scroll-x.svelte-i8zzmi.svelte-i8zzmi {\n  text-align: left;\n  flex: 60%;\n}\nlabel[role=button].svelte-i8zzmi.svelte-i8zzmi {\n  margin: var(--gap-sm) 0 0;\n  display: flex;\n}\nlabel[role=button].svelte-i8zzmi input.svelte-i8zzmi {\n  display: none;\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/data/schema/schemas.esbuild-svelte-fake-css */\nul[role=listbox].svelte-14r8xoc {\n  padding: var(--gap);\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/data/schema/fields.esbuild-svelte-fake-css */\nfieldset.svelte-1digiow {\n  margin-bottom: var(--gap);\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/data/page.esbuild-svelte-fake-css */\n#addRecord.svelte-1i10ixq {\n  bottom: 3.5rem;\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/files/upload.esbuild-svelte-fake-css */\nfieldset.svelte-88yfos.svelte-88yfos {\n  min-inline-size: fit-content;\n}\nfieldset.svelte-88yfos label.svelte-88yfos {\n  margin: 0;\n}\n[role=button].svelte-88yfos.svelte-88yfos {\n  mask-size: 50%;\n}\n[type=file].svelte-88yfos.svelte-88yfos {\n  position: absolute;\n  opacity: 0;\n  inset: 0;\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/files/page.esbuild-svelte-fake-css */\nul[role=listbox].svelte-lgpwhs.svelte-lgpwhs {\n  --cols-gap:var(--gap-sm);\n  --col-width:9.5em;\n  position: relative;\n  padding: 0;\n}\nul[role=listbox].svelte-lgpwhs li.svelte-lgpwhs {\n  position: relative;\n  flex-flow: column nowrap;\n  align-items: start;\n  justify-content: space-between;\n  padding: 0;\n  gap: 0;\n}\nul[role=listbox].svelte-lgpwhs li a.svelte-lgpwhs {\n  flex: auto;\n  width: 100%;\n  color: transparent;\n  background-size: cover;\n}\nul[role=listbox].svelte-lgpwhs li label.svelte-lgpwhs {\n  display: flex;\n  align-items: center;\n  justify-content: start;\n  flex-wrap: nowrap;\n  width: 100%;\n  margin: 0;\n  padding: 0 var(--gap-sm);\n}\n[type=checkbox].svelte-lgpwhs.svelte-lgpwhs {\n  flex: 0 0 auto;\n}\nsmall.svelte-lgpwhs.svelte-lgpwhs {\n  max-width: calc(var(--col-width) - var(--gap));\n  max-width: 13.5ch;\n  flex: 0 auto;\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/users/page.esbuild-svelte-fake-css */\n#addUser.svelte-5un1ps {\n  bottom: 3.5rem;\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/components/Search.esbuild-svelte-fake-css */\n[type=search].collapsed.svelte-1i670oi.svelte-1i670oi {\n  padding-right: 0;\n  width: 2.5em;\n}\n[type=search].collapsed.svelte-1i670oi.svelte-1i670oi::placeholder {\n  color: transparent;\n}\n[type=search].collapsed.svelte-1i670oi.svelte-1i670oi:is(:focus, :focus-visible) {\n  padding-right: var(--gap);\n  width: 100%;\n}\n[type=search].collapsed.svelte-1i670oi.svelte-1i670oi:is(:focus, :focus-visible)::placeholder {\n  color: var(--gray);\n}\nform.svelte-1i670oi label.svelte-1i670oi {\n  margin-bottom: 0;\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/views/Footer.esbuild-svelte-fake-css */\nfooter.svelte-1aqpy8p {\n  --viewport:25em;\n  --cols-gap:var(--gap-sm);\n  bottom: 0;\n  padding: var(--gap-sm) 0;\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/components/Paginator.esbuild-svelte-fake-css */\n.paginator.svelte-zk2d7b.svelte-zk2d7b {\n  --cols-gap:var(--gap-sm);\n  display: inline-flex;\n  align-items: center;\n  list-style: none;\n  margin: auto;\n  padding: 0;\n  max-width: fit-content;\n}\n.paginator.svelte-zk2d7b li.svelte-zk2d7b {\n  line-height: 1.5;\n}\n.paginator.svelte-zk2d7b li:not(:first-child, :last-child) button.svelte-zk2d7b {\n  padding: 0 var(--gap-sm);\n}\nselect.svelte-zk2d7b.svelte-zk2d7b {\n  width: auto;\n  max-width: fit-content;\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/users/input.esbuild-svelte-fake-css */\nfieldset.svelte-4oyeew label.svelte-4oyeew {\n  margin: 0;\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/users/nav.esbuild-svelte-fake-css */\n[href=\"#add-role\"].svelte-1mx47zj {\n  left: 0;\n  z-index: 1;\n  background-color: var(--back);\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/files/input.esbuild-svelte-fake-css */\nfieldset.svelte-4oyeew label.svelte-4oyeew {\n  margin: 0;\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/files/nav.esbuild-svelte-fake-css */\n[href=\"#add-folder\"].svelte-kcwsun {\n  left: 0;\n  z-index: 1;\n  background-color: var(--back);\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/data/nav.esbuild-svelte-fake-css */\na[href=\"/data\"].svelte-1hu73eg {\n  left: 0;\n  z-index: 1;\n}\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/views/Main.esbuild-svelte-fake-css */\n.container.svelte-11vk0bu {\n  --viewport:100%;\n}\n.grid.svelte-11vk0bu {\n  --viewport:25rem;\n  place-content: center;\n}\n\n/* src/client/styles/theme.css */\n:root {\n  --color: hsl(210, 15%, 15%);\n  --surface: hsl(210, 15%, 100%);\n  --hover: hsl(210, 15%, 95%);\n  --active: hsl(210, 15%, 90%);\n  --back: hsl(210, 15%, 85%);\n  --gray: hsl(210, 15%, 50%);\n  --backdrop: hsla(210, 15%, 80%, 50%);\n  --success: hsl(120, 50%, 50%);\n  --warning: hsl(40, 90%, 50%);\n  --error: hsl(20, 90%, 50%);\n  --border-radius-lg: 0.75em;\n  --border-radius: 0.5em;\n  --border-radius-sm: 0.25em;\n  --gap-lg: 1.25em;\n  --gap: 1em;\n  --gap-sm: 0.5em;\n  --padding-lg: var(--gap-lg);\n  --padding: var(--gap-sm) var(--gap-lg);\n  --padding-sm: var(--gap-sm);\n  --viewport: 100%;\n  --icon-chevron: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='hsl(210, 15%, 15%)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E\");\n  --icon-search: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='hsl(210, 15%, 15%)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'%3E%3C/line%3E%3C/svg%3E\");\n  --icon-date: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='hsl(210, 15%, 15%)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect x='3' y='4' width='18' height='18' rx='2' ry='2'%3E%3C/rect%3E%3Cline x1='16' y1='2' x2='16' y2='6'%3E%3C/line%3E%3Cline x1='8' y1='2' x2='8' y2='6'%3E%3C/line%3E%3Cline x1='3' y1='10' x2='21' y2='10'%3E%3C/line%3E%3C/svg%3E\");\n  --icon-time: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='hsl(210, 15%, 15%)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'%3E%3C/circle%3E%3Cpolyline points='12 6 12 12 16 14'%3E%3C/polyline%3E%3C/svg%3E\");\n  --icon-checkbox: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='hsl(210, 15%, 85%)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E\");\n}\n@media (prefers-color-scheme: dark) {\n  :root {\n    color-scheme: dark;\n    --color: hsl(210, 15%, 85%);\n    --surface: hsl(210, 15%, 25%);\n    --hover: hsl(210, 15%, 20%);\n    --active: hsl(210, 15%, 15%);\n    --back: hsl(210, 15%, 10%);\n    --backdrop: hsla(210, 15%, 10%, 50%);\n    --icon-chevron: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='hsl(210, 15%, 85%)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E\");\n    --icon-search: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='hsl(210, 15%, 85%)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'%3E%3C/line%3E%3C/svg%3E\");\n    --icon-date: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='hsl(210, 15%, 85%)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect x='3' y='4' width='18' height='18' rx='2' ry='2'%3E%3C/rect%3E%3Cline x1='16' y1='2' x2='16' y2='6'%3E%3C/line%3E%3Cline x1='8' y1='2' x2='8' y2='6'%3E%3C/line%3E%3Cline x1='3' y1='10' x2='21' y2='10'%3E%3C/line%3E%3C/svg%3E\");\n    --icon-time: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='hsl(210, 15%, 85%)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'%3E%3C/circle%3E%3Cpolyline points='12 6 12 12 16 14'%3E%3C/polyline%3E%3C/svg%3E\");\n    --icon-checkbox: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='hsl(210, 15%, 15%)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E\");\n  }\n}\n\n/* src/client/styles/base.css */\nbody,\nhtml {\n  -webkit-text-size-adjust: 100%;\n}\nhtml {\n  height: 100%;\n}\nbody {\n  margin: 0;\n  display: grid;\n  overflow-x: hidden;\n  min-block-size: 100%;\n  grid-template-rows: auto 1fr auto;\n  grid-template-columns: 1fr;\n  font-family: system-ui;\n  color: var(--color);\n  background-color: var(--back);\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n*,\n::after,\n::before {\n  box-sizing: border-box;\n  min-width: 0;\n}\nheader,\nfooter {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 0 var(--gap);\n  gap: var(--gap-sm);\n  z-index: 2;\n}\nheader {\n  top: 0;\n}\n:is(header, footer) > * {\n  margin: 0;\n  flex: auto;\n}\nmain > nav {\n  margin: var(--gap-lg) 0;\n}\narticle {\n  padding: var(--padding);\n  border-radius: var(--border-radius-lg);\n}\nnav.cols {\n  --cols-gap: var(--gap-sm);\n  padding: 0;\n}\nnav.cols :is([role=button]):is([aria-disabled=true]):not(.box) {\n  padding: 0;\n}\nmenu {\n  --cols-gap: var(--gap-sm) !important;\n  padding: 0;\n  margin: 0;\n}\nfigure {\n  padding: 0;\n  margin: 0;\n  min-block-size: 100%;\n  display: flex;\n  flex-flow: column nowrap;\n  justify-content: space-between;\n}\nfigcaption {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\nimg {\n  border-radius: var(--border-radius-sm);\n  max-width: 100%;\n  height: auto;\n}\n\n/* src/client/styles/typo.css */\np {\n  line-height: 1.5;\n}\na {\n  color: inherit;\n}\na:hover {\n  text-decoration: none;\n}\na :is([role=button], button) {\n  border: 0;\n}\nstrong {\n  font-size: large;\n  font-weight: bold;\n  border-radius: 0.5em;\n}\nsmall {\n  color: var(--gray);\n}\nsamp {\n  color: var(--error);\n  word-break: break-word;\n  font-size: medium;\n}\nul,\nol {\n  line-height: 1.5;\n}\nul[role=listbox] {\n  list-style: none;\n  padding: 0;\n}\nul[role=listbox].cols {\n  --cols-gap: var(--gap);\n  position: relative;\n  margin: 0;\n}\nul[role=listbox] li {\n  border-radius: var(--border-radius-sm);\n}\npre {\n  background-color: var(--back);\n  border-radius: var(--border-radius-sm);\n  line-height: 1.5;\n  tab-size: 1rem;\n  overflow-x: auto;\n}\npre code {\n  display: block;\n  border: 0.09rem solid var(--surface);\n  padding: var(--padding);\n  cursor: auto;\n}\ncode {\n  background-color: var(--back);\n  border-radius: var(--border-radius-sm);\n  padding: 0.25rem 0.5rem;\n  white-space: inherit !important;\n  color: var(--gray);\n}\ncode span {\n  opacity: 0.5;\n}\n.text-center {\n  text-align: center;\n}\n.text-left {\n  text-align: left;\n}\n.text-break {\n  word-break: break-all;\n  white-space: initial;\n  min-width: fit-content;\n  max-width: min-content;\n}\n.text-bold {\n  font-weight: bold;\n}\n.text-small {\n  font-size: small;\n}\n.text-ellepsis {\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n  line-height: inherit;\n}\n\n/* src/client/styles/colors.css */\n.text-success {\n  color: var(--success);\n}\n.text-warning {\n  color: var(--warning);\n}\n.text-error {\n  color: var(--error) !important;\n}\n.text-gray {\n  color: var(--gray);\n}\n.text-color {\n  color: var(--color);\n}\n.text-current {\n  color: currentColor;\n}\n.bg-back {\n  background-color: var(--back);\n}\n.bg-surface {\n  background-color: var(--surface);\n}\n.bg-hover {\n  background-color: var(--hover);\n}\n.bg-active {\n  background-color: var(--active);\n}\n\n/* src/client/styles/table.css */\ntable {\n  white-space: nowrap;\n  min-inline-size: 100%;\n  line-height: 2.5;\n  border-collapse: collapse;\n}\ntable th {\n  color: var(--gray);\n  text-align: inherit;\n  font-weight: inherit;\n  font-size: medium;\n}\ntable th span {\n  display: flex;\n  align-items: center;\n  gap: 0.25rem;\n}\ntable th span i:nth-child(2) {\n  margin-left: var(--gap);\n}\ntable td {\n  vertical-align: initial;\n  white-space: normal;\n}\ntable td p {\n  margin: 0;\n  overflow: hidden;\n  display: -webkit-box;\n  -webkit-line-clamp: 1;\n  -webkit-box-orient: vertical;\n}\ntable thead th[role=button] {\n  padding: 0 var(--gap);\n  display: table-cell;\n  text-align: start;\n  color: var(--gray);\n  line-height: 3;\n}\ntable :is(th, td) {\n  padding: var(--gap-sm) var(--gap);\n  line-height: initial;\n  vertical-align: middle;\n}\ntable.selectable :is(th, td):nth-of-type(1) {\n  padding: var(--gap-sm);\n  position: sticky;\n  width: 2rem;\n  z-index: 1;\n  left: 0;\n}\ntable.selectable tr td:nth-of-type(1) input {\n  vertical-align: middle;\n}\ntable.selectable tr td:nth-of-type(2) {\n  font-size: small;\n  color: var(--gray);\n  white-space: nowrap;\n}\ntable.updated tr td:last-child {\n  font-size: small;\n  color: var(--gray);\n  white-space: nowrap;\n}\ntable.updated tr :is(th, td):is(:nth-child(2), :last-child) {\n  width: 1%;\n}\ntable :not(thead) tr:hover {\n  cursor: pointer;\n  background-color: var(--hover);\n}\ntable tr :is(th, td) input[type=checkbox] {\n  vertical-align: inherit;\n}\n\n/* src/client/styles/layouts.css */\n.cols {\n  --cols-gap: var(--gap-lg);\n  display: flex;\n  flex-flow: row wrap;\n  align-items: stretch;\n  justify-content: space-between;\n  gap: var(--cols-gap);\n}\n.cols > * {\n  flex: auto;\n}\n.cols.col-2 > * {\n  flex: 0 calc(50% - var(--gap) / 2);\n}\n.cols.col-3 > * {\n  flex: 0 calc(100% / 3 - var(--gap) / 1.5);\n}\n.cols.col-4 > * {\n  flex: 0 calc(100% / 4 - var(--gap) / 1.25);\n}\n.cols.col-fit > * {\n  flex: 0 0 fit-content;\n}\n.cols.col-min > * {\n  flex: 0 min-content;\n}\n.cols.column {\n  flex-direction: column;\n}\n.cols.nowrap {\n  flex-wrap: nowrap;\n}\n.cols.justify-start {\n  justify-content: start;\n}\n.cols.justify-center {\n  justify-content: center;\n}\n.cols.justify-end {\n  justify-content: end;\n}\n.cols.align-start {\n  align-items: start;\n}\n.cols.align-center {\n  align-items: center;\n}\n.cols.align-end {\n  align-items: end;\n}\n.surface {\n  background-color: var(--surface);\n}\n.hover {\n  background-color: var(--hover);\n}\n.active {\n  background-color: var(--active);\n}\n.container {\n  margin-inline: calc(max(0%, 50% - var(--viewport) / 2) + var(--gap-lg));\n}\n@media screen and (max-width: 600px) {\n  .cols:is(.col-2, .col-3, .col-4) > * {\n    flex: auto;\n  }\n}\n.grid {\n  --col-width: 25em;\n  --col-gap: var(--gap);\n  display: grid;\n  grid-gap: var(--col-gap);\n}\n@supports (width: min(var(--col-width), 100%)) {\n  .grid {\n    grid-template-columns: repeat(auto-fit, minmax(min(var(--col-width), 100%), 1fr));\n  }\n}\n.grid.center {\n  place-content: center;\n}\n.aspect-ratio-1-1 {\n  aspect-ratio: 1/1;\n}\n.columns {\n  --col-width: 20em;\n  --col-gap: var(--gap);\n  columns: var(--col-width);\n  gap: var(--col-gap);\n  margin: auto;\n}\n.columns > * {\n  break-inside: avoid;\n  margin-bottom: var(--col-gap);\n}\n\n/* src/client/styles/aside.css */\naside {\n  --cols-gap: var(--gap-sm);\n  display: flex;\n  position: fixed;\n  inset: 0;\n  z-index: 100;\n  min-width: 35em;\n}\naside::after {\n  content: \"\";\n  position: fixed;\n  z-index: -1;\n  inset: inherit;\n  width: 1000rem;\n  height: 1000rem;\n  background: var(--backdrop);\n}\naside :is(header, footer) {\n  padding: var(--padding);\n}\naside form {\n  display: flex;\n  flex-flow: column nowrap;\n  align-items: stretch;\n  min-width: inherit;\n  background: var(--active);\n}\naside form label small {\n  display: inline-flex;\n  align-items: center;\n  gap: 0.25rem;\n}\naside article {\n  padding: var(--gap-lg);\n  flex: 1;\n}\naside header #close {\n  font-size: small;\n  flex: none;\n}\naside header #close:hover {\n  color: var(--error);\n}\naside.left {\n  right: auto;\n}\naside.right {\n  left: auto;\n}\naside.top {\n  bottom: auto;\n  max-inline-size: fit-content;\n}\naside.bottom {\n  top: auto;\n}\n@media screen and (max-width: 600px) {\n  aside {\n    min-inline-size: 100%;\n    max-inline-size: 100%;\n  }\n}\n\n/* src/client/styles/forms.css */\nform.center {\n  margin: 0 auto;\n}\nform.sm {\n  max-inline-size: 25%;\n}\nform.md {\n  max-inline-size: 50%;\n  min-inline-size: 50%;\n}\nform.lg {\n  max-inline-size: 75%;\n}\nform.fs {\n  min-inline-size: 100%;\n  min-block-size: 100%;\n}\nform {\n  max-inline-size: 40rem;\n}\n@media screen and (max-width: 600px) {\n  form {\n    min-inline-size: 100% !important;\n    max-inline-size: 100% !important;\n  }\n}\nfieldset {\n  padding: 0;\n  border: 0;\n  margin: 0;\n  border-radius: var(--border-radius-sm);\n}\nfieldset.cols {\n  --cols-gap: var(--gap-sm);\n}\nfieldset.cols label {\n  margin: 0;\n}\nlegend {\n  font-size: large;\n  position: relative;\n  margin-bottom: var(--gap);\n}\nlabel {\n  position: relative;\n}\nlabel:not([data-note]) {\n  margin-bottom: var(--gap-lg);\n  display: block;\n}\nfieldset.cols label :is(small, span) {\n  display: block;\n}\nlabel :is(small, span) + :is(input, select, textarea) {\n  margin-top: var(--gap-sm);\n}\ninput,\nselect,\ntextarea {\n  margin: 0;\n  padding: 0 1rem;\n  border: 0.09em solid var(--surface);\n  border-radius: var(--border-radius-sm);\n  background-color: var(--back);\n  font-family: inherit;\n  font-size: inherit;\n  font-weight: inherit;\n  color: var(--color);\n  line-height: 2.25;\n  width: 100%;\n}\ninput:is([type=date], [type=time], [type=datetime-local]) {\n  appearance: none;\n  background-repeat: no-repeat;\n  background-position: center right 0.65rem;\n  background-size: 1rem;\n  padding-right: 0.5rem;\n  min-height: 2.5em;\n}\ninput[type=time] {\n  background-image: var(--icon-time);\n}\n@supports not (-moz-appearance: none) {\n  input:is([type=date], [type=datetime-local]) {\n    background-image: var(--icon-date);\n  }\n}\ninput[type=file] {\n  padding: var(--padding-sm);\n  line-height: inherit;\n}\n:is(input, select, textarea).contrast {\n  border-color: currentColor;\n}\n:is(input, select, textarea)::placeholder {\n  color: var(--gray);\n  opacity: 0.5;\n}\ninput[type=radio] {\n  border-radius: 50%;\n}\ninput:is([type=checkbox], [type=radio]) {\n  appearance: none;\n  width: 1.25rem;\n  height: 1.25rem;\n  padding: 0;\n  vertical-align: top;\n  line-height: inherit;\n  min-inline-size: auto;\n}\ninput:is([type=checkbox], [type=radio]):checked {\n  background-color: currentColor;\n}\ninput[type=checkbox]:checked:not([role=switch]) {\n  background-image: var(--icon-checkbox);\n  background-size: 70%;\n  background-repeat: no-repeat;\n  background-position: center;\n}\ninput[type=radio]:checked {\n  border-width: 0.35em;\n  border-color: currentColor;\n  background-color: var(--back);\n}\ninput[type=checkbox][role=switch] {\n  width: 2.1rem;\n  border-radius: 1rem;\n}\ninput[type=checkbox][role=switch]:checked::before {\n  margin-left: 1rem;\n  background-color: var(--back);\n}\ninput[type=checkbox][role=switch]::before {\n  content: \"\";\n  width: 0.9rem;\n  height: 0.9rem;\n  display: inline-block;\n  border-radius: 50%;\n  background-color: var(--color);\n  margin: 0.1rem;\n  transition: margin .1s ease-in-out;\n}\ninput[type=search] {\n  appearance: none;\n  border-radius: var(--gap-lg);\n  background-image: var(--icon-search);\n  background-repeat: no-repeat;\n  background-position: 0.65rem;\n  background-size: 1rem;\n  padding-left: 2.15rem;\n}\nselect {\n  appearance: none;\n  font-family: inherit;\n  background-image: var(--icon-chevron);\n  background-position: center right 0.5rem;\n  background-size: 1rem auto;\n  background-repeat: no-repeat;\n  padding-right: 2.5rem;\n}\nselect::after {\n  content: \"after\";\n}\ntextarea {\n  resize: none;\n  overflow: hidden;\n  line-height: 1.5;\n  padding: var(--padding);\n  padding-bottom: var(--gap);\n}\n:is(:focus, :focus-visible, :focus-within) {\n  outline: none;\n  border-color: currentColor;\n}\n.valid,\n:not(button, select, [type=checkbox], [type=search], :placeholder-shown):focus:valid {\n  border-color: var(--success);\n}\n.invalid,\n:not(button):invalid,\n:out-of-range {\n  border-color: var(--error);\n}\n:is(:autofill, :-webkit-autofill) {\n  background: inherit;\n}\n:is(textarea, input).secret {\n  text-shadow: 0 0 0.5rem var(--light);\n  color: transparent;\n}\n:is(textarea, input).secret:focus {\n  color: inherit;\n  text-shadow: none;\n}\n:disabled {\n  border-color: var(--gray);\n  color: var(--gray);\n}\nlabel:where(:disabled) {\n  color: var(--gray);\n}\n\n/* src/client/styles/dialog.css */\ndialog {\n  inset: 0;\n  border: 0;\n  padding: 0;\n  scale: 1;\n  color: inherit;\n  border-radius: var(--border-radius);\n  background: var(--active);\n  min-inline-size: 20em;\n  animation-name: from-top;\n  animation-duration: 450ms;\n  will-change: transform;\n  display: none;\n  overflow: hidden;\n  box-shadow: none;\n}\ndialog.center {\n  animation-name: from-center;\n}\ndialog.top {\n  animation-name: from-top;\n}\ndialog.bottom {\n  animation-name: from-bottom;\n}\ndialog.left {\n  animation-name: from-left;\n}\ndialog.right {\n  animation-name: from-right;\n}\n@keyframes from-center {\n  from {\n    transform: scale(0);\n  }\n}\n@keyframes from-top {\n  from {\n    transform: translateY(-100%);\n  }\n}\n@keyframes from-bottom {\n  from {\n    transform: translateY(100%);\n  }\n}\n@keyframes from-left {\n  from {\n    transform: translateX(-100%);\n  }\n}\n@keyframes from-right {\n  from {\n    transform: translateX(100%);\n  }\n}\ndialog[loading] {\n  visibility: hidden;\n}\ndialog[open] {\n  pointer-events: auto;\n  display: flex;\n}\ndialog[open]::backdrop {\n  backdrop-filter: blur(0.25em);\n  -webkit-backdrop-filter: blur(0.25em);\n  background-color: var(--backdrop);\n}\ndialog::backdrop {\n  transition: backdrop-filter 450ms;\n}\ndialog form {\n  display: flex;\n  flex-flow: column nowrap;\n  align-items: stretch;\n  width: 100%;\n}\ndialog.img form header {\n  height: 0;\n  padding: 0;\n}\ndialog.img form article {\n  padding: 0;\n  border-radius: 0;\n}\ndialog.img form article #close {\n  position: fixed;\n  right: 0;\n}\ndialog.img form article img {\n  border-radius: 0;\n}\ndialog.img form footer {\n  padding: var(--padding-sm);\n}\ndialog form :is(header, footer) {\n  padding: var(--padding);\n}\ndialog form header {\n  text-align: start;\n  line-height: 1.5;\n  top: 0;\n}\ndialog form footer {\n  text-align: end;\n  bottom: 0;\n  top: auto;\n}\ndialog form[method=dialog] footer nav.cols form {\n  flex: auto;\n}\ndialog form footer menu {\n  --cols-gap: var(--gap-sm);\n}\ndialog form header #close {\n  font-size: small;\n  flex: none;\n}\ndialog form header #close:hover {\n  color: var(--error);\n}\ndialog.sm {\n  max-inline-size: 25%;\n}\ndialog.md {\n  max-inline-size: 50%;\n  min-inline-size: 50%;\n}\ndialog.lg {\n  max-inline-size: 75%;\n}\ndialog.fs {\n  min-inline-size: 100%;\n  min-block-size: 100%;\n}\ndialog {\n  max-inline-size: 50rem;\n}\n@media screen and (max-width: 600px) {\n  dialog {\n    min-inline-size: 100% !important;\n    max-inline-size: 100% !important;\n  }\n}\nhtml:has(dialog[open]) {\n  overflow: hidden;\n}\n\n/* src/client/styles/details.css */\ndetails {\n  position: relative;\n  line-height: initial;\n  border-radius: var(--border-radius-sm);\n  min-inline-size: fit-content;\n}\ndetails[open]:not([role=list]) {\n}\ndetails form {\n  padding: var(--gap);\n  gap: var(--gap);\n  display: flex;\n  flex-flow: column nowrap;\n}\ndetails summary {\n  background-color: transparent;\n  border-radius: var(--border-radius-sm);\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\ndetails summary[aria-disabled=true] {\n  pointer-events: none;\n}\ndetails summary input {\n  border: 0;\n}\ndetails summary > * {\n  display: inline;\n  margin: 0;\n}\ndetails summary:hover {\n  background-color: var(--hover);\n}\ndetails[role=list] summary:not([role=button]) {\n  border: 0.1rem solid var(--surface);\n  background-color: var(--back);\n}\ndetails summary::marker {\n  display: none;\n  content: \"\";\n}\ndetails summary::-webkit-details-marker {\n  display: none;\n  content: \"\";\n}\ndetails summary:not(.clear)::after {\n  content: \"\";\n  background-image: var(--icon-chevron);\n  background-position: center;\n  background-size: 1rem;\n  background-repeat: no-repeat;\n  width: 1rem;\n  height: 1rem;\n  rotate: 0.75turn;\n  float: right;\n}\ndetails:is([role=list], [open]) summary::after {\n  rotate: 0turn;\n}\ndetails[role=list][open] summary {\n  border-color: currentColor;\n}\ndetails[role=list][open] summary::before {\n  display: block;\n  z-index: 1;\n  position: fixed;\n  inset: 0;\n  background: 0 0;\n  content: \"\";\n  cursor: default;\n}\ndetails[role=list].top summary::after {\n  background-position: center -0.1rem;\n  rotate: 0.5turn;\n}\ndetails[role=list] ul[role=listbox] {\n  margin: 0;\n  padding: 0.5rem 0;\n  list-style: none;\n  position: absolute;\n  text-align: left;\n  line-height: 2.25;\n  overflow: hidden;\n  border-radius: var(--border-radius-sm);\n  background-color: var(--hover);\n  z-index: 1;\n  width: 100%;\n}\ndetails[role=list].top ul[role=listbox] {\n  bottom: 100%;\n}\ndetails[role=list] ul[role=listbox] li {\n  padding: 0;\n  cursor: pointer;\n}\ndetails[role=list] ul[role=listbox] li:is(:hover, .active) {\n  background-color: var(--active);\n}\ndetails[role=list] ul[role=listbox] li a {\n  text-decoration: none;\n  display: flex;\n  align-items: center;\n  gap: var(--gap-sm);\n  padding: 0 1rem;\n}\ndetails:focus summary {\n  border-color: currentColor;\n}\n\n/* src/client/styles/buttons.css */\nbutton,\n[role=button],\n[type=file]::file-selector-button,\nsummary {\n  text-align: center;\n  text-decoration: none;\n  color: inherit;\n  padding: 0 var(--gap);\n  margin: 0;\n  border: 0.1rem solid transparent;\n  background-color: var(--surface);\n  border-radius: var(--border-radius-sm);\n  font-size: inherit;\n  font-weight: inherit;\n  user-select: none;\n  -webkit-user-select: none;\n  cursor: pointer;\n  display: inline-flex;\n  line-height: 2;\n  min-inline-size: max-content;\n  align-items: center;\n  justify-content: center;\n  gap: var(--gap-sm);\n  overflow: hidden;\n}\n:is(button, [role=button]):is(.action, .box) {\n  padding: var(--gap-sm);\n  aspect-ratio: 1/1;\n  min-width: 2.25rem;\n}\n:is(button, [role=button]).action {\n  border-radius: 50%;\n}\n:is(button, [role=button]).block {\n  display: flex;\n  min-width: 100%;\n}\n:is(button, [role=button]).outline {\n  border-color: var(--surface);\n  background-color: transparent;\n}\n:is(button, [role=button]).dashed {\n  border-style: dashed;\n}\n:is(button, [role=button]).link {\n  background-color: transparent;\n}\n:is(button, [role=button]).strong {\n  font-weight: bold;\n}\n:is(button, [role=button]).primary {\n  background-color: var(--color);\n  color: var(--back);\n}\n:is(button, [role=button]).success {\n  background-color: var(--success);\n}\n:is(button, [role=button]).warning {\n  background-color: var(--warning);\n}\n:is(button, [role=button]).error {\n  background-color: var(--error);\n}\n:is(button, [role=button], [type=file]::file-selector-button):hover {\n  background-color: var(--hover);\n}\n:is(button, [role=button], [type=file]::file-selector-button):hover:active {\n  background-color: var(--active);\n}\n:is(button, [role=button], [type=file]::file-selector-button):is(:focus, :focus-visible, :focus-within) {\n  border-color: currentColor;\n}\n:is(button, [role=button], [type=file]::file-selector-button):is(:disabled, [aria-disabled=true], [aria-busy=true]) {\n  background-color: transparent;\n  border-color: var(--surface);\n  color: var(--gray);\n  cursor: auto;\n}\n[type=file]::file-selector-button {\n  margin-right: var(--gap);\n  font-size: small;\n}\n[type=file]::file-selector-button:hover {\n  background-color: var(--hover);\n}\n[type=file]::file-selector-button:hover:active {\n  background-color: var(--active);\n}\n[role=group] {\n  display: flex;\n  min-width: 100%;\n  padding: 0;\n}\n[role=group] > * {\n  flex: auto;\n  border-radius: 0;\n  margin: 0 -0.0655em;\n}\n[role=group] > *:is(:hover, .active, .primary) {\n  z-index: 1;\n}\n[role=group] > *:first-child {\n  border-right: 0;\n  border-top-left-radius: var(--border-radius-sm);\n  border-bottom-left-radius: var(--border-radius-sm);\n}\n[role=group] > *:last-child {\n  border-left: 0;\n  border-top-right-radius: var(--border-radius-sm);\n  border-bottom-right-radius: var(--border-radius-sm);\n}\n\n/* src/client/styles/toaster.css */\n.toaster .toast-list {\n  position: fixed;\n  width: fit-content;\n  list-style: none;\n  margin: 0;\n  padding: 0;\n  z-index: 10000;\n  line-height: 1;\n}\n.toaster .toast-list > li {\n  margin: 1em;\n}\n.toaster .toast-list.pos-top_center {\n  top: 0;\n  left: 50%;\n  translate: -50%;\n  text-align: center;\n}\n.toaster .toast-list.pos-top_right {\n  top: 0;\n  right: 0;\n}\n.toaster .toast-list.pos-center_right {\n  top: 50%;\n  right: 0;\n  translate: 0 -50%;\n}\n.toaster .toast-list.pos-bottom_right {\n  bottom: 0;\n  right: 0;\n}\n.toaster .toast-list.pos-bottom_center {\n  bottom: 0;\n  left: 50%;\n  translate: -50%;\n  text-align: center;\n}\n.toaster .toast-list.pos-bottom_left {\n  bottom: 0;\n  left: 0;\n}\n.toaster .toast-list.pos-center_left {\n  top: 50%;\n  left: 0;\n  translate: 0 -50%;\n}\n.toaster .toast-list.pos-top_left {\n  top: 0;\n  left: 0;\n}\n.toaster .toast-list.pos-center_center {\n  top: 50%;\n  left: 50%;\n  translate: -50%;\n  text-align: center;\n}\n.toast.pos-sticky {\n  top: calc(var(--gap-lg) * 2.75);\n  margin: auto;\n  z-index: 1;\n}\n.toast {\n  --toast-color: var(--gray);\n  position: relative;\n  overflow: hidden;\n  text-align: center;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  border: 0.1em solid var(--toast-color);\n  border-radius: var(--border-radius-sm);\n  background: var(--back);\n  min-inline-size: fit-content;\n  max-inline-size: max-content;\n  z-index: 0;\n  padding: 0;\n  padding-left: var(--gap);\n}\n.toast > i {\n  margin-right: var(--gap-sm);\n}\n.toast[draggable=true] {\n  cursor: move;\n}\n.toast::before {\n  content: \"\";\n  position: absolute;\n  background: var(--toast-color);\n  width: calc(100% * var(--progress));\n  height: 100%;\n  left: 0;\n  z-index: -1;\n}\n.toast samp {\n  color: inherit;\n  line-height: 1.5;\n  word-break: inherit;\n}\n.toast.success {\n  --toast-color: var(--success);\n}\n.toast.error {\n  --toast-color: var(--error);\n}\n.toast.warning {\n  --toast-color: var(--warning);\n}\n.toast button#close {\n  color: var(--toast-color);\n}\n\n/* src/client/styles/utils.css */\n.loader {\n  color: transparent;\n  width: 1.5em;\n  height: 1.5em;\n  flex: none !important;\n  pointer-events: none;\n  position: relative;\n  margin: auto;\n  display: flex;\n}\n.loader.lg {\n  width: 2.5em;\n  height: 2.5em;\n  flex: 0 2.5em;\n}\n.loading {\n  color: transparent;\n  width: 1.5em;\n  height: 1.5em;\n  flex: none !important;\n  pointer-events: none;\n  position: relative;\n  margin: auto;\n  display: flex;\n}\n.loading.inline {\n  display: inline-flex;\n  vertical-align: bottom;\n  margin: 0;\n}\n.loading.lg {\n  width: 2.5em;\n  height: 2.5em;\n  flex: 0 2.5em;\n}\n.loading::after {\n  animation: loading 750ms infinite linear;\n  background: var(--color);\n  border: 0.125em solid;\n  border-radius: 50%;\n  content: \"\";\n  width: 100%;\n  height: 100%;\n}\n.complete::before {\n  content: \"\\2705   \";\n  display: inline-block;\n  margin-right: 0.5em;\n}\n@keyframes loading {\n  0% {\n    rotate: 0;\n    scale: 0.5;\n  }\n  50% {\n    scale: 1;\n  }\n  100% {\n    rotate: 360deg;\n    scale: 0.5;\n  }\n}\n.scroll-x {\n  max-width: 100%;\n  overflow-x: auto;\n  vertical-align: bottom;\n  white-space: nowrap;\n}\n.scroll-y {\n  overflow-y: auto;\n}\n.scroll {\n  overflow: auto;\n}\n:is(.scroll-x, .scroll-y, .scroll) {\n  scrollbar-width: none;\n}\n:is(.scroll-x, .scroll-y, .scroll)::-webkit-scrollbar {\n  display: none;\n}\n.pos-sticky {\n  position: sticky;\n}\n[data-tooltip] {\n  position: relative;\n  overflow: visible;\n}\n[data-tooltip]::after {\n  content: attr(data-tooltip);\n  display: block;\n  position: absolute;\n  text-align: left;\n  pointer-events: none;\n  bottom: 100%;\n  right: 0%;\n  opacity: 0;\n  background: var(--back);\n  padding: 0.5em 1em;\n  border-radius: 1em;\n  font-size: small;\n  transition: opacity 250ms;\n  color: inherit;\n  min-width: max-content;\n}\n[data-tooltip].tooltip-left::after {\n  bottom: auto;\n  right: 100%;\n}\n[data-tooltip].tooltip-right::after {\n  bottom: auto;\n  right: auto;\n  left: 100%;\n}\n[data-tooltip].tooltip-bottom::after {\n  bottom: auto;\n  top: 100%;\n}\n[data-tooltip]:hover::after {\n  opacity: 1;\n}\n[data-note] {\n  position: relative;\n}\n[data-note]::after {\n  content: attr(data-note);\n  font-weight: 300;\n  font-size: small;\n  display: block;\n  color: var(--gray);\n  padding: var(--gap-sm) 0 var(--gap);\n  top: 100%;\n  left: 0;\n}\n.hidden {\n  visibility: hidden;\n  display: none;\n}\n.overlay {\n  inset: 0;\n  display: grid;\n  position: fixed;\n  place-content: center;\n  z-index: 200;\n  text-align: center;\n  backdrop-filter: blur(0.25em);\n}\n.overlay::after {\n  content: \"\";\n  inset: 0;\n  position: absolute;\n  background: var(--back);\n  opacity: 0.75;\n  z-index: -1;\n}\nhtml:has(.overlay) {\n  overflow: hidden;\n}\n::selection {\n  background-color: var(--surface);\n}\n[aria-busy=true] {\n  vertical-align: top;\n}\n[aria-busy=true]::before {\n  display: inline-block;\n  color: inherit;\n  width: 1em;\n  height: 1em;\n  border: .15em solid currentColor;\n  border-right-color: transparent;\n  border-radius: 1em;\n  content: \"\";\n  vertical-align: text-bottom;\n  animation: spinner .75s linear infinite;\n  opacity: 0.5;\n}\n[aria-busy=true]:empty {\n  text-align: center;\n}\n[aria-busy=true]:not(:empty, button, [role=button])::before {\n  text-align: inherit;\n  margin-right: var(--gap-sm);\n}\n@keyframes spinner {\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n/* src/client/app.css */\n\n/* fakecss:/Users/valexr/Desktop/Jsonik/src/client/App.esbuild-svelte-fake-css */\n</style></head><body><svg id=\"sprite\"><defs><style>#sprite{display:none}#sprite:target{display:inline}</style><symbol id=\"alert-triangle\" viewBox=\"0 0 24 24\"><path d=\"M10.29 3.86 1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0zM12 9v4m0 4h.01\"/></symbol><symbol id=\"arrow-down\" viewBox=\"0 0 24 24\"><path d=\"M12 5v14m7-7-7 7-7-7\"/></symbol><symbol id=\"arrow-left\" viewBox=\"0 0 24 24\"><path d=\"M19 12H5m7 7-7-7 7-7\"/></symbol><symbol id=\"arrow-right\" viewBox=\"0 0 24 24\"><path d=\"M5 12h14m-7-7 7 7-7 7\"/></symbol><symbol id=\"arrow-up\" viewBox=\"0 0 24 24\"><path d=\"M12 19V5m-7 7 7-7 7 7\"/></symbol><symbol id=\"at-sign\" viewBox=\"0 0 24 24\"><circle cx=\"12\" cy=\"12\" r=\"4\"/><path d=\"M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94\"/></symbol><symbol id=\"calendar\" viewBox=\"0 0 24 24\"><rect x=\"3\" y=\"4\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"/><path d=\"M16 2v4M8 2v4m-5 4h18\"/></symbol><symbol id=\"check-square\" viewBox=\"0 0 24 24\"><path d=\"m9 11 3 3L22 4\"/><path d=\"M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11\"/></symbol><symbol id=\"clock\" viewBox=\"0 0 24 24\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M12 6v6l4 2\"/></symbol><symbol id=\"code\" viewBox=\"0 0 24 24\"><path d=\"m16 18 6-6-6-6M8 6l-6 6 6 6\"/></symbol><symbol id=\"database\" viewBox=\"0 0 24 24\"><ellipse cx=\"12\" cy=\"5\" rx=\"9\" ry=\"3\"/><path d=\"M21 12c0 1.66-4 3-9 3s-9-1.34-9-3\"/><path d=\"M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5\"/></symbol><symbol id=\"edit\" viewBox=\"0 0 24 24\"><path d=\"M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7\"/><path d=\"M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z\"/></symbol><symbol id=\"file-plus\" viewBox=\"0 0 24 24\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"/><path d=\"M14 2v6h6m-8 10v-6m-3 3h6\"/></symbol><symbol id=\"file-text\" viewBox=\"0 0 24 24\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"/><path d=\"M14 2v6h6m-4 5H8m8 4H8m2-8H8\"/></symbol><symbol id=\"folder-plus\" viewBox=\"0 0 24 24\"><path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2zm-10-8v6m-3-3h6\"/></symbol><symbol id=\"hard-drive\" viewBox=\"0 0 24 24\"><path d=\"M22 12H2m3.45-6.89L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11zM6 16h.01M10 16h.01\"/></symbol><symbol id=\"hash\" viewBox=\"0 0 24 24\"><path d=\"M4 9h16M4 15h16M10 3 8 21m8-18-2 18\"/></symbol><symbol id=\"image\" viewBox=\"0 0 24 24\"><rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"/><circle cx=\"8.5\" cy=\"8.5\" r=\"1.5\"/><path d=\"m21 15-5-5L5 21\"/></symbol><symbol id=\"key\" viewBox=\"0 0 24 24\"><path d=\"m21 2-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0 3 3L22 7l-3-3m-3.5 3.5L19 4\"/></symbol><symbol id=\"link\" viewBox=\"0 0 24 24\"><path d=\"M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71\"/><path d=\"M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71\"/></symbol><symbol id=\"list\" viewBox=\"0 0 24 24\"><path d=\"M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01\"/></symbol><symbol id=\"move\" viewBox=\"0 0 24 24\"><path d=\"m5 9-3 3 3 3M9 5l3-3 3 3m0 14-3 3-3-3M19 9l3 3-3 3M2 12h20M12 2v20\"/></symbol><symbol id=\"phone\" viewBox=\"0 0 24 24\"><path d=\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\"/></symbol><symbol id=\"plus-square\" viewBox=\"0 0 24 24\"><rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"/><path d=\"M12 8v8m-4-4h8\"/></symbol><symbol id=\"plus\" viewBox=\"0 0 24 24\"><path d=\"M12 5v14m-7-7h14\"/></symbol><symbol id=\"power\" viewBox=\"0 0 24 24\"><path d=\"M18.36 6.64a9 9 0 1 1-12.73 0M12 2v10\"/></symbol><symbol id=\"save\" viewBox=\"0 0 24 24\"><path d=\"M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z\"/><path d=\"M17 21v-8H7v8M7 3v5h8\"/></symbol><symbol id=\"settings\" viewBox=\"0 0 24 24\"><circle cx=\"12\" cy=\"12\" r=\"3\"/><path d=\"M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z\"/></symbol><symbol id=\"trash\" viewBox=\"0 0 24 24\"><path d=\"M3 6h18m-2 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\"/></symbol><symbol id=\"type\" viewBox=\"0 0 24 24\"><path d=\"M4 7V4h16v3M9 20h6M12 4v16\"/></symbol><symbol id=\"user-plus\" viewBox=\"0 0 24 24\"><path d=\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"/><circle cx=\"8.5\" cy=\"7\" r=\"4\"/><path d=\"M20 8v6m3-3h-6\"/></symbol><symbol id=\"users\" viewBox=\"0 0 24 24\"><path d=\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"/><circle cx=\"9\" cy=\"7\" r=\"4\"/><path d=\"M23 21v-2a4 4 0 0 0-3-3.87m-4-12a4 4 0 0 1 0 7.75\"/></symbol><symbol id=\"x\" viewBox=\"0 0 24 24\"><path d=\"M18 6 6 18M6 6l12 12\"/></symbol></defs></svg><script>\n\"use strict\";\n(() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __export = (target, all) => {\n    for (var name2 in all)\n      __defProp(target, name2, { get: all[name2], enumerable: true });\n  };\n\n  // env/reload.js\n  var es;\n  var init_reload = __esm({\n    \"env/reload.js\"() {\n      \"use strict\";\n      es = new EventSource(\"/stream\");\n      es.onerror = () => setTimeout(() => location.reload(true), 100);\n      es.onmessage = console.log;\n      es.onopen = console.log;\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/utils.js\n  function noop() {\n  }\n  function assign(tar, src) {\n    for (const k in src) tar[k] = src[k];\n    return (\n      /** @type {T & S} */\n      tar\n    );\n  }\n  function is_promise(value) {\n    return !!value && (typeof value === \"object\" || typeof value === \"function\") && typeof /** @type {any} */\n    value.then === \"function\";\n  }\n  function add_location(element2, file48, line, column, char) {\n    element2.__svelte_meta = {\n      loc: { file: file48, line, column, char }\n    };\n  }\n  function run(fn) {\n    return fn();\n  }\n  function blank_object() {\n    return /* @__PURE__ */ Object.create(null);\n  }\n  function run_all(fns) {\n    fns.forEach(run);\n  }\n  function is_function(thing) {\n    return typeof thing === \"function\";\n  }\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a && typeof a === \"object\" || typeof a === \"function\";\n  }\n  function src_url_equal(element_src, url2) {\n    if (element_src === url2) return true;\n    if (!src_url_equal_anchor) {\n      src_url_equal_anchor = document.createElement(\"a\");\n    }\n    src_url_equal_anchor.href = url2;\n    return element_src === src_url_equal_anchor.href;\n  }\n  function is_empty(obj) {\n    return Object.keys(obj).length === 0;\n  }\n  function validate_store(store, name2) {\n    if (store != null && typeof store.subscribe !== \"function\") {\n      throw new Error(`'${name2}' is not a store with a 'subscribe' method`);\n    }\n  }\n  function subscribe(store, ...callbacks) {\n    if (store == null) {\n      for (const callback of callbacks) {\n        callback(void 0);\n      }\n      return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n  }\n  function get_store_value(store) {\n    let value;\n    subscribe(store, (_) => value = _)();\n    return value;\n  }\n  function component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n  }\n  function create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n      const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n      return definition[0](slot_ctx);\n    }\n  }\n  function get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n  }\n  function get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n      const lets = definition[2](fn(dirty));\n      if ($$scope.dirty === void 0) {\n        return lets;\n      }\n      if (typeof lets === \"object\") {\n        const merged = [];\n        const len2 = Math.max($$scope.dirty.length, lets.length);\n        for (let i = 0; i < len2; i += 1) {\n          merged[i] = $$scope.dirty[i] | lets[i];\n        }\n        return merged;\n      }\n      return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n  }\n  function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n      const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n      slot.p(slot_context, slot_changes);\n    }\n  }\n  function get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n      const dirty = [];\n      const length = $$scope.ctx.length / 32;\n      for (let i = 0; i < length; i++) {\n        dirty[i] = -1;\n      }\n      return dirty;\n    }\n    return -1;\n  }\n  function exclude_internal_props(props) {\n    const result = {};\n    for (const k in props) if (k[0] !== \"$\") result[k] = props[k];\n    return result;\n  }\n  function compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props) if (!keys.has(k) && k[0] !== \"$\") rest[k] = props[k];\n    return rest;\n  }\n  function compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n      result[key] = true;\n    }\n    return result;\n  }\n  function set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n  }\n  function action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n  }\n  function split_css_unit(value) {\n    const split = typeof value === \"string\" && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n    return split ? [parseFloat(split[1]), split[2] || \"px\"] : [\n      /** @type {number} */\n      value,\n      \"px\"\n    ];\n  }\n  var identity, src_url_equal_anchor, has_prop;\n  var init_utils = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/utils.js\"() {\n      init_reload();\n      identity = (x) => x;\n      has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/environment.js\n  var is_client, now, raf;\n  var init_environment = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/environment.js\"() {\n      init_reload();\n      init_utils();\n      is_client = typeof window !== \"undefined\";\n      now = is_client ? () => window.performance.now() : () => Date.now();\n      raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/loop.js\n  function run_tasks(now2) {\n    tasks.forEach((task) => {\n      if (!task.c(now2)) {\n        tasks.delete(task);\n        task.f();\n      }\n    });\n    if (tasks.size !== 0) raf(run_tasks);\n  }\n  function loop(callback) {\n    let task;\n    if (tasks.size === 0) raf(run_tasks);\n    return {\n      promise: new Promise((fulfill) => {\n        tasks.add(task = { c: callback, f: fulfill });\n      }),\n      abort() {\n        tasks.delete(task);\n      }\n    };\n  }\n  var tasks;\n  var init_loop = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/loop.js\"() {\n      init_reload();\n      init_environment();\n      tasks = /* @__PURE__ */ new Set();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/globals.js\n  var globals;\n  var init_globals = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/globals.js\"() {\n      init_reload();\n      globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : (\n        // @ts-ignore Node typings have this\n        global\n      );\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js\n  var ResizeObserverSingleton;\n  var init_ResizeObserverSingleton = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js\"() {\n      init_reload();\n      init_globals();\n      ResizeObserverSingleton = class _ResizeObserverSingleton {\n        /**\n         * @private\n         * @readonly\n         * @type {WeakMap<Element, import('./private.js').Listener>}\n         */\n        _listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n        /**\n         * @private\n         * @type {ResizeObserver}\n         */\n        _observer = void 0;\n        /** @type {ResizeObserverOptions} */\n        options;\n        /** @param {ResizeObserverOptions} options */\n        constructor(options2) {\n          this.options = options2;\n        }\n        /**\n         * @param {Element} element\n         * @param {import('./private.js').Listener} listener\n         * @returns {() => void}\n         */\n        observe(element2, listener) {\n          this._listeners.set(element2, listener);\n          this._getObserver().observe(element2, this.options);\n          return () => {\n            this._listeners.delete(element2);\n            this._observer.unobserve(element2);\n          };\n        }\n        /**\n         * @private\n         */\n        _getObserver() {\n          return this._observer ?? (this._observer = new ResizeObserver((entries) => {\n            for (const entry of entries) {\n              _ResizeObserverSingleton.entries.set(entry.target, entry);\n              this._listeners.get(entry.target)?.(entry);\n            }\n          }));\n        }\n      };\n      ResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/dom.js\n  function start_hydrating() {\n    is_hydrating = true;\n  }\n  function end_hydrating() {\n    is_hydrating = false;\n  }\n  function append(target, node) {\n    target.appendChild(node);\n  }\n  function get_root_for_style(node) {\n    if (!node) return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && /** @type {ShadowRoot} */\n    root.host) {\n      return (\n        /** @type {ShadowRoot} */\n        root\n      );\n    }\n    return node.ownerDocument;\n  }\n  function append_empty_stylesheet(node) {\n    const style_element = element(\"style\");\n    style_element.textContent = \"/* empty */\";\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n  }\n  function append_stylesheet(node, style) {\n    append(\n      /** @type {Document} */\n      node.head || node,\n      style\n    );\n    return style.sheet;\n  }\n  function insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n  function detach(node) {\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  }\n  function destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n      if (iterations[i]) iterations[i].d(detaching);\n    }\n  }\n  function element(name2) {\n    return document.createElement(name2);\n  }\n  function object_without_properties(obj, exclude) {\n    const target = (\n      /** @type {Pick<T, Exclude<keyof T, K>>} */\n      {}\n    );\n    for (const k in obj) {\n      if (has_prop(obj, k) && // @ts-ignore\n      exclude.indexOf(k) === -1) {\n        target[k] = obj[k];\n      }\n    }\n    return target;\n  }\n  function svg_element(name2) {\n    return document.createElementNS(\"http://www.w3.org/2000/svg\", name2);\n  }\n  function text(data) {\n    return document.createTextNode(data);\n  }\n  function space() {\n    return text(\" \");\n  }\n  function empty() {\n    return text(\"\");\n  }\n  function listen(node, event, handler, options2) {\n    node.addEventListener(event, handler, options2);\n    return () => node.removeEventListener(event, handler, options2);\n  }\n  function prevent_default(fn) {\n    return function(event) {\n      event.preventDefault();\n      return fn.call(this, event);\n    };\n  }\n  function stop_propagation(fn) {\n    return function(event) {\n      event.stopPropagation();\n      return fn.call(this, event);\n    };\n  }\n  function attr(node, attribute, value) {\n    if (value == null) node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n  }\n  function set_attributes(node, attributes2) {\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes2) {\n      if (attributes2[key] == null) {\n        node.removeAttribute(key);\n      } else if (key === \"style\") {\n        node.style.cssText = attributes2[key];\n      } else if (key === \"__value\") {\n        node.value = node[key] = attributes2[key];\n      } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {\n        node[key] = attributes2[key];\n      } else {\n        attr(node, key, attributes2[key]);\n      }\n    }\n  }\n  function get_binding_group_value(group, __value, checked) {\n    const value = /* @__PURE__ */ new Set();\n    for (let i = 0; i < group.length; i += 1) {\n      if (group[i].checked) value.add(group[i].__value);\n    }\n    if (!checked) {\n      value.delete(__value);\n    }\n    return Array.from(value);\n  }\n  function init_binding_group(group) {\n    let _inputs;\n    return {\n      /* push */\n      p(...inputs) {\n        _inputs = inputs;\n        _inputs.forEach((input) => group.push(input));\n      },\n      /* remove */\n      r() {\n        _inputs.forEach((input) => group.splice(group.indexOf(input), 1));\n      }\n    };\n  }\n  function children(element2) {\n    return Array.from(element2.childNodes);\n  }\n  function set_input_value(input, value) {\n    input.value = value == null ? \"\" : value;\n  }\n  function set_style(node, key, value, important) {\n    if (value == null) {\n      node.style.removeProperty(key);\n    } else {\n      node.style.setProperty(key, value, important ? \"important\" : \"\");\n    }\n  }\n  function select_option(select, value, mounting) {\n    for (let i = 0; i < select.options.length; i += 1) {\n      const option = select.options[i];\n      if (option.__value === value) {\n        option.selected = true;\n        return;\n      }\n    }\n    if (!mounting || value !== void 0) {\n      select.selectedIndex = -1;\n    }\n  }\n  function select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n      const option = select.options[i];\n      option.selected = ~value.indexOf(option.__value);\n    }\n  }\n  function select_value(select) {\n    const selected_option = select.querySelector(\":checked\");\n    return selected_option && selected_option.__value;\n  }\n  function select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(\":checked\"), (option) => option.__value);\n  }\n  function toggle_class(element2, name2, toggle) {\n    element2.classList.toggle(name2, !!toggle);\n  }\n  function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    return new CustomEvent(type, { detail, bubbles, cancelable });\n  }\n  function get_custom_elements_slots(element2) {\n    const result = {};\n    element2.childNodes.forEach(\n      /** @param {Element} node */\n      (node) => {\n        result[node.slot || \"default\"] = true;\n      }\n    );\n    return result;\n  }\n  var is_hydrating, always_set_through_set_attribute;\n  var init_dom = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/dom.js\"() {\n      init_reload();\n      init_utils();\n      init_ResizeObserverSingleton();\n      is_hydrating = false;\n      always_set_through_set_attribute = [\"width\", \"height\"];\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/style_manager.js\n  function hash(str) {\n    let hash3 = 5381;\n    let i = str.length;\n    while (i--) hash3 = (hash3 << 5) - hash3 ^ str.charCodeAt(i);\n    return hash3 >>> 0;\n  }\n  function create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n  }\n  function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = \"{\\n\";\n    for (let p = 0; p <= 1; p += step) {\n      const t = a + (b - a) * ease(p);\n      keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;\n    const name2 = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name2]) {\n      rules[name2] = true;\n      stylesheet.insertRule(`@keyframes ${name2} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || \"\";\n    node.style.animation = `${animation ? `${animation}, ` : \"\"}${name2} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name2;\n  }\n  function delete_rule(node, name2) {\n    const previous = (node.style.animation || \"\").split(\", \");\n    const next = previous.filter(\n      name2 ? (anim) => anim.indexOf(name2) < 0 : (anim) => anim.indexOf(\"__svelte\") === -1\n      // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n      node.style.animation = next.join(\", \");\n      active -= deleted;\n      if (!active) clear_rules();\n    }\n  }\n  function clear_rules() {\n    raf(() => {\n      if (active) return;\n      managed_styles.forEach((info) => {\n        const { ownerNode } = info.stylesheet;\n        if (ownerNode) detach(ownerNode);\n      });\n      managed_styles.clear();\n    });\n  }\n  var managed_styles, active;\n  var init_style_manager = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/style_manager.js\"() {\n      init_reload();\n      init_dom();\n      init_environment();\n      managed_styles = /* @__PURE__ */ new Map();\n      active = 0;\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/animations.js\n  function create_animation(node, from, fn, params) {\n    if (!from) return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n      return noop;\n    const {\n      delay = 0,\n      duration = 300,\n      easing = identity,\n      // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n      start: start_time = now() + delay,\n      // @ts-ignore todo:\n      end = start_time + duration,\n      tick: tick2 = noop,\n      css\n    } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name2;\n    function start() {\n      if (css) {\n        name2 = create_rule(node, 0, 1, duration, delay, easing, css);\n      }\n      if (!delay) {\n        started = true;\n      }\n    }\n    function stop() {\n      if (css) delete_rule(node, name2);\n      running = false;\n    }\n    loop((now2) => {\n      if (!started && now2 >= start_time) {\n        started = true;\n      }\n      if (started && now2 >= end) {\n        tick2(1, 0);\n        stop();\n      }\n      if (!running) {\n        return false;\n      }\n      if (started) {\n        const p = now2 - start_time;\n        const t = 0 + 1 * easing(p / duration);\n        tick2(t, 1 - t);\n      }\n      return true;\n    });\n    start();\n    tick2(0, 1);\n    return stop;\n  }\n  function fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== \"absolute\" && style.position !== \"fixed\") {\n      const { width, height } = style;\n      const a = node.getBoundingClientRect();\n      node.style.position = \"absolute\";\n      node.style.width = width;\n      node.style.height = height;\n      add_transform(node, a);\n    }\n  }\n  function add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n      const style = getComputedStyle(node);\n      const transform = style.transform === \"none\" ? \"\" : style.transform;\n      node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n  }\n  var init_animations = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/animations.js\"() {\n      init_reload();\n      init_utils();\n      init_environment();\n      init_loop();\n      init_style_manager();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/lifecycle.js\n  function set_current_component(component) {\n    current_component = component;\n  }\n  function get_current_component() {\n    if (!current_component) throw new Error(\"Function called outside component initialization\");\n    return current_component;\n  }\n  function createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n      const callbacks = component.$$.callbacks[type];\n      if (callbacks) {\n        const event = custom_event(\n          /** @type {string} */\n          type,\n          detail,\n          { cancelable }\n        );\n        callbacks.slice().forEach((fn) => {\n          fn.call(component, event);\n        });\n        return !event.defaultPrevented;\n      }\n      return true;\n    };\n  }\n  function bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n      callbacks.slice().forEach((fn) => fn.call(this, event));\n    }\n  }\n  var current_component;\n  var init_lifecycle = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/lifecycle.js\"() {\n      init_reload();\n      init_dom();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/scheduler.js\n  function schedule_update() {\n    if (!update_scheduled) {\n      update_scheduled = true;\n      resolved_promise.then(flush);\n    }\n  }\n  function tick() {\n    schedule_update();\n    return resolved_promise;\n  }\n  function add_render_callback(fn) {\n    render_callbacks.push(fn);\n  }\n  function add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n  }\n  function flush() {\n    if (flushidx !== 0) {\n      return;\n    }\n    const saved_component = current_component;\n    do {\n      try {\n        while (flushidx < dirty_components.length) {\n          const component = dirty_components[flushidx];\n          flushidx++;\n          set_current_component(component);\n          update(component.$$);\n        }\n      } catch (e) {\n        dirty_components.length = 0;\n        flushidx = 0;\n        throw e;\n      }\n      set_current_component(null);\n      dirty_components.length = 0;\n      flushidx = 0;\n      while (binding_callbacks.length) binding_callbacks.pop()();\n      for (let i = 0; i < render_callbacks.length; i += 1) {\n        const callback = render_callbacks[i];\n        if (!seen_callbacks.has(callback)) {\n          seen_callbacks.add(callback);\n          callback();\n        }\n      }\n      render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n      flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n  }\n  function update($$) {\n    if ($$.fragment !== null) {\n      $$.update();\n      run_all($$.before_update);\n      const dirty = $$.dirty;\n      $$.dirty = [-1];\n      $$.fragment && $$.fragment.p($$.ctx, dirty);\n      $$.after_update.forEach(add_render_callback);\n    }\n  }\n  function flush_render_callbacks(fns) {\n    const filtered = [];\n    const targets = [];\n    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n    targets.forEach((c) => c());\n    render_callbacks = filtered;\n  }\n  var dirty_components, binding_callbacks, render_callbacks, flush_callbacks, resolved_promise, update_scheduled, seen_callbacks, flushidx;\n  var init_scheduler = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/scheduler.js\"() {\n      init_reload();\n      init_utils();\n      init_lifecycle();\n      dirty_components = [];\n      binding_callbacks = [];\n      render_callbacks = [];\n      flush_callbacks = [];\n      resolved_promise = /* @__PURE__ */ Promise.resolve();\n      update_scheduled = false;\n      seen_callbacks = /* @__PURE__ */ new Set();\n      flushidx = 0;\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/transitions.js\n  function wait() {\n    if (!promise) {\n      promise = Promise.resolve();\n      promise.then(() => {\n        promise = null;\n      });\n    }\n    return promise;\n  }\n  function dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? \"intro\" : \"outro\"}${kind}`));\n  }\n  function group_outros() {\n    outros = {\n      r: 0,\n      c: [],\n      p: outros\n      // parent group\n    };\n  }\n  function check_outros() {\n    if (!outros.r) {\n      run_all(outros.c);\n    }\n    outros = outros.p;\n  }\n  function transition_in(block2, local) {\n    if (block2 && block2.i) {\n      outroing.delete(block2);\n      block2.i(local);\n    }\n  }\n  function transition_out(block2, local, detach2, callback) {\n    if (block2 && block2.o) {\n      if (outroing.has(block2)) return;\n      outroing.add(block2);\n      outros.c.push(() => {\n        outroing.delete(block2);\n        if (callback) {\n          if (detach2) block2.d(1);\n          callback();\n        }\n      });\n      block2.o(local);\n    } else if (callback) {\n      callback();\n    }\n  }\n  function create_in_transition(node, fn, params) {\n    const options2 = { direction: \"in\" };\n    let config = fn(node, params, options2);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n      if (animation_name) delete_rule(node, animation_name);\n    }\n    function go() {\n      const {\n        delay = 0,\n        duration = 300,\n        easing = identity,\n        tick: tick2 = noop,\n        css\n      } = config || null_transition;\n      if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n      tick2(0, 1);\n      const start_time = now() + delay;\n      const end_time = start_time + duration;\n      if (task) task.abort();\n      running = true;\n      add_render_callback(() => dispatch(node, true, \"start\"));\n      task = loop((now2) => {\n        if (running) {\n          if (now2 >= end_time) {\n            tick2(1, 0);\n            dispatch(node, true, \"end\");\n            cleanup();\n            return running = false;\n          }\n          if (now2 >= start_time) {\n            const t = easing((now2 - start_time) / duration);\n            tick2(t, 1 - t);\n          }\n        }\n        return running;\n      });\n    }\n    let started = false;\n    return {\n      start() {\n        if (started) return;\n        started = true;\n        delete_rule(node);\n        if (is_function(config)) {\n          config = config(options2);\n          wait().then(go);\n        } else {\n          go();\n        }\n      },\n      invalidate() {\n        started = false;\n      },\n      end() {\n        if (running) {\n          cleanup();\n          running = false;\n        }\n      }\n    };\n  }\n  function create_bidirectional_transition(node, fn, params, intro) {\n    const options2 = { direction: \"both\" };\n    let config = fn(node, params, options2);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    let original_inert_value;\n    function clear_animation() {\n      if (animation_name) delete_rule(node, animation_name);\n    }\n    function init3(program, duration) {\n      const d = (\n        /** @type {Program['d']} */\n        program.b - t\n      );\n      duration *= Math.abs(d);\n      return {\n        a: t,\n        b: program.b,\n        d,\n        duration,\n        start: program.start,\n        end: program.start + duration,\n        group: program.group\n      };\n    }\n    function go(b) {\n      const {\n        delay = 0,\n        duration = 300,\n        easing = identity,\n        tick: tick2 = noop,\n        css\n      } = config || null_transition;\n      const program = {\n        start: now() + delay,\n        b\n      };\n      if (!b) {\n        program.group = outros;\n        outros.r += 1;\n      }\n      if (\"inert\" in node) {\n        if (b) {\n          if (original_inert_value !== void 0) {\n            node.inert = original_inert_value;\n          }\n        } else {\n          original_inert_value = /** @type {HTMLElement} */\n          node.inert;\n          node.inert = true;\n        }\n      }\n      if (running_program || pending_program) {\n        pending_program = program;\n      } else {\n        if (css) {\n          clear_animation();\n          animation_name = create_rule(node, t, b, duration, delay, easing, css);\n        }\n        if (b) tick2(0, 1);\n        running_program = init3(program, duration);\n        add_render_callback(() => dispatch(node, b, \"start\"));\n        loop((now2) => {\n          if (pending_program && now2 > pending_program.start) {\n            running_program = init3(pending_program, duration);\n            pending_program = null;\n            dispatch(node, running_program.b, \"start\");\n            if (css) {\n              clear_animation();\n              animation_name = create_rule(\n                node,\n                t,\n                running_program.b,\n                running_program.duration,\n                0,\n                easing,\n                config.css\n              );\n            }\n          }\n          if (running_program) {\n            if (now2 >= running_program.end) {\n              tick2(t = running_program.b, 1 - t);\n              dispatch(node, running_program.b, \"end\");\n              if (!pending_program) {\n                if (running_program.b) {\n                  clear_animation();\n                } else {\n                  if (!--running_program.group.r) run_all(running_program.group.c);\n                }\n              }\n              running_program = null;\n            } else if (now2 >= running_program.start) {\n              const p = now2 - running_program.start;\n              t = running_program.a + running_program.d * easing(p / running_program.duration);\n              tick2(t, 1 - t);\n            }\n          }\n          return !!(running_program || pending_program);\n        });\n      }\n    }\n    return {\n      run(b) {\n        if (is_function(config)) {\n          wait().then(() => {\n            const opts = { direction: b ? \"in\" : \"out\" };\n            config = config(opts);\n            go(b);\n          });\n        } else {\n          go(b);\n        }\n      },\n      end() {\n        clear_animation();\n        running_program = pending_program = null;\n      }\n    };\n  }\n  var promise, outroing, outros, null_transition;\n  var init_transitions = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/transitions.js\"() {\n      init_reload();\n      init_utils();\n      init_environment();\n      init_loop();\n      init_style_manager();\n      init_dom();\n      init_scheduler();\n      outroing = /* @__PURE__ */ new Set();\n      null_transition = { duration: 0 };\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/await_block.js\n  function handle_promise(promise2, info) {\n    const token = info.token = {};\n    function update2(type, index, key, value) {\n      if (info.token !== token) return;\n      info.resolved = value;\n      let child_ctx = info.ctx;\n      if (key !== void 0) {\n        child_ctx = child_ctx.slice();\n        child_ctx[key] = value;\n      }\n      const block2 = type && (info.current = type)(child_ctx);\n      let needs_flush = false;\n      if (info.block) {\n        if (info.blocks) {\n          info.blocks.forEach((block3, i) => {\n            if (i !== index && block3) {\n              group_outros();\n              transition_out(block3, 1, 1, () => {\n                if (info.blocks[i] === block3) {\n                  info.blocks[i] = null;\n                }\n              });\n              check_outros();\n            }\n          });\n        } else {\n          info.block.d(1);\n        }\n        block2.c();\n        transition_in(block2, 1);\n        block2.m(info.mount(), info.anchor);\n        needs_flush = true;\n      }\n      info.block = block2;\n      if (info.blocks) info.blocks[index] = block2;\n      if (needs_flush) {\n        flush();\n      }\n    }\n    if (is_promise(promise2)) {\n      const current_component2 = get_current_component();\n      promise2.then(\n        (value) => {\n          set_current_component(current_component2);\n          update2(info.then, 1, info.value, value);\n          set_current_component(null);\n        },\n        (error) => {\n          set_current_component(current_component2);\n          update2(info.catch, 2, info.error, error);\n          set_current_component(null);\n          if (!info.hasCatch) {\n            throw error;\n          }\n        }\n      );\n      if (info.current !== info.pending) {\n        update2(info.pending, 0);\n        return true;\n      }\n    } else {\n      if (info.current !== info.then) {\n        update2(info.then, 1, info.value, promise2);\n        return true;\n      }\n      info.resolved = /** @type {T} */\n      promise2;\n    }\n  }\n  var init_await_block = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/await_block.js\"() {\n      init_reload();\n      init_utils();\n      init_transitions();\n      init_scheduler();\n      init_lifecycle();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/each.js\n  function ensure_array_like(array_like_or_iterator) {\n    return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);\n  }\n  function destroy_block(block2, lookup) {\n    block2.d(1);\n    lookup.delete(block2.key);\n  }\n  function outro_and_destroy_block(block2, lookup) {\n    transition_out(block2, 1, 1, () => {\n      lookup.delete(block2.key);\n    });\n  }\n  function fix_and_outro_and_destroy_block(block2, lookup) {\n    block2.f();\n    outro_and_destroy_block(block2, lookup);\n  }\n  function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list2, lookup, node, destroy, create_each_block15, next, get_context) {\n    let o = old_blocks.length;\n    let n = list2.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--) old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = /* @__PURE__ */ new Map();\n    const deltas = /* @__PURE__ */ new Map();\n    const updates = [];\n    i = n;\n    while (i--) {\n      const child_ctx = get_context(ctx, list2, i);\n      const key = get_key(child_ctx);\n      let block2 = lookup.get(key);\n      if (!block2) {\n        block2 = create_each_block15(key, child_ctx);\n        block2.c();\n      } else if (dynamic) {\n        updates.push(() => block2.p(child_ctx, dirty));\n      }\n      new_lookup.set(key, new_blocks[i] = block2);\n      if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = /* @__PURE__ */ new Set();\n    const did_move = /* @__PURE__ */ new Set();\n    function insert2(block2) {\n      transition_in(block2, 1);\n      block2.m(node, next);\n      lookup.set(block2.key, block2);\n      next = block2.first;\n      n--;\n    }\n    while (o && n) {\n      const new_block = new_blocks[n - 1];\n      const old_block = old_blocks[o - 1];\n      const new_key = new_block.key;\n      const old_key = old_block.key;\n      if (new_block === old_block) {\n        next = new_block.first;\n        o--;\n        n--;\n      } else if (!new_lookup.has(old_key)) {\n        destroy(old_block, lookup);\n        o--;\n      } else if (!lookup.has(new_key) || will_move.has(new_key)) {\n        insert2(new_block);\n      } else if (did_move.has(old_key)) {\n        o--;\n      } else if (deltas.get(new_key) > deltas.get(old_key)) {\n        did_move.add(new_key);\n        insert2(new_block);\n      } else {\n        will_move.add(old_key);\n        o--;\n      }\n    }\n    while (o--) {\n      const old_block = old_blocks[o];\n      if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n    }\n    while (n) insert2(new_blocks[n - 1]);\n    run_all(updates);\n    return new_blocks;\n  }\n  function validate_each_keys(ctx, list2, get_context, get_key) {\n    const keys = /* @__PURE__ */ new Map();\n    for (let i = 0; i < list2.length; i++) {\n      const key = get_key(get_context(ctx, list2, i));\n      if (keys.has(key)) {\n        let value = \"\";\n        try {\n          value = `with value '${String(key)}' `;\n        } catch (e) {\n        }\n        throw new Error(\n          `Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n            key\n          )} and ${i} ${value}are duplicates`\n        );\n      }\n      keys.set(key, i);\n    }\n  }\n  var init_each = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/each.js\"() {\n      init_reload();\n      init_transitions();\n      init_utils();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/spread.js\n  function get_spread_update(levels, updates) {\n    const update2 = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n      const o = levels[i];\n      const n = updates[i];\n      if (n) {\n        for (const key in o) {\n          if (!(key in n)) to_null_out[key] = 1;\n        }\n        for (const key in n) {\n          if (!accounted_for[key]) {\n            update2[key] = n[key];\n            accounted_for[key] = 1;\n          }\n        }\n        levels[i] = n;\n      } else {\n        for (const key in o) {\n          accounted_for[key] = 1;\n        }\n      }\n    }\n    for (const key in to_null_out) {\n      if (!(key in update2)) update2[key] = void 0;\n    }\n    return update2;\n  }\n  function get_spread_object(spread_props) {\n    return typeof spread_props === \"object\" && spread_props !== null ? spread_props : {};\n  }\n  var init_spread = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/spread.js\"() {\n      init_reload();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/shared/boolean_attributes.js\n  var _boolean_attributes, boolean_attributes;\n  var init_boolean_attributes = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/shared/boolean_attributes.js\"() {\n      init_reload();\n      _boolean_attributes = /** @type {const} */\n      [\n        \"allowfullscreen\",\n        \"allowpaymentrequest\",\n        \"async\",\n        \"autofocus\",\n        \"autoplay\",\n        \"checked\",\n        \"controls\",\n        \"default\",\n        \"defer\",\n        \"disabled\",\n        \"formnovalidate\",\n        \"hidden\",\n        \"inert\",\n        \"ismap\",\n        \"loop\",\n        \"multiple\",\n        \"muted\",\n        \"nomodule\",\n        \"novalidate\",\n        \"open\",\n        \"playsinline\",\n        \"readonly\",\n        \"required\",\n        \"reversed\",\n        \"selected\"\n      ];\n      boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/shared/utils/names.js\n  var init_names = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/shared/utils/names.js\"() {\n      init_reload();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/ssr.js\n  var init_ssr = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/ssr.js\"() {\n      init_reload();\n      init_lifecycle();\n      init_utils();\n      init_boolean_attributes();\n      init_each();\n      init_names();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/Component.js\n  function bind(component, name2, callback) {\n    const index = component.$$.props[name2];\n    if (index !== void 0) {\n      component.$$.bound[index] = callback;\n      callback(component.$$.ctx[index]);\n    }\n  }\n  function create_component(block2) {\n    block2 && block2.c();\n  }\n  function mount_component(component, target, anchor) {\n    const { fragment: fragment3, after_update } = component.$$;\n    fragment3 && fragment3.m(target, anchor);\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n  }\n  function destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n      flush_render_callbacks($$.after_update);\n      run_all($$.on_destroy);\n      $$.fragment && $$.fragment.d(detaching);\n      $$.on_destroy = $$.fragment = null;\n      $$.ctx = [];\n    }\n  }\n  function make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n      dirty_components.push(component);\n      schedule_update();\n      component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n  }\n  function init(component, options2, instance52, create_fragment52, not_equal, props, append_styles = null, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n      fragment: null,\n      ctx: [],\n      // state\n      props,\n      update: noop,\n      not_equal,\n      bound: blank_object(),\n      // lifecycle\n      on_mount: [],\n      on_destroy: [],\n      on_disconnect: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(options2.context || (parent_component ? parent_component.$$.context : [])),\n      // everything else\n      callbacks: blank_object(),\n      dirty,\n      skip_bound: false,\n      root: options2.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance52 ? instance52(component, options2.props || {}, (i, ret, ...rest) => {\n      const value = rest.length ? rest[0] : ret;\n      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n      return ret;\n    }) : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    $$.fragment = create_fragment52 ? create_fragment52($$.ctx) : false;\n    if (options2.target) {\n      if (options2.hydrate) {\n        start_hydrating();\n        const nodes = children(options2.target);\n        $$.fragment && $$.fragment.l(nodes);\n        nodes.forEach(detach);\n      } else {\n        $$.fragment && $$.fragment.c();\n      }\n      if (options2.intro) transition_in(component.$$.fragment);\n      mount_component(component, options2.target, options2.anchor);\n      end_hydrating();\n      flush();\n    }\n    set_current_component(parent_component);\n  }\n  function get_custom_element_value(prop, value, props_definition, transform) {\n    const type = props_definition[prop]?.type;\n    value = type === \"Boolean\" && typeof value !== \"boolean\" ? value != null : value;\n    if (!transform || !props_definition[prop]) {\n      return value;\n    } else if (transform === \"toAttribute\") {\n      switch (type) {\n        case \"Object\":\n        case \"Array\":\n          return value == null ? null : JSON.stringify(value);\n        case \"Boolean\":\n          return value ? \"\" : null;\n        case \"Number\":\n          return value == null ? null : value;\n        default:\n          return value;\n      }\n    } else {\n      switch (type) {\n        case \"Object\":\n        case \"Array\":\n          return value && JSON.parse(value);\n        case \"Boolean\":\n          return value;\n        case \"Number\":\n          return value != null ? +value : value;\n        default:\n          return value;\n      }\n    }\n  }\n  var SvelteElement, SvelteComponent;\n  var init_Component = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/Component.js\"() {\n      init_reload();\n      init_scheduler();\n      init_lifecycle();\n      init_utils();\n      init_dom();\n      init_transitions();\n      if (typeof HTMLElement === \"function\") {\n        SvelteElement = class extends HTMLElement {\n          /** The Svelte component constructor */\n          $$ctor;\n          /** Slots */\n          $$s;\n          /** The Svelte component instance */\n          $$c;\n          /** Whether or not the custom element is connected */\n          $$cn = false;\n          /** Component props data */\n          $$d = {};\n          /** `true` if currently in the process of reflecting component props back to attributes */\n          $$r = false;\n          /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n          $$p_d = {};\n          /** @type {Record<string, Function[]>} Event listeners */\n          $$l = {};\n          /** @type {Map<Function, Function>} Event listener unsubscribe functions */\n          $$l_u = /* @__PURE__ */ new Map();\n          constructor($$componentCtor, $$slots, use_shadow_dom) {\n            super();\n            this.$$ctor = $$componentCtor;\n            this.$$s = $$slots;\n            if (use_shadow_dom) {\n              this.attachShadow({ mode: \"open\" });\n            }\n          }\n          addEventListener(type, listener, options2) {\n            this.$$l[type] = this.$$l[type] || [];\n            this.$$l[type].push(listener);\n            if (this.$$c) {\n              const unsub = this.$$c.$on(type, listener);\n              this.$$l_u.set(listener, unsub);\n            }\n            super.addEventListener(type, listener, options2);\n          }\n          removeEventListener(type, listener, options2) {\n            super.removeEventListener(type, listener, options2);\n            if (this.$$c) {\n              const unsub = this.$$l_u.get(listener);\n              if (unsub) {\n                unsub();\n                this.$$l_u.delete(listener);\n              }\n            }\n          }\n          async connectedCallback() {\n            this.$$cn = true;\n            if (!this.$$c) {\n              let create_slot2 = function(name2) {\n                return () => {\n                  let node;\n                  const obj = {\n                    c: function create() {\n                      node = element(\"slot\");\n                      if (name2 !== \"default\") {\n                        attr(node, \"name\", name2);\n                      }\n                    },\n                    /**\n                     * @param {HTMLElement} target\n                     * @param {HTMLElement} [anchor]\n                     */\n                    m: function mount(target, anchor) {\n                      insert(target, node, anchor);\n                    },\n                    d: function destroy(detaching) {\n                      if (detaching) {\n                        detach(node);\n                      }\n                    }\n                  };\n                  return obj;\n                };\n              };\n              await Promise.resolve();\n              if (!this.$$cn || this.$$c) {\n                return;\n              }\n              const $$slots = {};\n              const existing_slots = get_custom_elements_slots(this);\n              for (const name2 of this.$$s) {\n                if (name2 in existing_slots) {\n                  $$slots[name2] = [create_slot2(name2)];\n                }\n              }\n              for (const attribute of this.attributes) {\n                const name2 = this.$$g_p(attribute.name);\n                if (!(name2 in this.$$d)) {\n                  this.$$d[name2] = get_custom_element_value(name2, attribute.value, this.$$p_d, \"toProp\");\n                }\n              }\n              for (const key in this.$$p_d) {\n                if (!(key in this.$$d) && this[key] !== void 0) {\n                  this.$$d[key] = this[key];\n                  delete this[key];\n                }\n              }\n              this.$$c = new this.$$ctor({\n                target: this.shadowRoot || this,\n                props: {\n                  ...this.$$d,\n                  $$slots,\n                  $$scope: {\n                    ctx: []\n                  }\n                }\n              });\n              const reflect_attributes = () => {\n                this.$$r = true;\n                for (const key in this.$$p_d) {\n                  this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n                  if (this.$$p_d[key].reflect) {\n                    const attribute_value = get_custom_element_value(\n                      key,\n                      this.$$d[key],\n                      this.$$p_d,\n                      \"toAttribute\"\n                    );\n                    if (attribute_value == null) {\n                      this.removeAttribute(this.$$p_d[key].attribute || key);\n                    } else {\n                      this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n                    }\n                  }\n                }\n                this.$$r = false;\n              };\n              this.$$c.$$.after_update.push(reflect_attributes);\n              reflect_attributes();\n              for (const type in this.$$l) {\n                for (const listener of this.$$l[type]) {\n                  const unsub = this.$$c.$on(type, listener);\n                  this.$$l_u.set(listener, unsub);\n                }\n              }\n              this.$$l = {};\n            }\n          }\n          // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n          // and setting attributes through setAttribute etc, this is helpful\n          attributeChangedCallback(attr2, _oldValue, newValue) {\n            if (this.$$r) return;\n            attr2 = this.$$g_p(attr2);\n            this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, \"toProp\");\n            this.$$c?.$set({ [attr2]: this.$$d[attr2] });\n          }\n          disconnectedCallback() {\n            this.$$cn = false;\n            Promise.resolve().then(() => {\n              if (!this.$$cn && this.$$c) {\n                this.$$c.$destroy();\n                this.$$c = void 0;\n              }\n            });\n          }\n          $$g_p(attribute_name) {\n            return Object.keys(this.$$p_d).find(\n              (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name\n            ) || attribute_name;\n          }\n        };\n      }\n      SvelteComponent = class {\n        /**\n         * ### PRIVATE API\n         *\n         * Do not use, may change at any time\n         *\n         * @type {any}\n         */\n        $$ = void 0;\n        /**\n         * ### PRIVATE API\n         *\n         * Do not use, may change at any time\n         *\n         * @type {any}\n         */\n        $$set = void 0;\n        /** @returns {void} */\n        $destroy() {\n          destroy_component(this, 1);\n          this.$destroy = noop;\n        }\n        /**\n         * @template {Extract<keyof Events, string>} K\n         * @param {K} type\n         * @param {((e: Events[K]) => void) | null | undefined} callback\n         * @returns {() => void}\n         */\n        $on(type, callback) {\n          if (!is_function(callback)) {\n            return noop;\n          }\n          const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n          callbacks.push(callback);\n          return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1) callbacks.splice(index, 1);\n          };\n        }\n        /**\n         * @param {Partial<Props>} props\n         * @returns {void}\n         */\n        $set(props) {\n          if (this.$$set && !is_empty(props)) {\n            this.$$.skip_bound = true;\n            this.$$set(props);\n            this.$$.skip_bound = false;\n          }\n        }\n      };\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/shared/version.js\n  var VERSION, PUBLIC_VERSION;\n  var init_version = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/shared/version.js\"() {\n      init_reload();\n      VERSION = \"4.2.18\";\n      PUBLIC_VERSION = \"4\";\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/dev.js\n  function dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, { version: VERSION, ...detail }, { bubbles: true }));\n  }\n  function append_dev(target, node) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node });\n    append(target, node);\n  }\n  function insert_dev(target, node, anchor) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node, anchor });\n    insert(target, node, anchor);\n  }\n  function detach_dev(node) {\n    dispatch_dev(\"SvelteDOMRemove\", { node });\n    detach(node);\n  }\n  function listen_dev(node, event, handler, options2, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\n    const modifiers = options2 === true ? [\"capture\"] : options2 ? Array.from(Object.keys(options2)) : [];\n    if (has_prevent_default) modifiers.push(\"preventDefault\");\n    if (has_stop_propagation) modifiers.push(\"stopPropagation\");\n    if (has_stop_immediate_propagation) modifiers.push(\"stopImmediatePropagation\");\n    dispatch_dev(\"SvelteDOMAddEventListener\", { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options2);\n    return () => {\n      dispatch_dev(\"SvelteDOMRemoveEventListener\", { node, event, handler, modifiers });\n      dispose();\n    };\n  }\n  function attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null) dispatch_dev(\"SvelteDOMRemoveAttribute\", { node, attribute });\n    else dispatch_dev(\"SvelteDOMSetAttribute\", { node, attribute, value });\n  }\n  function prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\"SvelteDOMSetProperty\", { node, property, value });\n  }\n  function set_data_dev(text2, data) {\n    data = \"\" + data;\n    if (text2.data === data) return;\n    dispatch_dev(\"SvelteDOMSetData\", { node: text2, data });\n    text2.data = /** @type {string} */\n    data;\n  }\n  function ensure_array_like_dev(arg) {\n    if (typeof arg !== \"string\" && !(arg && typeof arg === \"object\" && \"length\" in arg) && !(typeof Symbol === \"function\" && arg && Symbol.iterator in arg)) {\n      throw new Error(\"{#each} only works with iterable values.\");\n    }\n    return ensure_array_like(arg);\n  }\n  function validate_slots(name2, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n      if (!~keys.indexOf(slot_key)) {\n        console.warn(`<${name2}> received an unexpected slot \"${slot_key}\".`);\n      }\n    }\n  }\n  var SvelteComponentDev;\n  var init_dev = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/dev.js\"() {\n      init_reload();\n      init_dom();\n      init_Component();\n      init_names();\n      init_version();\n      init_utils();\n      init_each();\n      SvelteComponentDev = class extends SvelteComponent {\n        /**\n         * For type checking capabilities only.\n         * Does not exist at runtime.\n         * ### DO NOT USE!\n         *\n         * @type {Props}\n         */\n        $$prop_def;\n        /**\n         * For type checking capabilities only.\n         * Does not exist at runtime.\n         * ### DO NOT USE!\n         *\n         * @type {Events}\n         */\n        $$events_def;\n        /**\n         * For type checking capabilities only.\n         * Does not exist at runtime.\n         * ### DO NOT USE!\n         *\n         * @type {Slots}\n         */\n        $$slot_def;\n        /** @param {import('./public.js').ComponentConstructorOptions<Props>} options */\n        constructor(options2) {\n          if (!options2 || !options2.target && !options2.$$inline) {\n            throw new Error(\"'target' is a required option\");\n          }\n          super();\n        }\n        /** @returns {void} */\n        $destroy() {\n          super.$destroy();\n          this.$destroy = () => {\n            console.warn(\"Component was already destroyed\");\n          };\n        }\n        /** @returns {void} */\n        $capture_state() {\n        }\n        /** @returns {void} */\n        $inject_state() {\n        }\n      };\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/index.js\n  var init_internal = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/index.js\"() {\n      init_reload();\n      init_animations();\n      init_await_block();\n      init_dom();\n      init_environment();\n      init_globals();\n      init_each();\n      init_lifecycle();\n      init_loop();\n      init_scheduler();\n      init_spread();\n      init_ssr();\n      init_transitions();\n      init_utils();\n      init_Component();\n      init_dev();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/disclose-version/index.js\n  var init_disclose_version = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/disclose-version/index.js\"() {\n      init_reload();\n      init_version();\n      if (typeof window !== \"undefined\")\n        (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);\n    }\n  });\n\n  // src/client/components/Icon.svelte\n  function create_fragment(ctx) {\n    let svg;\n    let use2;\n    let use_href_value;\n    let svg_class_value;\n    const block2 = {\n      c: function create() {\n        svg = svg_element(\"svg\");\n        use2 = svg_element(\"use\");\n        attr_dev(use2, \"href\", use_href_value = \"#\" + /*icon*/\n        ctx[0]);\n        add_location(use2, file, 16, 4, 293);\n        attr_dev(\n          svg,\n          \"width\",\n          /*size*/\n          ctx[1]\n        );\n        attr_dev(\n          svg,\n          \"height\",\n          /*size*/\n          ctx[1]\n        );\n        attr_dev(svg, \"class\", svg_class_value = \"text-\" + /*color*/\n        ctx[2]);\n        attr_dev(svg, \"fill\", \"none\");\n        attr_dev(svg, \"stroke-width\", \"2\");\n        attr_dev(svg, \"stroke\", \"currentColor\");\n        attr_dev(svg, \"stroke-linecap\", \"round\");\n        attr_dev(svg, \"stroke-linejoin\", \"round\");\n        add_location(svg, file, 6, 0, 104);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, svg, anchor);\n        append_dev(svg, use2);\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (dirty & /*icon*/\n        1 && use_href_value !== (use_href_value = \"#\" + /*icon*/\n        ctx2[0])) {\n          attr_dev(use2, \"href\", use_href_value);\n        }\n        if (dirty & /*size*/\n        2) {\n          attr_dev(\n            svg,\n            \"width\",\n            /*size*/\n            ctx2[1]\n          );\n        }\n        if (dirty & /*size*/\n        2) {\n          attr_dev(\n            svg,\n            \"height\",\n            /*size*/\n            ctx2[1]\n          );\n        }\n        if (dirty & /*color*/\n        4 && svg_class_value !== (svg_class_value = \"text-\" + /*color*/\n        ctx2[2])) {\n          attr_dev(svg, \"class\", svg_class_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(svg);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Icon\", slots, []);\n    let { icon = \"x\" } = $$props;\n    let { size = 16 } = $$props;\n    let { color = \"current\" } = $$props;\n    const writable_props = [\"icon\", \"size\", \"color\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Icon> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(0, icon = $$props2.icon);\n      if (\"size\" in $$props2) $$invalidate(1, size = $$props2.size);\n      if (\"color\" in $$props2) $$invalidate(2, color = $$props2.color);\n    };\n    $$self.$capture_state = () => ({ icon, size, color });\n    $$self.$inject_state = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(0, icon = $$props2.icon);\n      if (\"size\" in $$props2) $$invalidate(1, size = $$props2.size);\n      if (\"color\" in $$props2) $$invalidate(2, color = $$props2.color);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [icon, size, color];\n  }\n  var file, Icon, Icon_default;\n  var init_Icon = __esm({\n    \"src/client/components/Icon.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      file = \"src/client/components/Icon.svelte\";\n      Icon = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance, create_fragment, safe_not_equal, { icon: 0, size: 1, color: 2 });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Icon\",\n            options: options2,\n            id: create_fragment.name\n          });\n        }\n        get icon() {\n          throw new Error(\"<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set icon(value) {\n          throw new Error(\"<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get size() {\n          throw new Error(\"<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set size(value) {\n          throw new Error(\"<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get color() {\n          throw new Error(\"<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set color(value) {\n          throw new Error(\"<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      Icon_default = Icon;\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/index.js\n  var init_runtime = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/index.js\"() {\n      init_reload();\n      init_internal();\n    }\n  });\n\n  // src/client/components/Form.svelte\n  function create_fragment2(ctx) {\n    let form;\n    let validate_action;\n    let current;\n    let mounted;\n    let dispose;\n    const default_slot_template = (\n      /*#slots*/\n      ctx[9].default\n    );\n    const default_slot = create_slot(\n      default_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[8],\n      null\n    );\n    const block2 = {\n      c: function create() {\n        form = element(\"form\");\n        if (default_slot) default_slot.c();\n        attr_dev(\n          form,\n          \"id\",\n          /*id*/\n          ctx[1]\n        );\n        attr_dev(\n          form,\n          \"method\",\n          /*method*/\n          ctx[3]\n        );\n        attr_dev(\n          form,\n          \"action\",\n          /*action*/\n          ctx[4]\n        );\n        attr_dev(\n          form,\n          \"enctype\",\n          /*enctype*/\n          ctx[5]\n        );\n        attr_dev(\n          form,\n          \"class\",\n          /*size*/\n          ctx[2]\n        );\n        toggle_class(\n          form,\n          \"center\",\n          /*center*/\n          ctx[6]\n        );\n        add_location(form, file2, 23, 0, 445);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, form, anchor);\n        if (default_slot) {\n          default_slot.m(form, null);\n        }\n        current = true;\n        if (!mounted) {\n          dispose = [\n            listen_dev(form, \"submit\", prevent_default(\n              /*submit_handler*/\n              ctx[10]\n            ), false, true, false, false),\n            listen_dev(form, \"reset\", prevent_default(\n              /*reset_handler*/\n              ctx[11]\n            ), false, true, false, false),\n            listen_dev(\n              form,\n              \"change\",\n              /*change_handler*/\n              ctx[12],\n              false,\n              false,\n              false,\n              false\n            ),\n            listen_dev(\n              form,\n              \"input\",\n              /*input_handler*/\n              ctx[13],\n              false,\n              false,\n              false,\n              false\n            ),\n            action_destroyer(validate_action = validate.call(\n              null,\n              form,\n              /*validate_function*/\n              ctx[14]\n            ))\n          ];\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (default_slot) {\n          if (default_slot.p && (!current || dirty & /*$$scope*/\n          256)) {\n            update_slot_base(\n              default_slot,\n              default_slot_template,\n              ctx2,\n              /*$$scope*/\n              ctx2[8],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx2[8]\n              ) : get_slot_changes(\n                default_slot_template,\n                /*$$scope*/\n                ctx2[8],\n                dirty,\n                null\n              ),\n              null\n            );\n          }\n        }\n        if (!current || dirty & /*id*/\n        2) {\n          attr_dev(\n            form,\n            \"id\",\n            /*id*/\n            ctx2[1]\n          );\n        }\n        if (!current || dirty & /*method*/\n        8) {\n          attr_dev(\n            form,\n            \"method\",\n            /*method*/\n            ctx2[3]\n          );\n        }\n        if (!current || dirty & /*action*/\n        16) {\n          attr_dev(\n            form,\n            \"action\",\n            /*action*/\n            ctx2[4]\n          );\n        }\n        if (!current || dirty & /*enctype*/\n        32) {\n          attr_dev(\n            form,\n            \"enctype\",\n            /*enctype*/\n            ctx2[5]\n          );\n        }\n        if (!current || dirty & /*size*/\n        4) {\n          attr_dev(\n            form,\n            \"class\",\n            /*size*/\n            ctx2[2]\n          );\n        }\n        if (validate_action && is_function(validate_action.update) && dirty & /*valid*/\n        1) validate_action.update.call(\n          null,\n          /*validate_function*/\n          ctx2[14]\n        );\n        if (!current || dirty & /*size, center*/\n        68) {\n          toggle_class(\n            form,\n            \"center\",\n            /*center*/\n            ctx2[6]\n          );\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(default_slot, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(default_slot, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(form);\n        }\n        if (default_slot) default_slot.d(detaching);\n        mounted = false;\n        run_all(dispose);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment2.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function validate(form, valid) {\n    setTimeout(() => valid(form.checkValidity()), 0);\n    form.oninput = () => valid(form.checkValidity());\n  }\n  function instance2($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Form\", slots, [\"default\"]);\n    let { id = \"\" } = $$props;\n    let { size = \"\" } = $$props;\n    let { method = \"GET\" } = $$props;\n    let { action = \"\" } = $$props;\n    let { enctype = \"multipart/form-data\" } = $$props;\n    let { valid = true } = $$props;\n    let { center = false } = $$props;\n    const writable_props = [\"id\", \"size\", \"method\", \"action\", \"enctype\", \"valid\", \"center\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Form> was created with unknown prop '${key}'`);\n    });\n    function submit_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    function reset_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    function change_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    function input_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    const validate_function = (value) => $$invalidate(0, valid = value);\n    $$self.$$set = ($$props2) => {\n      if (\"id\" in $$props2) $$invalidate(1, id = $$props2.id);\n      if (\"size\" in $$props2) $$invalidate(2, size = $$props2.size);\n      if (\"method\" in $$props2) $$invalidate(3, method = $$props2.method);\n      if (\"action\" in $$props2) $$invalidate(4, action = $$props2.action);\n      if (\"enctype\" in $$props2) $$invalidate(5, enctype = $$props2.enctype);\n      if (\"valid\" in $$props2) $$invalidate(0, valid = $$props2.valid);\n      if (\"center\" in $$props2) $$invalidate(6, center = $$props2.center);\n      if (\"$$scope\" in $$props2) $$invalidate(8, $$scope = $$props2.$$scope);\n    };\n    $$self.$capture_state = () => ({\n      tick,\n      id,\n      size,\n      method,\n      action,\n      enctype,\n      valid,\n      center,\n      validate\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"id\" in $$props2) $$invalidate(1, id = $$props2.id);\n      if (\"size\" in $$props2) $$invalidate(2, size = $$props2.size);\n      if (\"method\" in $$props2) $$invalidate(3, method = $$props2.method);\n      if (\"action\" in $$props2) $$invalidate(4, action = $$props2.action);\n      if (\"enctype\" in $$props2) $$invalidate(5, enctype = $$props2.enctype);\n      if (\"valid\" in $$props2) $$invalidate(0, valid = $$props2.valid);\n      if (\"center\" in $$props2) $$invalidate(6, center = $$props2.center);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      valid,\n      id,\n      size,\n      method,\n      action,\n      enctype,\n      center,\n      validate,\n      $$scope,\n      slots,\n      submit_handler,\n      reset_handler,\n      change_handler,\n      input_handler,\n      validate_function\n    ];\n  }\n  var file2, Form, Form_default;\n  var init_Form = __esm({\n    \"src/client/components/Form.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_runtime();\n      file2 = \"src/client/components/Form.svelte\";\n      Form = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance2, create_fragment2, safe_not_equal, {\n            id: 1,\n            size: 2,\n            method: 3,\n            action: 4,\n            enctype: 5,\n            valid: 0,\n            center: 6,\n            validate: 7\n          });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Form\",\n            options: options2,\n            id: create_fragment2.name\n          });\n        }\n        get id() {\n          throw new Error(\"<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set id(value) {\n          throw new Error(\"<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get size() {\n          throw new Error(\"<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set size(value) {\n          throw new Error(\"<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get method() {\n          throw new Error(\"<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set method(value) {\n          throw new Error(\"<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get action() {\n          throw new Error(\"<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set action(value) {\n          throw new Error(\"<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get enctype() {\n          throw new Error(\"<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set enctype(value) {\n          throw new Error(\"<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get valid() {\n          throw new Error(\"<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set valid(value) {\n          throw new Error(\"<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get center() {\n          throw new Error(\"<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set center(value) {\n          throw new Error(\"<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get validate() {\n          return validate;\n        }\n        set validate(value) {\n          throw new Error(\"<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      Form_default = Form;\n    }\n  });\n\n  // src/client/utils/index.ts\n  function s(count) {\n    return count && count > 1 ? \"s\" : \"\";\n  }\n  function listen2(node, event, handler, options2) {\n    node.addEventListener(event, handler, options2);\n    return () => node.removeEventListener(event, handler, options2);\n  }\n  function uniq(array) {\n    return Array.from(new Set(array));\n  }\n  var init_utils2 = __esm({\n    \"src/client/utils/index.ts\"() {\n      \"use strict\";\n      init_reload();\n    }\n  });\n\n  // src/client/utils/actions.ts\n  function clickout(node, cb) {\n    window.onpointerup = (e) => {\n      const target = e.target;\n      const el = [\"BUTTON\", \"A\"].includes(target.nodeName) ? target : node;\n      if (e.composedPath().includes(el)) return;\n      cb instanceof Function && cb();\n    };\n    return {\n      destroy() {\n        window.onpointerup = null;\n      }\n    };\n  }\n  function expand(node) {\n    if (node.nodeName === \"TEXTAREA\")\n      node.oninput = (e) => {\n        node.style.height = \"auto\";\n        node.style.height = `${node.scrollHeight + 3}px`;\n      };\n  }\n  function getFocusable(node) {\n    return Array.from(node.querySelectorAll(\n      ':is(a, button, input, textarea, select, details, summary):not(:disabled, [type=hidden], .hidden,[tabindex=\"-1\"])'\n      //  [tabindex]:not([tabindex=\"-1\"])`\n    ));\n  }\n  function focusTrap(node) {\n    let focusable = getFocusable(node);\n    const MO = new MutationObserver((ML) => {\n      focusable = getFocusable(node);\n    });\n    MO.observe(node, { childList: true, subtree: true, attributes: true });\n    node.onkeydown = (e) => {\n      if (e.key === \"Tab\") {\n        e.preventDefault();\n        let index = focusable.indexOf(document.activeElement);\n        if (index === -1 && e.shiftKey) index = 0;\n        index += focusable.length + (e.shiftKey ? -1 : 1);\n        index %= focusable.length;\n        focusable[index].focus();\n      }\n    };\n    return {\n      destroy: () => MO.disconnect()\n    };\n  }\n  function keyEscape(node, cb) {\n    window.onkeydown = (e) => {\n      if (e.key === \"Escape\") {\n        e.preventDefault();\n        cb();\n      }\n    };\n  }\n  function scrollIntoView(node, path3) {\n    const update2 = (path4) => {\n      const selectors = `a[href^=\"/${path4}\"][aria-disabled=\"true\"]`;\n      const anchor = node.querySelector(selectors);\n      anchor?.scrollIntoView({ behavior: \"smooth\", inline: \"center\" });\n    };\n    update2(path3);\n    return {\n      update: update2\n    };\n  }\n  var clickOutside;\n  var init_actions = __esm({\n    \"src/client/utils/actions.ts\"() {\n      \"use strict\";\n      init_reload();\n      init_utils2();\n      clickOutside = (node, handler) => {\n        const handleClick = (e) => {\n          const { target, defaultPrevented } = e;\n          if (node && !node.contains(target) && !defaultPrevented && handler) {\n            e.stopImmediatePropagation();\n            handler();\n          }\n        };\n        const unsubscribe = listen2(document, \"click\", handleClick, true);\n        return {\n          destroy: unsubscribe\n        };\n      };\n    }\n  });\n\n  // src/client/components/Dialog.svelte\n  function create_if_block_1(ctx) {\n    let button;\n    let icon;\n    let current;\n    icon = new Icon_default({ $$inline: true });\n    const block2 = {\n      c: function create() {\n        button = element(\"button\");\n        create_component(icon.$$.fragment);\n        attr_dev(button, \"type\", \"reset\");\n        attr_dev(button, \"id\", \"close\");\n        attr_dev(button, \"class\", \"action link\");\n        add_location(button, file3, 83, 16, 1829);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, button, anchor);\n        mount_component(icon, button, null);\n        current = true;\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(button);\n        }\n        destroy_component(icon);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_1.name,\n      type: \"if\",\n      source: \"(65:12) {#if !img}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block(ctx) {\n    let footer;\n    let current;\n    const footer_slot_template = (\n      /*#slots*/\n      ctx[8].footer\n    );\n    const footer_slot = create_slot(\n      footer_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[15],\n      get_footer_slot_context\n    );\n    const footer_slot_or_fallback = footer_slot || fallback_block(ctx);\n    const block2 = {\n      c: function create() {\n        footer = element(\"footer\");\n        if (footer_slot_or_fallback) footer_slot_or_fallback.c();\n        add_location(footer, file3, 92, 12, 2078);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, footer, anchor);\n        if (footer_slot_or_fallback) {\n          footer_slot_or_fallback.m(footer, null);\n        }\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (footer_slot) {\n          if (footer_slot.p && (!current || dirty & /*$$scope*/\n          32768)) {\n            update_slot_base(\n              footer_slot,\n              footer_slot_template,\n              ctx2,\n              /*$$scope*/\n              ctx2[15],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx2[15]\n              ) : get_slot_changes(\n                footer_slot_template,\n                /*$$scope*/\n                ctx2[15],\n                dirty,\n                get_footer_slot_changes\n              ),\n              get_footer_slot_context\n            );\n          }\n        } else {\n          if (footer_slot_or_fallback && footer_slot_or_fallback.p && (!current || dirty & /*valid*/\n          1)) {\n            footer_slot_or_fallback.p(ctx2, !current ? -1 : dirty);\n          }\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(footer_slot_or_fallback, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(footer_slot_or_fallback, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(footer);\n        }\n        if (footer_slot_or_fallback) footer_slot_or_fallback.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block.name,\n      type: \"if\",\n      source: \"(74:8) {#if !info}\",\n      ctx\n    });\n    return block2;\n  }\n  function fallback_block(ctx) {\n    let menu;\n    let button0;\n    let t1;\n    let button1;\n    let t2;\n    let button1_disabled_value;\n    const block2 = {\n      c: function create() {\n        menu = element(\"menu\");\n        button0 = element(\"button\");\n        button0.textContent = \"Cancel\";\n        t1 = space();\n        button1 = element(\"button\");\n        t2 = text(\"Confirm\");\n        attr_dev(button0, \"type\", \"reset\");\n        attr_dev(button0, \"class\", \"link\");\n        add_location(button0, file3, 95, 24, 2208);\n        attr_dev(button1, \"type\", \"submit\");\n        attr_dev(button1, \"class\", \"success\");\n        button1.disabled = button1_disabled_value = !/*valid*/\n        ctx[0];\n        add_location(button1, file3, 96, 24, 2282);\n        attr_dev(menu, \"class\", \"cols col-fit justify-end\");\n        add_location(menu, file3, 94, 20, 2144);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, menu, anchor);\n        append_dev(menu, button0);\n        append_dev(menu, t1);\n        append_dev(menu, button1);\n        append_dev(button1, t2);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*valid*/\n        1 && button1_disabled_value !== (button1_disabled_value = !/*valid*/\n        ctx2[0])) {\n          prop_dev(button1, \"disabled\", button1_disabled_value);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(menu);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: fallback_block.name,\n      type: \"fallback\",\n      source: \"(76:36)                      \",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot(ctx) {\n    let header;\n    let t0;\n    let t1;\n    let article;\n    let t2;\n    let if_block1_anchor;\n    let current;\n    const header_slot_template = (\n      /*#slots*/\n      ctx[8].header\n    );\n    const header_slot = create_slot(\n      header_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[15],\n      get_header_slot_context\n    );\n    let if_block0 = !/*img*/\n    ctx[3] && create_if_block_1(ctx);\n    const default_slot_template = (\n      /*#slots*/\n      ctx[8].default\n    );\n    const default_slot = create_slot(\n      default_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[15],\n      null\n    );\n    let if_block1 = !/*info*/\n    ctx[2] && create_if_block(ctx);\n    const block2 = {\n      c: function create() {\n        header = element(\"header\");\n        if (header_slot) header_slot.c();\n        t0 = space();\n        if (if_block0) if_block0.c();\n        t1 = space();\n        article = element(\"article\");\n        if (default_slot) default_slot.c();\n        t2 = space();\n        if (if_block1) if_block1.c();\n        if_block1_anchor = empty();\n        attr_dev(header, \"class\", \"cols\");\n        toggle_class(header, \"justify-end\", !/*$$slots*/\n        ctx[7].header);\n        add_location(header, file3, 80, 8, 1697);\n        attr_dev(article, \"class\", \"scroll\");\n        add_location(article, file3, 88, 8, 1981);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, header, anchor);\n        if (header_slot) {\n          header_slot.m(header, null);\n        }\n        append_dev(header, t0);\n        if (if_block0) if_block0.m(header, null);\n        insert_dev(target, t1, anchor);\n        insert_dev(target, article, anchor);\n        if (default_slot) {\n          default_slot.m(article, null);\n        }\n        insert_dev(target, t2, anchor);\n        if (if_block1) if_block1.m(target, anchor);\n        insert_dev(target, if_block1_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (header_slot) {\n          if (header_slot.p && (!current || dirty & /*$$scope*/\n          32768)) {\n            update_slot_base(\n              header_slot,\n              header_slot_template,\n              ctx2,\n              /*$$scope*/\n              ctx2[15],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx2[15]\n              ) : get_slot_changes(\n                header_slot_template,\n                /*$$scope*/\n                ctx2[15],\n                dirty,\n                get_header_slot_changes\n              ),\n              get_header_slot_context\n            );\n          }\n        }\n        if (!/*img*/\n        ctx2[3]) {\n          if (if_block0) {\n            if (dirty & /*img*/\n            8) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_1(ctx2);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(header, null);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, () => {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if (!current || dirty & /*$$slots*/\n        128) {\n          toggle_class(header, \"justify-end\", !/*$$slots*/\n          ctx2[7].header);\n        }\n        if (default_slot) {\n          if (default_slot.p && (!current || dirty & /*$$scope*/\n          32768)) {\n            update_slot_base(\n              default_slot,\n              default_slot_template,\n              ctx2,\n              /*$$scope*/\n              ctx2[15],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx2[15]\n              ) : get_slot_changes(\n                default_slot_template,\n                /*$$scope*/\n                ctx2[15],\n                dirty,\n                null\n              ),\n              null\n            );\n          }\n        }\n        if (!/*info*/\n        ctx2[2]) {\n          if (if_block1) {\n            if_block1.p(ctx2, dirty);\n            if (dirty & /*info*/\n            4) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block(ctx2);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, () => {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(header_slot, local);\n        transition_in(if_block0);\n        transition_in(default_slot, local);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(header_slot, local);\n        transition_out(if_block0);\n        transition_out(default_slot, local);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(header);\n          detach_dev(t1);\n          detach_dev(article);\n          detach_dev(t2);\n          detach_dev(if_block1_anchor);\n        }\n        if (header_slot) header_slot.d(detaching);\n        if (if_block0) if_block0.d();\n        if (default_slot) default_slot.d(detaching);\n        if (if_block1) if_block1.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot.name,\n      type: \"slot\",\n      source: '(62:4) <Form method=\\\\\"dialog\\\\\" bind:valid on:submit on:reset on:change on:input>',\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment3(ctx) {\n    let dialog;\n    let form;\n    let updating_valid;\n    let dialog_class_value;\n    let action_action;\n    let current;\n    let mounted;\n    let dispose;\n    function form_valid_binding(value) {\n      ctx[10](value);\n    }\n    let form_props = {\n      method: \"dialog\",\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    };\n    if (\n      /*valid*/\n      ctx[0] !== void 0\n    ) {\n      form_props.valid = /*valid*/\n      ctx[0];\n    }\n    form = new Form_default({ props: form_props, $$inline: true });\n    binding_callbacks.push(() => bind(form, \"valid\", form_valid_binding));\n    form.$on(\n      \"submit\",\n      /*submit_handler*/\n      ctx[11]\n    );\n    form.$on(\n      \"reset\",\n      /*reset_handler*/\n      ctx[12]\n    );\n    form.$on(\n      \"change\",\n      /*change_handler*/\n      ctx[13]\n    );\n    form.$on(\n      \"input\",\n      /*input_handler*/\n      ctx[14]\n    );\n    const block2 = {\n      c: function create() {\n        dialog = element(\"dialog\");\n        create_component(form.$$.fragment);\n        attr_dev(dialog, \"class\", dialog_class_value = `${/*size*/\n        ctx[4]} ${/*from*/\n        ctx[5]}`);\n        toggle_class(\n          dialog,\n          \"img\",\n          /*img*/\n          ctx[3]\n        );\n        add_location(dialog, file3, 73, 0, 1509);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, dialog, anchor);\n        mount_component(form, dialog, null);\n        current = true;\n        if (!mounted) {\n          dispose = [\n            action_destroyer(action_action = /*action*/\n            ctx[6].call(\n              null,\n              dialog,\n              /*open*/\n              ctx[1]\n            )),\n            listen_dev(dialog, \"close\", prevent_default(\n              /*close_handler*/\n              ctx[9]\n            ), false, true, false, false)\n          ];\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, [dirty]) {\n        const form_changes = {};\n        if (dirty & /*$$scope, valid, info, $$slots, img*/\n        32909) {\n          form_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        if (!updating_valid && dirty & /*valid*/\n        1) {\n          updating_valid = true;\n          form_changes.valid = /*valid*/\n          ctx2[0];\n          add_flush_callback(() => updating_valid = false);\n        }\n        form.$set(form_changes);\n        if (!current || dirty & /*size, from*/\n        48 && dialog_class_value !== (dialog_class_value = `${/*size*/\n        ctx2[4]} ${/*from*/\n        ctx2[5]}`)) {\n          attr_dev(dialog, \"class\", dialog_class_value);\n        }\n        if (action_action && is_function(action_action.update) && dirty & /*open*/\n        2) action_action.update.call(\n          null,\n          /*open*/\n          ctx2[1]\n        );\n        if (!current || dirty & /*size, from, img*/\n        56) {\n          toggle_class(\n            dialog,\n            \"img\",\n            /*img*/\n            ctx2[3]\n          );\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(form.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(form.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(dialog);\n        }\n        destroy_component(form);\n        mounted = false;\n        run_all(dispose);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment3.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance3($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Dialog\", slots, [\"header\", \"default\", \"footer\"]);\n    const $$slots = compute_slots(slots);\n    let { open = false } = $$props;\n    let { valid = false } = $$props;\n    let { info = false } = $$props;\n    let { img = false } = $$props;\n    let { size = \"\" } = $$props;\n    let { from = \"\" } = $$props;\n    const dispatch2 = createEventDispatcher();\n    function action(dialog, opened) {\n      const form = dialog.firstChild;\n      focusTrap(dialog);\n      window.onkeydown = (e) => {\n        if (e.key === \"Escape\") {\n          e.preventDefault();\n          dialog.close();\n        }\n      };\n      form.onsubmit = () => dialog.close();\n      form.onreset = () => dialog.close();\n      dialog.onclick = (e) => {\n        e.stopPropagation();\n        const { nodeName } = e.target;\n        if (nodeName === \"DIALOG\") {\n          dialog.close();\n        }\n      };\n      dialog.onclose = () => {\n        dispatch2(\"close\");\n      };\n      function update2(opened2) {\n        $$invalidate(0, valid = form.checkValidity());\n        if (opened2) {\n          dialog.showModal();\n          dispatch2(\"open\");\n        } else {\n          dialog.close();\n        }\n      }\n      function destroy() {\n        $$invalidate(0, valid = form.checkValidity());\n      }\n      update2(opened);\n      return { update: update2, destroy };\n    }\n    const writable_props = [\"open\", \"valid\", \"info\", \"img\", \"size\", \"from\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Dialog> was created with unknown prop '${key}'`);\n    });\n    function close_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    function form_valid_binding(value) {\n      valid = value;\n      $$invalidate(0, valid);\n    }\n    function submit_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    function reset_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    function change_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    function input_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"open\" in $$props2) $$invalidate(1, open = $$props2.open);\n      if (\"valid\" in $$props2) $$invalidate(0, valid = $$props2.valid);\n      if (\"info\" in $$props2) $$invalidate(2, info = $$props2.info);\n      if (\"img\" in $$props2) $$invalidate(3, img = $$props2.img);\n      if (\"size\" in $$props2) $$invalidate(4, size = $$props2.size);\n      if (\"from\" in $$props2) $$invalidate(5, from = $$props2.from);\n      if (\"$$scope\" in $$props2) $$invalidate(15, $$scope = $$props2.$$scope);\n    };\n    $$self.$capture_state = () => ({\n      createEventDispatcher,\n      focusTrap,\n      keyEscape,\n      Icon: Icon_default,\n      Form: Form_default,\n      open,\n      valid,\n      info,\n      img,\n      size,\n      from,\n      dispatch: dispatch2,\n      action\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"open\" in $$props2) $$invalidate(1, open = $$props2.open);\n      if (\"valid\" in $$props2) $$invalidate(0, valid = $$props2.valid);\n      if (\"info\" in $$props2) $$invalidate(2, info = $$props2.info);\n      if (\"img\" in $$props2) $$invalidate(3, img = $$props2.img);\n      if (\"size\" in $$props2) $$invalidate(4, size = $$props2.size);\n      if (\"from\" in $$props2) $$invalidate(5, from = $$props2.from);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      valid,\n      open,\n      info,\n      img,\n      size,\n      from,\n      action,\n      $$slots,\n      slots,\n      close_handler,\n      form_valid_binding,\n      submit_handler,\n      reset_handler,\n      change_handler,\n      input_handler,\n      $$scope\n    ];\n  }\n  var file3, get_footer_slot_changes, get_footer_slot_context, get_header_slot_changes, get_header_slot_context, Dialog, Dialog_default;\n  var init_Dialog = __esm({\n    \"src/client/components/Dialog.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Form();\n      init_Icon();\n      init_actions();\n      init_runtime();\n      file3 = \"src/client/components/Dialog.svelte\";\n      get_footer_slot_changes = (dirty) => ({});\n      get_footer_slot_context = (ctx) => ({});\n      get_header_slot_changes = (dirty) => ({});\n      get_header_slot_context = (ctx) => ({});\n      Dialog = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance3, create_fragment3, safe_not_equal, {\n            open: 1,\n            valid: 0,\n            info: 2,\n            img: 3,\n            size: 4,\n            from: 5\n          });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Dialog\",\n            options: options2,\n            id: create_fragment3.name\n          });\n        }\n        get open() {\n          throw new Error(\"<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set open(value) {\n          throw new Error(\"<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get valid() {\n          throw new Error(\"<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set valid(value) {\n          throw new Error(\"<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get info() {\n          throw new Error(\"<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set info(value) {\n          throw new Error(\"<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get img() {\n          throw new Error(\"<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set img(value) {\n          throw new Error(\"<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get size() {\n          throw new Error(\"<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set size(value) {\n          throw new Error(\"<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get from() {\n          throw new Error(\"<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set from(value) {\n          throw new Error(\"<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      Dialog_default = Dialog;\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/store/index.js\n  function readable(value, start) {\n    return {\n      subscribe: writable(value, start).subscribe\n    };\n  }\n  function writable(value, start = noop) {\n    let stop;\n    const subscribers = /* @__PURE__ */ new Set();\n    function set(new_value) {\n      if (safe_not_equal(value, new_value)) {\n        value = new_value;\n        if (stop) {\n          const run_queue = !subscriber_queue.length;\n          for (const subscriber of subscribers) {\n            subscriber[1]();\n            subscriber_queue.push(subscriber, value);\n          }\n          if (run_queue) {\n            for (let i = 0; i < subscriber_queue.length; i += 2) {\n              subscriber_queue[i][0](subscriber_queue[i + 1]);\n            }\n            subscriber_queue.length = 0;\n          }\n        }\n      }\n    }\n    function update2(fn) {\n      set(fn(value));\n    }\n    function subscribe2(run2, invalidate = noop) {\n      const subscriber = [run2, invalidate];\n      subscribers.add(subscriber);\n      if (subscribers.size === 1) {\n        stop = start(set, update2) || noop;\n      }\n      run2(value);\n      return () => {\n        subscribers.delete(subscriber);\n        if (subscribers.size === 0 && stop) {\n          stop();\n          stop = null;\n        }\n      };\n    }\n    return { set, update: update2, subscribe: subscribe2 };\n  }\n  function derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single ? [stores] : stores;\n    if (!stores_array.every(Boolean)) {\n      throw new Error(\"derived() expects stores as input, got a falsy value\");\n    }\n    const auto = fn.length < 2;\n    return readable(initial_value, (set, update2) => {\n      let started = false;\n      const values = [];\n      let pending = 0;\n      let cleanup = noop;\n      const sync = () => {\n        if (pending) {\n          return;\n        }\n        cleanup();\n        const result = fn(single ? values[0] : values, set, update2);\n        if (auto) {\n          set(result);\n        } else {\n          cleanup = is_function(result) ? result : noop;\n        }\n      };\n      const unsubscribers = stores_array.map(\n        (store, i) => subscribe(\n          store,\n          (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (started) {\n              sync();\n            }\n          },\n          () => {\n            pending |= 1 << i;\n          }\n        )\n      );\n      started = true;\n      sync();\n      return function stop() {\n        run_all(unsubscribers);\n        cleanup();\n        started = false;\n      };\n    });\n  }\n  var subscriber_queue;\n  var init_store = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/store/index.js\"() {\n      init_reload();\n      init_internal();\n      subscriber_queue = [];\n    }\n  });\n\n  // src/client/stores/cacheable.ts\n  function cacheable(key, initial, local) {\n    const { subscribe: subscribe2, set } = writable(initial);\n    const store = typeof window === \"object\" ? local ? localStorage : sessionStorage : void 0;\n    const item = store?.getItem(key) || \"\";\n    try {\n      initial = item ? JSON.parse(item) : initial;\n    } catch {\n      initial = initial;\n    }\n    sync(initial);\n    function sync(value) {\n      store?.setItem(key, JSON.stringify(value));\n      initial = value;\n      return set(initial);\n    }\n    return {\n      get: () => initial,\n      set: (value) => sync(value),\n      update: (fn) => sync(fn(initial)),\n      remove: () => store?.removeItem(key),\n      clear: () => store?.clear(),\n      subscribe: subscribe2\n    };\n  }\n  var init_cacheable = __esm({\n    \"src/client/stores/cacheable.ts\"() {\n      \"use strict\";\n      init_reload();\n      init_store();\n    }\n  });\n\n  // src/client/api/fetch.ts\n  async function fetch_default(url2, { ...options2 }, body) {\n    try {\n      const res = await fetch(base + url2, {\n        ...options2,\n        // headers: {\n        // 'Access-Control-Allow-Origin': '*'\n        //     Authorization: 'Baerer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOjEyMzQ1Njc4OTAsIm5hbWUiOiJKb2huIERvZSIsImFkbWluIjp0cnVlLCJpYXQiOjE1MTYyMzkwMjJ9.OWQ0MjQ0NWY5MWUxMmVjYzRjYTg0OGVlNTQ1ZjUwY2U1YTYzN2E5YmFkOWQ5ZjRiN2ZhZDY0MGM1ZGJlMzI5Ng==',\n        // },\n        credentials: \"include\",\n        body\n      });\n      if (res.status !== 200) throw new Error(await res.text());\n      const text2 = res.headers.get(\"content-type\") === \"text/plain\";\n      return text2 ? res.text() : res.json();\n    } catch (e) {\n      throw e;\n    }\n  }\n  var base;\n  var init_fetch = __esm({\n    \"src/client/api/fetch.ts\"() {\n      \"use strict\";\n      init_reload();\n      base = \"/api\";\n    }\n  });\n\n  // src/client/api/methods.ts\n  async function get(url2, options2) {\n    return fetch_default(url2, { method: \"GET\", ...options2 });\n  }\n  async function post(url2, payload, options2) {\n    return fetch_default(url2, { method: \"POST\", ...options2 }, payload);\n  }\n  async function put(url2, payload, options2) {\n    return fetch_default(url2, { method: \"PUT\", ...options2 }, payload);\n  }\n  async function patch(url2, payload, options2) {\n    return fetch_default(url2, { method: \"PATCH\", ...options2 }, payload);\n  }\n  async function del(url2, payload, options2) {\n    return fetch_default(url2, { method: \"DELETE\", ...options2 }, payload);\n  }\n  var init_methods = __esm({\n    \"src/client/api/methods.ts\"() {\n      \"use strict\";\n      init_reload();\n      init_fetch();\n    }\n  });\n\n  // src/client/stores/files.ts\n  function createFiles() {\n    const { set, subscribe: subscribe2, update: update2 } = writable([]);\n    return {\n      subscribe: subscribe2,\n      async get(folder = \"\", file48 = \"\") {\n        const { files: files2 } = await get(`/files/${folder}/${file48}`);\n        set(files2);\n      },\n      async add(folder = \"\", file48, name2) {\n        file48 = await post(`/files/${folder}/${name2 || file48?.name}`, file48);\n        update2((state2) => uniq(state2.concat(String(file48))));\n      },\n      async move(from = \"\", file48, to = \"\") {\n        file48 = await put(`/files/${from}/${to}?file=${encodeURI(file48)}`);\n        update2((state2) => state2.filter((f) => f !== file48));\n      },\n      async rename(folder = \"\", file48, name2 = \"\") {\n        await patch(`/files/${folder}/${file48}?name=${name2}`);\n        update2((state2) => state2.map((f) => f === file48 ? name2 : f));\n      },\n      async delete(folder = \"\", files2) {\n        const promises = files2?.map((file48) => {\n          del(`/files/${folder}/${file48}`);\n        });\n        await Promise.all(promises);\n        update2((state2) => state2?.filter((f) => !files2?.includes(f)));\n      }\n    };\n  }\n  function createFolders() {\n    const { set, subscribe: subscribe2, update: update2 } = writable([]);\n    return {\n      set,\n      subscribe: subscribe2,\n      update: update2,\n      async get() {\n        const { folders: folders2 } = await get(`/files//`);\n        set(folders2);\n      },\n      async add(folder = \"\") {\n        folder = await post(`/files/${folder}/`);\n        update2((state2) => state2.concat(folder));\n      },\n      async rename(folder = \"\", name2 = \"\") {\n        await patch(`/files/${folder}/?name=${name2}`);\n        update2((state2) => state2.map((f) => f === folder ? name2 : f));\n      },\n      async delete(folder = \"\") {\n        try {\n          await del(`/files/${folder}/`);\n          update2((state2) => state2.filter((f) => f !== folder));\n        } catch (e) {\n        }\n      }\n    };\n  }\n  var files, folders;\n  var init_files = __esm({\n    \"src/client/stores/files.ts\"() {\n      \"use strict\";\n      init_reload();\n      init_store();\n      init_cacheable();\n      init_methods();\n      init_utils2();\n      files = createFiles();\n      folders = createFolders();\n    }\n  });\n\n  // src/client/stores/getable.ts\n  function getable(init3) {\n    const { subscribe: subscribe2, set } = writable(init3);\n    return {\n      subscribe: subscribe2,\n      get: () => init3,\n      set: (value) => set(init3 = value),\n      update: (fn) => set(init3 = fn(init3))\n    };\n  }\n  var init_getable = __esm({\n    \"src/client/stores/getable.ts\"() {\n      \"use strict\";\n      init_reload();\n      init_store();\n    }\n  });\n\n  // src/client/stores/data.ts\n  function createCollections() {\n    const { set, subscribe: subscribe2, update: update2 } = cacheable(\"collections\", []);\n    return {\n      update: update2,\n      subscribe: subscribe2,\n      async get() {\n        const files2 = await get(`/data/`);\n        set(files2);\n      },\n      async rename(file48, name2) {\n        name2 = await patch(`/data/${file48}?name=${name2}`);\n        update2((state2) => uniq(state2.map((f) => f === file48 ? name2 : f)));\n      },\n      async delete(file48) {\n        file48 = await del(`/data/${file48}`);\n        update2((state2) => state2.filter((s2) => s2 !== file48));\n      }\n    };\n  }\n  function createRecords() {\n    const { set, subscribe: subscribe2, update: update2, get: getValue } = getable([]);\n    return {\n      subscribe: subscribe2,\n      id: (id) => getValue().find((v) => v.id === id),\n      async get(file48 = \"\", query3 = \"\") {\n        try {\n          const records2 = await get(`/data/${file48}/records${query3}`);\n          set(records2);\n        } catch (e) {\n          set([]);\n          throw e;\n        }\n      },\n      async set(file48, record) {\n        const records2 = await post(`/data/${file48}/records`, JSON.stringify(record), {\n          headers: { \"Content-Type\": \"application/json\" }\n        });\n        set(records2);\n      },\n      async update(file48, record) {\n        const updated = await put(`/data/${file48}/records`, JSON.stringify(record), {\n          headers: { \"Content-Type\": \"application/json\" }\n        });\n        update2(() => updated);\n      },\n      async upkeys(file48, keys) {\n        const records2 = await patch(`/data/${file48}/records`, JSON.stringify(keys), {\n          headers: { \"Content-Type\": \"application/json\" }\n        });\n        update2(() => records2);\n      },\n      async deleteFiles(file48 = \"\", fileNames) {\n        if (!getValue().length) await this.get(file48);\n        const records2 = fileNames.reduce((a, filename) => {\n          const [recordID, field, ...name2] = filename.split(\"-\");\n          if (name2) {\n            const record = this.id(Number(recordID));\n            if (record) {\n              record[field] = record[field].filter((f) => f.name !== filename);\n              a.push(record);\n            }\n          }\n          return uniq(a);\n        }, []);\n        await this.update(file48, records2);\n      },\n      async delete(file48, IDs) {\n        const records2 = await del(`/data/${file48}/records`, JSON.stringify(IDs), {\n          headers: { \"Content-Type\": \"application/json\" }\n        });\n        update2(() => records2);\n      }\n    };\n  }\n  function createSchemas() {\n    const { set, subscribe: subscribe2, update: update2, get: getValue } = getable([]);\n    return {\n      subscribe: subscribe2,\n      async get(file48 = \"\") {\n        try {\n          const schemas2 = await get(`/data/${file48}/schemas`);\n          set(schemas2);\n        } catch (e) {\n          set([]);\n          throw e;\n        }\n      },\n      async set(file48, schemas2) {\n        await post(`/data/${file48}/schemas`, JSON.stringify(schemas2), {\n          headers: { \"Content-Type\": \"application/json\" }\n        });\n        collections.update((state2) => uniq(state2.concat(file48)));\n      },\n      async update(file48, schemas2) {\n        await put(`/data/${file48}/schemas`, JSON.stringify(schemas2), {\n          headers: { \"Content-Type\": \"application/json\" }\n        });\n      },\n      add: (schema) => update2((state2) => state2.concat(schema)),\n      invalidate: (id) => update2(\n        (state2) => state2.map((s2) => s2.id === id ? { ...s2, valid: false } : s2)\n      ),\n      save: (schema) => update2(\n        (state2) => state2.map((s2) => schema?.id === s2.id ? { ...schema, valid: true } : s2)\n      ),\n      move: (from, to) => update2((state2) => {\n        state2.splice(to, 0, state2.splice(from, 1)[0]);\n        return state2;\n      }),\n      type: (fieldname) => getValue().find((v) => v.name === fieldname)?.type,\n      cleanup: () => update2((state2) => state2.map(({ prevName, ...schema }) => schema)),\n      delete: (id) => update2((state2) => state2.filter((s2) => s2.id !== id)),\n      clear: () => set([])\n    };\n  }\n  var collections, records, schemas, schemaInvalID, schemaNames, schemasKeys;\n  var init_data = __esm({\n    \"src/client/stores/data.ts\"() {\n      \"use strict\";\n      init_reload();\n      init_store();\n      init_methods();\n      init_utils2();\n      init_getable();\n      init_cacheable();\n      collections = createCollections();\n      records = createRecords();\n      schemas = createSchemas();\n      schemaInvalID = derived(schemas, ($schemas) => $schemas.find((s2) => !s2.valid)?.id);\n      schemaNames = derived(schemas, ($schemas) => $schemas.map(({ name: name2 }) => name2));\n      schemasKeys = derived(schemas, ($schemas) => $schemas.reduce((a, { prevName, name: name2 }) => {\n        a[prevName || name2] = name2;\n        return a;\n      }, {}));\n    }\n  });\n\n  // node_modules/.pnpm/svelte-pathfinder@4.8.1_svelte@4.2.18/node_modules/svelte-pathfinder/src/utils.js\n  function getPath() {\n    const pathname2 = getLocation().pathname;\n    if (!pathname2) return;\n    const base2 = getBase();\n    const path3 = trimPrefix(pathname2, base2);\n    return prependPrefix(path3);\n  }\n  function getLocation() {\n    if (!hasLocation) return {};\n    if (prefs.hashbang || useHashbang) {\n      const hash3 = location.hash;\n      return new URL(\n        hash3.indexOf(hashbang) === 0 ? hash3.substring(2) : hash3.substring(1),\n        \"file:\"\n      );\n    }\n    return location;\n  }\n  function getBase() {\n    if (prefs.base) return prefs.base;\n    if (hasLocation && (prefs.hashbang || useHashbang)) return location.pathname;\n    return \"/\";\n  }\n  function getFullURL(url2) {\n    (prefs.hashbang || useHashbang) && (url2 = hashbang + url2);\n    const base2 = getBase();\n    return (base2[base2.length - 1] === \"/\" ? base2.substring(0, base2.length - 1) : base2) + url2;\n  }\n  function getShortURL(url2) {\n    url2 = trimPrefix(url2, getLocation().origin);\n    const base2 = getBase();\n    url2 = trimPrefix(url2, base2);\n    (prefs.hashbang || useHashbang) && (url2 = trimPrefix(url2, hashbang));\n    return prependPrefix(url2);\n  }\n  function isBtn(el) {\n    const tagName = el.tagName.toLowerCase();\n    const type = el.type && el.type.toLowerCase();\n    return tagName === \"button\" || tagName === \"input\" && [\"button\", \"submit\", \"image\"].includes(type);\n  }\n  function closest(el, tagName) {\n    while (el && el.nodeName.toLowerCase() !== tagName) el = el.parentNode;\n    return !el || el.nodeName.toLowerCase() !== tagName ? null : el;\n  }\n  function setScroll(scroll, hash3 = \"\") {\n    const anchor = trimPrefix(normalizeHash(hash3), \"#\");\n    if (scroll && prefs.scroll) {\n      const opts = isObj(prefs.scroll) ? { ...prefs.scroll, ...scroll } : scroll;\n      const { top = 0, left = 0 } = scroll;\n      const { scrollHeight, scrollWidth } = document.documentElement;\n      if (top <= scrollHeight && left <= scrollWidth) return scrollTo(opts);\n      const cancel = observeResize((entries) => {\n        if (!entries[0]) return cancel();\n        if ((!top || entries[0].contentRect.height >= top) && (!left || entries[0].contentRect.width >= left)) {\n          cancel();\n          scrollTo(opts);\n        }\n      }, document.documentElement);\n    } else if (anchor && prefs.anchor) {\n      const opts = isObj(prefs.anchor) ? prefs.anchor : {};\n      const el = document.getElementById(anchor);\n      if (el) return scrollTo(opts, el);\n      const cancel = observeDom(() => {\n        const el2 = document.getElementById(anchor);\n        if (el2) {\n          cancel();\n          scrollTo(opts, el2);\n        }\n      });\n    } else if (prefs.scroll) {\n      scrollTo();\n    }\n  }\n  function setFocus(keepFocusId, activeElement) {\n    if (!prefs.focus) return;\n    setTimeout(() => {\n      const autofocus = focus();\n      if (autofocus) return autofocus.focus();\n      const cancel = observeDom(() => {\n        const autofocus2 = focus();\n        if (autofocus2) {\n          cancel();\n          autofocus2.focus();\n        }\n      });\n      const body = document.body;\n      const tabindex = body.getAttribute(\"tabindex\");\n      body.tabIndex = -1;\n      body.focus({ preventScroll: true });\n      if (tabindex !== null) {\n        body.setAttribute(\"tabindex\", tabindex);\n      } else {\n        body.removeAttribute(\"tabindex\");\n      }\n      getSelection().removeAllRanges();\n    });\n    function focus() {\n      if (keepFocusId) {\n        return document.getElementById(keepFocusId);\n      } else if (document.activeElement !== activeElement && document.activeElement !== document.body) {\n        return document.activeElement;\n      } else {\n        return document.querySelector(\"[autofocus]\");\n      }\n    }\n  }\n  function parseQuery(str = \"\", { decode = decodeURIComponent } = {}) {\n    return str ? str.replace(\"?\", \"\").replace(/\\+/g, \" \").split(\"&\").filter(Boolean).reduce((obj, p) => {\n      let [key, val] = p.split(/=(.*)/, 2);\n      key = decode(key || \"\");\n      val = decode(val || \"\");\n      let o = parseKeys(key, val);\n      obj = Object.keys(o).reduce((obj2, key2) => {\n        const val2 = prefs.convertTypes ? convertType(o[key2]) : o[key2];\n        if (obj2[key2]) {\n          Array.isArray(obj2[key2]) ? obj2[key2] = obj2[key2].concat(val2) : Object.assign(obj2[key2], val2);\n        } else {\n          obj2[key2] = val2;\n        }\n        return obj2;\n      }, obj);\n      return obj;\n    }, {}) : {};\n  }\n  function stringifyQuery(obj = {}, { encode = encodeURIComponent } = {}) {\n    return Object.keys(obj).reduce((a, k) => {\n      if (Object.prototype.hasOwnProperty.call(obj, k) && isNaN(parseInt(k, 10))) {\n        if (Array.isArray(obj[k])) {\n          if (prefs.array.format === \"separator\") {\n            a.push(`${k}=${obj[k].join(prefs.array.separator)}`);\n          } else {\n            obj[k].forEach((v) => a.push(`${k}[]=${encode(v)}`));\n          }\n        } else if (isObj(obj[k])) {\n          let o = parseKeys(k, obj[k]);\n          a.push(stringifyObj(o));\n        } else {\n          a.push(`${k}=${encode(obj[k])}`);\n        }\n      }\n      return a;\n    }, []).join(\"&\");\n  }\n  function injectParams(pattern2, params, { encode = encodeURIComponent } = {}) {\n    return pattern2.replace(/(\\/|^)([:*][^/]*?)(\\?)?(?=[/.]|$)/g, (param, _, key) => {\n      param = params[key === \"*\" ? \"wild\" : key.substring(1)];\n      return param ? `/${encode(param)}` : \"\";\n    });\n  }\n  function parseParams(path3 = \"\", pattern2 = \"*\", { loose = false, sensitive = false, blank = false, decode = decodeURIComponent } = {}) {\n    const blanks = {};\n    const rgx = pattern2 instanceof RegExp ? pattern2 : pattern2.split(\"/\").reduce((rgx2, seg, i, { length }) => {\n      if (seg) {\n        const pfx = seg[0];\n        if (pfx === \"*\") {\n          blanks[\"wild\"] = void 0;\n          rgx2 += \"/(?<wild>.*)\";\n        } else if (pfx === \":\") {\n          const opt = seg.indexOf(\"?\", 1);\n          const ext = seg.indexOf(\".\", 1);\n          const isOpt = !!~opt;\n          const isExt = !!~ext;\n          const key = seg.substring(1, isOpt ? opt : isExt ? ext : seg.length);\n          blanks[key] = void 0;\n          rgx2 += isOpt && !isExt ? `(?:/(?<${key}>[^/]+?))?` : `/(?<${key}>[^/]+?)`;\n          if (isExt) rgx2 += `${isOpt ? \"?\" : \"\"}\\\\${seg.substring(ext)}`;\n        } else {\n          rgx2 += `/${seg}`;\n        }\n      }\n      if (i === length - 1) {\n        rgx2 += loose ? \"(?:$|/)\" : \"/?$\";\n      }\n      return rgx2;\n    }, \"^\");\n    const flags = sensitive ? \"\" : \"i\";\n    const matches = new RegExp(rgx, flags).exec(path3);\n    return matches ? Object.entries(matches.groups || {}).reduce((params, [key, val]) => {\n      const value = decode(val);\n      params[key] = prefs.convertTypes ? convertType(value) : value;\n      return params;\n    }, {}) : blank ? blanks : null;\n  }\n  function normalizeHash(fragment3, { decode = decodeURIComponent } = {}) {\n    return decode(fragment3);\n  }\n  function prependPrefix(str, pfx = \"/\", strict = false) {\n    str += \"\";\n    return !str && strict ? str : str.indexOf(pfx) !== 0 ? pfx + str : str;\n  }\n  function trimPrefix(str, pfx) {\n    return (str + \"\").indexOf(pfx) === 0 ? str.substring(pfx.length) : str;\n  }\n  function isObj(obj) {\n    return !Array.isArray(obj) && typeof obj === \"object\" && obj !== null;\n  }\n  function isFn(fn) {\n    return typeof fn === \"function\";\n  }\n  function shallowCopy(value) {\n    if (typeof value !== \"object\" || value === null) return value;\n    return Object.create(Object.getPrototypeOf(value), Object.getOwnPropertyDescriptors(value));\n  }\n  function hookLauncher(hooks) {\n    return (...args) => {\n      const arr = [...hooks];\n      return !(prefs.breakHooks ? arr.some((cb) => cb(...args) === false) : arr.reduce((stop, cb) => cb(...args) === false || stop, false));\n    };\n  }\n  function listenEvent(...args) {\n    window.addEventListener(...args);\n    return () => window.removeEventListener(...args);\n  }\n  function scrollTo({ top = 0, left = 0, ...opts } = {}, el) {\n    if (el) {\n      document.documentElement.scrollIntoView ? el.scrollIntoView({ behavior: \"smooth\", ...opts }) : window.scrollTo({ top: el.offsetTop - top, behavior: \"smooth\", ...opts });\n    } else {\n      window.scrollTo({ top, left, behavior: \"smooth\", ...opts });\n    }\n  }\n  function observeResize(cb, el, t = 5e3) {\n    const observer = new ResizeObserver(cb);\n    observer.observe(el);\n    const off = () => observer.unobserve(el);\n    setTimeout(off, t);\n    return off;\n  }\n  function observeDom(cb, t = 5e3) {\n    const observer = new MutationObserver(cb);\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n    const off = () => observer.disconnect();\n    setTimeout(off, t);\n    return off;\n  }\n  function convertType(val) {\n    if (Array.isArray(val)) {\n      val[val.length - 1] = convertType(val[val.length - 1]);\n      return val;\n    } else if (typeof val === \"object\") {\n      return Object.entries(val).reduce((obj, [k, v]) => {\n        obj[k] = convertType(v);\n        return obj;\n      }, {});\n    }\n    if (val === \"true\" || val === \"false\") {\n      return val === \"true\";\n    } else if (val === \"null\") {\n      return null;\n    } else if (val === \"undefined\") {\n      return void 0;\n    } else if (val !== \"\" && !isNaN(Number(val)) && Number(val).toString() === val) {\n      return Number(val);\n    } else if (prefs.array.format === \"separator\" && typeof val === \"string\") {\n      const arr = val.split(prefs.array.separator);\n      return arr.length > 1 ? arr : val;\n    }\n    return val;\n  }\n  function parseKeys(key, val) {\n    const brackets = /(\\[[^[\\]]*])/, child = /(\\[[^[\\]]*])/g;\n    let seg = brackets.exec(key), parent = seg ? key.slice(0, seg.index) : key, keys = [];\n    parent && keys.push(parent);\n    let i = 0;\n    while ((seg = child.exec(key)) && i < prefs.nesting) {\n      i++;\n      keys.push(seg[1]);\n    }\n    seg && keys.push(`[${key.slice(seg.index)}]`);\n    return parseObj(keys, val);\n  }\n  function parseObj(chain, val) {\n    let leaf = val;\n    for (let i = chain.length - 1; i >= 0; --i) {\n      let root = chain[i], obj;\n      if (root === \"[]\") {\n        obj = [].concat(leaf);\n      } else {\n        obj = {};\n        const key = root.charAt(0) === \"[\" && root.charAt(root.length - 1) === \"]\" ? root.slice(1, -1) : root, j = parseInt(key, 10);\n        if (!isNaN(j) && root !== key && String(j) === key && j >= 0) {\n          obj = [];\n          obj[j] = prefs.convertTypes ? convertType(leaf) : leaf;\n        } else {\n          obj[key] = leaf;\n        }\n      }\n      leaf = obj;\n    }\n    return leaf;\n  }\n  function stringifyObj(obj = {}, nesting = \"\") {\n    return Object.entries(obj).map(([key, val]) => {\n      if (typeof val === \"object\") {\n        return stringifyObj(val, nesting ? `${nesting}[${key}]` : key);\n      } else {\n        return `${nesting}[${key}]=${val}`;\n      }\n    }).join(\"&\");\n  }\n  var specialLinks, hasLocation, hasProcess, hasHistory, hasPushState, hasWindow, isSubWindow, isFileScheme, sideEffect, useHashbang, hashbang, prefs;\n  var init_utils3 = __esm({\n    \"node_modules/.pnpm/svelte-pathfinder@4.8.1_svelte@4.2.18/node_modules/svelte-pathfinder/src/utils.js\"() {\n      init_reload();\n      specialLinks = /^((mailto:)|(tel:)|(sms:)|(data:)|(blob:)|(javascript:)|(ftp(s?):\\/\\/)|(file:\\/\\/))/;\n      hasLocation = typeof location !== \"undefined\";\n      hasProcess = typeof process !== \"undefined\";\n      hasHistory = typeof history !== \"undefined\";\n      hasPushState = hasHistory && isFn(history.pushState);\n      hasWindow = typeof window !== \"undefined\";\n      isSubWindow = hasWindow && window !== window.parent;\n      isFileScheme = hasLocation && (location.protocol === \"file:\" || /[-_\\w]+[.][\\w]+$/i.test(location.pathname));\n      sideEffect = hasWindow && hasHistory && hasLocation && !isSubWindow;\n      useHashbang = !hasPushState || isFileScheme;\n      hashbang = \"#!\";\n      prefs = {\n        array: {\n          separator: \",\",\n          format: \"bracket\"\n        },\n        convertTypes: true,\n        breakHooks: true,\n        hashbang: false,\n        anchor: false,\n        scroll: false,\n        focus: false,\n        nesting: 3,\n        sideEffect,\n        base: \"\"\n      };\n    }\n  });\n\n  // node_modules/.pnpm/svelte-pathfinder@4.8.1_svelte@4.2.18/node_modules/svelte-pathfinder/src/stores.js\n  function createParamStore(path3) {\n    return (pattern2, options2 = {}) => {\n      if (pattern2 instanceof RegExp)\n        throw new Error(\"Paramable does not support RegExp patterns.\");\n      let params;\n      pattern2 = pattern2.replace(/\\/$/, \"\");\n      const { subscribe: subscribe2 } = writable({}, (set2) => {\n        return path3.subscribe(($path) => {\n          params = parseParams($path.toString(), pattern2, { blank: true, ...options2 });\n          set2(shallowCopy(params));\n        });\n      });\n      function set(value = {}) {\n        if (Object.entries(params).some(([key, val]) => val !== value[key])) {\n          path3.update(($path) => {\n            const tail = options2.loose ? prependPrefix($path.slice(pattern2.split(\"/\").length - 1).join(\"/\")) : \"\";\n            return injectParams(pattern2 + tail, value);\n          });\n        }\n      }\n      return {\n        get() {\n          return get_store_value(this);\n        },\n        update(fn) {\n          set(fn(this.get()));\n        },\n        subscribe: subscribe2,\n        set\n      };\n    };\n  }\n  function createParsableStore(parse) {\n    return (value, cbx) => {\n      let serialized = value && value.toString();\n      !Array.isArray(cbx) && (cbx = [cbx]);\n      const hooks = new Set(cbx);\n      const runHooks = hookLauncher(hooks);\n      const { subscribe: subscribe2, set } = writable(value = parse(value), () => () => hooks.clear());\n      function update2(val) {\n        val = parse(val);\n        if (val.toString() !== serialized && runHooks(val, value, parse.name) !== false) {\n          serialized = val.toString();\n          value = val;\n          set(value);\n        }\n      }\n      runHooks(null, value, parse.name);\n      return {\n        subscribe: subscribe2,\n        update(fn) {\n          update2(fn(get_store_value(this)));\n        },\n        set(value2) {\n          update2(value2);\n        },\n        hook(cb) {\n          if (isFn(cb)) {\n            hooks.add(cb);\n            cb(null, value, parse.name);\n          }\n          return () => hooks.delete(cb);\n        }\n      };\n    };\n  }\n  var pathable, queryable, fragmentable;\n  var init_stores = __esm({\n    \"node_modules/.pnpm/svelte-pathfinder@4.8.1_svelte@4.2.18/node_modules/svelte-pathfinder/src/stores.js\"() {\n      init_reload();\n      init_store();\n      init_utils3();\n      pathable = createParsableStore(function path($path = \"\") {\n        if (typeof $path === \"string\") $path = trimPrefix($path, \"/\").split(\"/\");\n        return !Object.prototype.hasOwnProperty.call($path, \"toString\") ? Object.defineProperty($path, \"toString\", {\n          value() {\n            return prependPrefix(this.join(\"/\"));\n          },\n          configurable: false,\n          writable: false\n        }) : $path;\n      });\n      queryable = createParsableStore(function query($query = \"\") {\n        if (typeof $query === \"string\") $query = parseQuery($query);\n        return !Object.prototype.hasOwnProperty.call($query, \"toString\") ? Object.defineProperty($query, \"toString\", {\n          value() {\n            return prependPrefix(stringifyQuery(this), \"?\", true);\n          },\n          configurable: false,\n          writable: false\n        }) : $query;\n      });\n      fragmentable = createParsableStore(function fragment($fragment = \"\") {\n        return prependPrefix(normalizeHash($fragment), \"#\", true);\n      });\n    }\n  });\n\n  // node_modules/.pnpm/svelte-pathfinder@4.8.1_svelte@4.2.18/node_modules/svelte-pathfinder/src/index.js\n  function before() {\n    if (!prefs.scroll && !prefs.focus) return;\n    state.update(($state = {}) => {\n      prefs.scroll && ($state._scroll = {\n        top: window.pageYOffset,\n        left: window.pageXOffset\n      });\n      prefs.focus && ($state._focus = document.activeElement.id);\n      return $state;\n    });\n  }\n  function after(url2, state2) {\n    const anchor = url2.indexOf(\"#\") >= 0 ? url2.slice(url2.indexOf(\"#\")) : \"\";\n    const activeElement = document.activeElement;\n    !isObj(state2) && (state2 = {});\n    tick().then(() => setFocus(state2._focus, activeElement)).then(() => setScroll(state2._scroll, anchor));\n  }\n  function goto(url2 = \"\", data = {}) {\n    const { pathname: pathname2, search: search2, hash: hash3 } = url2 instanceof URL ? url2 : new URL(getShortURL(url2), \"file:\");\n    path2.set(pathname2);\n    query2.set(search2);\n    fragment2.set(hash3);\n    tick().then(() => state.set(data || {}));\n  }\n  function redirect(url2, data) {\n    tick().then(() => {\n      replace = true;\n      goto(url2, data);\n    });\n  }\n  function click(e) {\n    if (!e.target || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button || e.which !== 1 || e.defaultPrevented)\n      return;\n    const a = closest(e.target, \"a\");\n    if (!a || a.target || a.hasAttribute(\"download\") || a.hasAttribute(\"rel\") && a.getAttribute(\"rel\").includes(\"external\"))\n      return;\n    const href = a.getAttribute(\"href\");\n    const url2 = a.href;\n    if (!href || url2.indexOf(location.origin) !== 0 || specialLinks.test(href) || !prefs.hashbang && !useHashbang && href.startsWith(\"#\"))\n      return;\n    e.preventDefault();\n    goto(url2, Object.assign({}, a.dataset));\n  }\n  function submit(e) {\n    if (!e.target || e.defaultPrevented) return;\n    const form = e.target;\n    const btn = e.submitter || isBtn(document.activeElement) && document.activeElement;\n    let action = form.action;\n    let method = form.method;\n    let target = form.target;\n    if (btn) {\n      btn.hasAttribute(\"formaction\") && (action = btn.formAction);\n      btn.hasAttribute(\"formmethod\") && (method = btn.formMethod);\n      btn.hasAttribute(\"formtarget\") && (target = btn.formTarget);\n    }\n    if (method && method.toLowerCase() !== \"get\") return;\n    if (target && target.toLowerCase() !== \"_self\") return;\n    const { pathname: pathname2, hash: hash3 } = new URL(action);\n    const search2 = [];\n    const state2 = {};\n    const elements = form.elements;\n    const len2 = elements.length;\n    for (let i = 0; i < len2; i++) {\n      const element2 = elements[i];\n      if (!element2.name || element2.disabled) continue;\n      if ([\"checkbox\", \"radio\"].includes(element2.type) && !element2.checked) {\n        continue;\n      }\n      if (isBtn(element2) && element2 !== btn) {\n        continue;\n      }\n      if (element2.type === \"hidden\") {\n        state2[element2.name] = element2.value;\n        continue;\n      }\n      search2.push(`${element2.name}=${element2.value}`);\n    }\n    let url2 = prependPrefix(`${pathname2}?${search2.join(\"&\")}${hash3}`);\n    if (hasProcess && url2.match(/^\\/[a-zA-Z]:\\//)) {\n      url2 = url2.replace(/^\\/[a-zA-Z]:\\//, \"/\");\n    }\n    e.preventDefault();\n    goto(url2, state2);\n  }\n  var pathname, search, hash2, init2, popstate, replace, len, path2, query2, fragment2, state, url, pattern, paramable;\n  var init_src = __esm({\n    \"node_modules/.pnpm/svelte-pathfinder@4.8.1_svelte@4.2.18/node_modules/svelte-pathfinder/src/index.js\"() {\n      init_reload();\n      init_runtime();\n      init_store();\n      init_utils3();\n      init_stores();\n      pathname = getPath();\n      ({ search, hash: hash2 } = getLocation());\n      init2 = true;\n      popstate = false;\n      replace = false;\n      len = 0;\n      path2 = pathable(pathname, before);\n      query2 = queryable(search, before);\n      fragment2 = fragmentable(hash2, before);\n      state = writable({});\n      url = derived(\n        [path2, query2, fragment2],\n        ([$path, $query, $fragment], set) => {\n          let skip = false;\n          tick().then(() => {\n            if (skip) return;\n            set($path + $query + $fragment);\n          });\n          return () => skip = true;\n        },\n        pathname + search + hash2\n      );\n      pattern = derived(path2, ($path) => parseParams.bind(null, $path.toString()));\n      if (sideEffect || isSubWindow) {\n        const cleanup = /* @__PURE__ */ new Set();\n        cleanup.add(\n          url.subscribe(($url) => {\n            if (!init2 && !popstate && prefs.sideEffect) {\n              if (hasPushState) {\n                history[replace ? \"replaceState\" : \"pushState\"]({}, null, getFullURL($url));\n              } else {\n                location.hash = getFullURL($url);\n              }\n            }\n            !popstate && after($url);\n            !replace && len++;\n            init2 = replace = popstate = false;\n          })\n        );\n        if (hasPushState) {\n          cleanup.add(\n            state.subscribe(($state) => {\n              if (init2 || !prefs.sideEffect) return;\n              history.replaceState(\n                $state,\n                null,\n                location.pathname + location.search + location.hash\n              );\n            })\n          );\n          cleanup.add(\n            listenEvent(\"popstate\", (e) => {\n              popstate = true;\n              goto(location.href, e.state);\n              after(getShortURL(location.href), e.state);\n            })\n          );\n        } else {\n          cleanup.add(\n            listenEvent(\"hashchange\", () => {\n              popstate = true;\n              if (!prefs.hashbang && !useHashbang) return fragment2.set(location.hash);\n              goto(location.hash);\n              after(getShortURL(location.hash));\n            })\n          );\n        }\n        cleanup.add(\n          listenEvent(\n            \"beforeunload\",\n            () => {\n              cleanup.forEach((off) => off());\n              cleanup.clear();\n            },\n            true\n          )\n        );\n      }\n      paramable = createParamStore(path2);\n    }\n  });\n\n  // src/client/components/Toaster/toast.ts\n  function createToast() {\n    const { subscribe: subscribe2, set, update: update2 } = writable([]);\n    let id = 0;\n    const send = (toast2 = {}) => {\n      toast2.id = id++;\n      update2((state2) => [...state2, { ...defaults, ...toast2 }]);\n    };\n    const close4 = (id2) => {\n      update2((state2) => [...state2.filter((t) => t.id !== id2)]);\n    };\n    const clear = () => set([]);\n    return {\n      subscribe: subscribe2,\n      send,\n      close: close4,\n      clear,\n      default: (toast2 = {}) => send({ msg: \"default\", icon: \"message\", ...toast2 }),\n      error: (toast2 = {}) => send({ type: \"error\", icon: \"stop\", ...toast2 }),\n      warning: (toast2 = {}) => send({ type: \"warning\", icon: \"mail\", ...toast2 }),\n      primary: (toast2 = {}) => send({ type: \"primary\", icon: \"flag\", ...toast2 }),\n      success: (toast2 = {}) => send({ type: \"success\", icon: \"check\", ...toast2 })\n    };\n  }\n  var defaults, toast;\n  var init_toast = __esm({\n    \"src/client/components/Toaster/toast.ts\"() {\n      \"use strict\";\n      init_reload();\n      init_store();\n      defaults = { closable: true, pos: \"top_center\" };\n      toast = createToast();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/easing/index.js\n  function cubicOut(t) {\n    const f = t - 1;\n    return f * f * f + 1;\n  }\n  var init_easing = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/easing/index.js\"() {\n      init_reload();\n      init_internal();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/motion/utils.js\n  function is_date(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Date]\";\n  }\n  var init_utils4 = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/motion/utils.js\"() {\n      init_reload();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/motion/spring.js\n  var init_spring = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/motion/spring.js\"() {\n      init_reload();\n      init_store();\n      init_internal();\n      init_utils4();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/motion/tweened.js\n  function get_interpolator(a, b) {\n    if (a === b || a !== a) return () => a;\n    const type = typeof a;\n    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {\n      throw new Error(\"Cannot interpolate values of different type\");\n    }\n    if (Array.isArray(a)) {\n      const arr = b.map((bi, i) => {\n        return get_interpolator(a[i], bi);\n      });\n      return (t) => arr.map((fn) => fn(t));\n    }\n    if (type === \"object\") {\n      if (!a || !b) throw new Error(\"Object cannot be null\");\n      if (is_date(a) && is_date(b)) {\n        a = a.getTime();\n        b = b.getTime();\n        const delta = b - a;\n        return (t) => new Date(a + t * delta);\n      }\n      const keys = Object.keys(b);\n      const interpolators = {};\n      keys.forEach((key) => {\n        interpolators[key] = get_interpolator(a[key], b[key]);\n      });\n      return (t) => {\n        const result = {};\n        keys.forEach((key) => {\n          result[key] = interpolators[key](t);\n        });\n        return result;\n      };\n    }\n    if (type === \"number\") {\n      const delta = b - a;\n      return (t) => a + t * delta;\n    }\n    throw new Error(`Cannot interpolate ${type} values`);\n  }\n  function tweened(value, defaults2 = {}) {\n    const store = writable(value);\n    let task;\n    let target_value = value;\n    function set(new_value, opts) {\n      if (value == null) {\n        store.set(value = new_value);\n        return Promise.resolve();\n      }\n      target_value = new_value;\n      let previous_task = task;\n      let started = false;\n      let {\n        delay = 0,\n        duration = 400,\n        easing = identity,\n        interpolate = get_interpolator\n      } = assign(assign({}, defaults2), opts);\n      if (duration === 0) {\n        if (previous_task) {\n          previous_task.abort();\n          previous_task = null;\n        }\n        store.set(value = target_value);\n        return Promise.resolve();\n      }\n      const start = now() + delay;\n      let fn;\n      task = loop((now2) => {\n        if (now2 < start) return true;\n        if (!started) {\n          fn = interpolate(value, new_value);\n          if (typeof duration === \"function\") duration = duration(value, new_value);\n          started = true;\n        }\n        if (previous_task) {\n          previous_task.abort();\n          previous_task = null;\n        }\n        const elapsed = now2 - start;\n        if (elapsed > /** @type {number} */\n        duration) {\n          store.set(value = new_value);\n          return false;\n        }\n        store.set(value = fn(easing(elapsed / duration)));\n        return true;\n      });\n      return task.promise;\n    }\n    return {\n      set,\n      update: (fn, opts) => set(fn(target_value, value), opts),\n      subscribe: store.subscribe\n    };\n  }\n  var init_tweened = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/motion/tweened.js\"() {\n      init_reload();\n      init_store();\n      init_internal();\n      init_easing();\n      init_utils4();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/motion/index.js\n  var init_motion = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/motion/index.js\"() {\n      init_reload();\n      init_spring();\n      init_tweened();\n    }\n  });\n\n  // src/client/components/Toaster/Toast.svelte\n  function fallback_block2(ctx) {\n    let samp;\n    let t_value = (\n      /*toastItem*/\n      ctx[0].msg + \"\"\n    );\n    let t;\n    const block2 = {\n      c: function create() {\n        samp = element(\"samp\");\n        t = text(t_value);\n        add_location(samp, file5, 87, 8, 1870);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, samp, anchor);\n        append_dev(samp, t);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*toastItem*/\n        1 && t_value !== (t_value = /*toastItem*/\n        ctx2[0].msg + \"\")) set_data_dev(t, t_value);\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(samp);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: fallback_block2.name,\n      type: \"fallback\",\n      source: \"(63:10)          \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block2(ctx) {\n    let button;\n    let icon;\n    let current;\n    let mounted;\n    let dispose;\n    icon = new Icon_default({ $$inline: true });\n    const block2 = {\n      c: function create() {\n        button = element(\"button\");\n        create_component(icon.$$.fragment);\n        attr_dev(button, \"id\", \"close\");\n        attr_dev(button, \"class\", \"box link\");\n        add_location(button, file5, 91, 8, 1939);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, button, anchor);\n        mount_component(icon, button, null);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            button,\n            \"click\",\n            /*close*/\n            ctx[7],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(button);\n        }\n        destroy_component(icon);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block2.name,\n      type: \"if\",\n      source: \"(68:4) {#if closable}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment5(ctx) {\n    let article;\n    let t;\n    let article_class_value;\n    let pausable_action;\n    let current;\n    let mounted;\n    let dispose;\n    const default_slot_template = (\n      /*#slots*/\n      ctx[15].default\n    );\n    const default_slot = create_slot(\n      default_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[14],\n      null\n    );\n    const default_slot_or_fallback = default_slot || fallback_block2(ctx);\n    let if_block = (\n      /*closable*/\n      ctx[3] && create_if_block2(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        article = element(\"article\");\n        if (default_slot_or_fallback) default_slot_or_fallback.c();\n        t = space();\n        if (if_block) if_block.c();\n        attr_dev(article, \"class\", article_class_value = \"toast \" + /*type*/\n        (ctx[1] || \"\"));\n        set_style(\n          article,\n          \"--progress\",\n          /*$progress*/\n          ctx[5]\n        );\n        attr_dev(\n          article,\n          \"draggable\",\n          /*draggable*/\n          ctx[4]\n        );\n        add_location(article, file5, 77, 0, 1611);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, article, anchor);\n        if (default_slot_or_fallback) {\n          default_slot_or_fallback.m(article, null);\n        }\n        append_dev(article, t);\n        if (if_block) if_block.m(article, null);\n        current = true;\n        if (!mounted) {\n          dispose = [\n            action_destroyer(pausable_action = /*pausable*/\n            ctx[8].call(\n              null,\n              article,\n              /*timeout*/\n              ctx[2] > 0\n            )),\n            listen_dev(\n              article,\n              \"dragstart\",\n              /*dragstart_handler*/\n              ctx[16],\n              false,\n              false,\n              false,\n              false\n            ),\n            listen_dev(\n              article,\n              \"dragend\",\n              /*dragend_handler*/\n              ctx[17],\n              false,\n              false,\n              false,\n              false\n            )\n          ];\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (default_slot) {\n          if (default_slot.p && (!current || dirty & /*$$scope*/\n          16384)) {\n            update_slot_base(\n              default_slot,\n              default_slot_template,\n              ctx2,\n              /*$$scope*/\n              ctx2[14],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx2[14]\n              ) : get_slot_changes(\n                default_slot_template,\n                /*$$scope*/\n                ctx2[14],\n                dirty,\n                null\n              ),\n              null\n            );\n          }\n        } else {\n          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*toastItem*/\n          1)) {\n            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);\n          }\n        }\n        if (\n          /*closable*/\n          ctx2[3]\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty & /*closable*/\n            8) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block2(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(article, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n        if (!current || dirty & /*type*/\n        2 && article_class_value !== (article_class_value = \"toast \" + /*type*/\n        (ctx2[1] || \"\"))) {\n          attr_dev(article, \"class\", article_class_value);\n        }\n        if (!current || dirty & /*$progress*/\n        32) {\n          set_style(\n            article,\n            \"--progress\",\n            /*$progress*/\n            ctx2[5]\n          );\n        }\n        if (!current || dirty & /*draggable*/\n        16) {\n          attr_dev(\n            article,\n            \"draggable\",\n            /*draggable*/\n            ctx2[4]\n          );\n        }\n        if (pausable_action && is_function(pausable_action.update) && dirty & /*timeout*/\n        4) pausable_action.update.call(\n          null,\n          /*timeout*/\n          ctx2[2] > 0\n        );\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(default_slot_or_fallback, local);\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(default_slot_or_fallback, local);\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(article);\n        }\n        if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);\n        if (if_block) if_block.d();\n        mounted = false;\n        run_all(dispose);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment5.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance5($$self, $$props, $$invalidate) {\n    let $progress;\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Toast\", slots, [\"default\"]);\n    const dispatch2 = createEventDispatcher();\n    let { toastItem = {} } = $$props;\n    let { id = toastItem.id || 0 } = $$props;\n    let { type = toastItem.type || \"initial\" } = $$props;\n    let { timeout = toastItem.timeout || 0 } = $$props;\n    let { closable = toastItem.closable ?? true } = $$props;\n    let { reverse = toastItem.reverse || false } = $$props;\n    let { visible = true } = $$props;\n    let { draggable = false } = $$props;\n    let init3 = reverse ? 1 : 0;\n    let next = reverse ? 0 : 1;\n    let start = Date.now();\n    let remaining = timeout;\n    let options2 = { duration: remaining };\n    const defaults2 = { delay: 0, duration: 0, easing: identity };\n    const progress = tweened(init3, { ...defaults2 });\n    validate_store(progress, \"progress\");\n    component_subscribe($$self, progress, (value) => $$invalidate(5, $progress = value));\n    const autoclose = () => timeout && $progress % 1 === 0 && close4();\n    const close4 = () => {\n      dispatch2(\"close\", id);\n      toast.close(id);\n      $$invalidate(9, visible = false);\n    };\n    const pause = () => {\n      remaining -= Date.now() - start;\n      $$invalidate(12, next = $progress);\n      $$invalidate(13, options2 = { duration: 0 });\n    };\n    const resume = () => {\n      start = Date.now();\n      $$invalidate(12, next = reverse ? 0 : 1);\n      $$invalidate(13, options2 = { duration: remaining });\n    };\n    function pausable(node, paused) {\n      if (paused) {\n        node.onpointerenter = pause;\n        node.onpointerleave = resume;\n      }\n      return {\n        destroy() {\n          node.onpointerenter = null;\n          node.onpointerleave = null;\n        }\n      };\n    }\n    const writable_props = [\n      \"toastItem\",\n      \"id\",\n      \"type\",\n      \"timeout\",\n      \"closable\",\n      \"reverse\",\n      \"visible\",\n      \"draggable\"\n    ];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Toast> was created with unknown prop '${key}'`);\n    });\n    function dragstart_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    function dragend_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"toastItem\" in $$props2) $$invalidate(0, toastItem = $$props2.toastItem);\n      if (\"id\" in $$props2) $$invalidate(10, id = $$props2.id);\n      if (\"type\" in $$props2) $$invalidate(1, type = $$props2.type);\n      if (\"timeout\" in $$props2) $$invalidate(2, timeout = $$props2.timeout);\n      if (\"closable\" in $$props2) $$invalidate(3, closable = $$props2.closable);\n      if (\"reverse\" in $$props2) $$invalidate(11, reverse = $$props2.reverse);\n      if (\"visible\" in $$props2) $$invalidate(9, visible = $$props2.visible);\n      if (\"draggable\" in $$props2) $$invalidate(4, draggable = $$props2.draggable);\n      if (\"$$scope\" in $$props2) $$invalidate(14, $$scope = $$props2.$$scope);\n    };\n    $$self.$capture_state = () => ({\n      tweened,\n      linear: identity,\n      toast,\n      Icon: Icon_default,\n      createEventDispatcher,\n      dispatch: dispatch2,\n      toastItem,\n      id,\n      type,\n      timeout,\n      closable,\n      reverse,\n      visible,\n      draggable,\n      init: init3,\n      next,\n      start,\n      remaining,\n      options: options2,\n      defaults: defaults2,\n      progress,\n      autoclose,\n      close: close4,\n      pause,\n      resume,\n      pausable,\n      $progress\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"toastItem\" in $$props2) $$invalidate(0, toastItem = $$props2.toastItem);\n      if (\"id\" in $$props2) $$invalidate(10, id = $$props2.id);\n      if (\"type\" in $$props2) $$invalidate(1, type = $$props2.type);\n      if (\"timeout\" in $$props2) $$invalidate(2, timeout = $$props2.timeout);\n      if (\"closable\" in $$props2) $$invalidate(3, closable = $$props2.closable);\n      if (\"reverse\" in $$props2) $$invalidate(11, reverse = $$props2.reverse);\n      if (\"visible\" in $$props2) $$invalidate(9, visible = $$props2.visible);\n      if (\"draggable\" in $$props2) $$invalidate(4, draggable = $$props2.draggable);\n      if (\"init\" in $$props2) init3 = $$props2.init;\n      if (\"next\" in $$props2) $$invalidate(12, next = $$props2.next);\n      if (\"start\" in $$props2) start = $$props2.start;\n      if (\"remaining\" in $$props2) remaining = $$props2.remaining;\n      if (\"options\" in $$props2) $$invalidate(13, options2 = $$props2.options);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    $$self.$$.update = () => {\n      if ($$self.$$.dirty & /*timeout, next, options*/\n      12292) {\n        $: timeout && progress.set(next, options2).then(autoclose);\n      }\n    };\n    return [\n      toastItem,\n      type,\n      timeout,\n      closable,\n      draggable,\n      $progress,\n      progress,\n      close4,\n      pausable,\n      visible,\n      id,\n      reverse,\n      next,\n      options2,\n      $$scope,\n      slots,\n      dragstart_handler,\n      dragend_handler\n    ];\n  }\n  var file5, Toast, Toast_default;\n  var init_Toast = __esm({\n    \"src/client/components/Toaster/Toast.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Icon();\n      init_toast();\n      init_easing();\n      init_motion();\n      init_runtime();\n      file5 = \"src/client/components/Toaster/Toast.svelte\";\n      Toast = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance5, create_fragment5, safe_not_equal, {\n            toastItem: 0,\n            id: 10,\n            type: 1,\n            timeout: 2,\n            closable: 3,\n            reverse: 11,\n            visible: 9,\n            draggable: 4\n          });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Toast\",\n            options: options2,\n            id: create_fragment5.name\n          });\n        }\n        get toastItem() {\n          throw new Error(\"<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set toastItem(value) {\n          throw new Error(\"<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get id() {\n          throw new Error(\"<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set id(value) {\n          throw new Error(\"<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get type() {\n          throw new Error(\"<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set type(value) {\n          throw new Error(\"<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get timeout() {\n          throw new Error(\"<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set timeout(value) {\n          throw new Error(\"<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get closable() {\n          throw new Error(\"<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set closable(value) {\n          throw new Error(\"<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get reverse() {\n          throw new Error(\"<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set reverse(value) {\n          throw new Error(\"<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get visible() {\n          throw new Error(\"<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set visible(value) {\n          throw new Error(\"<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get draggable() {\n          throw new Error(\"<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set draggable(value) {\n          throw new Error(\"<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      Toast_default = Toast;\n    }\n  });\n\n  // src/client/components/Toaster/index.ts\n  var init_Toaster = __esm({\n    \"src/client/components/Toaster/index.ts\"() {\n      \"use strict\";\n      init_reload();\n      init_Toast();\n      init_Toast();\n      init_Toast();\n      init_Toaster2();\n      init_toast();\n    }\n  });\n\n  // src/client/components/Toaster/positions.ts\n  var positions;\n  var init_positions = __esm({\n    \"src/client/components/Toaster/positions.ts\"() {\n      \"use strict\";\n      init_reload();\n      positions = [\n        \"top_center\",\n        \"top_right\",\n        \"center_right\",\n        \"bottom_right\",\n        \"bottom_center\",\n        \"bottom_left\",\n        \"center_left\",\n        \"top_left\",\n        \"center_center\"\n      ];\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/transition/index.js\n  function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {\n    const style = getComputedStyle(node);\n    const target_opacity = +style.opacity;\n    const transform = style.transform === \"none\" ? \"\" : style.transform;\n    const od = target_opacity * (1 - opacity);\n    const [xValue, xUnit] = split_css_unit(x);\n    const [yValue, yUnit] = split_css_unit(y);\n    return {\n      delay,\n      duration,\n      easing,\n      css: (t, u) => `\n\t\t\ttransform: ${transform} translate(${(1 - t) * xValue}${xUnit}, ${(1 - t) * yValue}${yUnit});\n\t\t\topacity: ${target_opacity - od * u}`\n    };\n  }\n  var init_transition = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/transition/index.js\"() {\n      init_reload();\n      init_easing();\n      init_internal();\n    }\n  });\n\n  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/animate/index.js\n  function flip(node, { from, to }, params = {}) {\n    const style = getComputedStyle(node);\n    const transform = style.transform === \"none\" ? \"\" : style.transform;\n    const [ox, oy] = style.transformOrigin.split(\" \").map(parseFloat);\n    const dx = from.left + from.width * ox / to.width - (to.left + ox);\n    const dy = from.top + from.height * oy / to.height - (to.top + oy);\n    const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;\n    return {\n      delay,\n      duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,\n      easing,\n      css: (t, u) => {\n        const x = u * dx;\n        const y = u * dy;\n        const sx = t + u * from.width / to.width;\n        const sy = t + u * from.height / to.height;\n        return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;\n      }\n    };\n  }\n  var init_animate = __esm({\n    \"node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/animate/index.js\"() {\n      init_reload();\n      init_easing();\n      init_internal();\n    }\n  });\n\n  // src/client/components/Toaster/Toaster.svelte\n  function get_each_context(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[5] = list2[i];\n    return child_ctx;\n  }\n  function get_each_context_1(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[8] = list2[i];\n    return child_ctx;\n  }\n  function create_if_block3(ctx) {\n    let div;\n    let current;\n    let each_value = ensure_array_like_dev(positions);\n    let each_blocks = [];\n    for (let i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    }\n    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {\n      each_blocks[i] = null;\n    });\n    const block2 = {\n      c: function create() {\n        div = element(\"div\");\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        attr_dev(div, \"class\", \"toaster\");\n        add_location(div, file6, 31, 4, 598);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, div, anchor);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(div, null);\n          }\n        }\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*toasted*/\n        2) {\n          each_value = ensure_array_like_dev(positions);\n          let i;\n          for (i = 0; i < each_value.length; i += 1) {\n            const child_ctx = get_each_context(ctx2, each_value, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n              transition_in(each_blocks[i], 1);\n            } else {\n              each_blocks[i] = create_each_block(child_ctx);\n              each_blocks[i].c();\n              transition_in(each_blocks[i], 1);\n              each_blocks[i].m(div, null);\n            }\n          }\n          group_outros();\n          for (i = each_value.length; i < each_blocks.length; i += 1) {\n            out(i);\n          }\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        for (let i = 0; i < each_value.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        current = true;\n      },\n      o: function outro(local) {\n        each_blocks = each_blocks.filter(Boolean);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(div);\n        }\n        destroy_each(each_blocks, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block3.name,\n      type: \"if\",\n      source: \"(22:0) {#if $toast.length}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_12(ctx) {\n    let ul;\n    let each_blocks = [];\n    let each_1_lookup = /* @__PURE__ */ new Map();\n    let t;\n    let ul_class_value;\n    let current;\n    let each_value_1 = ensure_array_like_dev(\n      /*toasted*/\n      ctx[1](\n        /*pos*/\n        ctx[5]\n      )\n    );\n    const get_key = (ctx2) => (\n      /*toastItem*/\n      ctx2[8].id\n    );\n    validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);\n    for (let i = 0; i < each_value_1.length; i += 1) {\n      let child_ctx = get_each_context_1(ctx, each_value_1, i);\n      let key = get_key(child_ctx);\n      each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));\n    }\n    const block2 = {\n      c: function create() {\n        ul = element(\"ul\");\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        t = space();\n        attr_dev(ul, \"class\", ul_class_value = \"toast-list pos-\" + /*pos*/\n        ctx[5]);\n        add_location(ul, file6, 34, 16, 727);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, ul, anchor);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(ul, null);\n          }\n        }\n        append_dev(ul, t);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*toasted*/\n        2) {\n          each_value_1 = ensure_array_like_dev(\n            /*toasted*/\n            ctx2[1](\n              /*pos*/\n              ctx2[5]\n            )\n          );\n          group_outros();\n          for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();\n          validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);\n          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, ul, fix_and_outro_and_destroy_block, create_each_block_1, t, get_each_context_1);\n          for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        for (let i = 0; i < each_value_1.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        current = true;\n      },\n      o: function outro(local) {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(ul);\n        }\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].d();\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_12.name,\n      type: \"if\",\n      source: \"(25:12) {#if toasted(pos).some((t) => t.pos === pos)}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block_1(key_1, ctx) {\n    let li;\n    let toast_1;\n    let li_intro;\n    let rect;\n    let stop_animation = noop;\n    let current;\n    toast_1 = new Toast_default({\n      props: { toastItem: (\n        /*toastItem*/\n        ctx[8]\n      ) },\n      $$inline: true\n    });\n    const block2 = {\n      key: key_1,\n      first: null,\n      c: function create() {\n        li = element(\"li\");\n        create_component(toast_1.$$.fragment);\n        add_location(li, file6, 36, 24, 854);\n        this.first = li;\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, li, anchor);\n        mount_component(toast_1, li, null);\n        current = true;\n      },\n      p: function update2(new_ctx, dirty) {\n        ctx = new_ctx;\n        const toast_1_changes = {};\n        if (dirty & /*toasted*/\n        2) toast_1_changes.toastItem = /*toastItem*/\n        ctx[8];\n        toast_1.$set(toast_1_changes);\n      },\n      r: function measure() {\n        rect = li.getBoundingClientRect();\n      },\n      f: function fix() {\n        fix_position(li);\n        stop_animation();\n      },\n      a: function animate() {\n        stop_animation();\n        stop_animation = create_animation(li, rect, flip, { duration: 250 });\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(toast_1.$$.fragment, local);\n        if (local) {\n          if (!li_intro) {\n            add_render_callback(() => {\n              li_intro = create_in_transition(li, fly, {\n                .../*flying*/\n                ctx[2](\n                  /*toastItem*/\n                  ctx[8].pos\n                ),\n                opacity: 1\n              });\n              li_intro.start();\n            });\n          }\n        }\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(toast_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(li);\n        }\n        destroy_component(toast_1);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block_1.name,\n      type: \"each\",\n      source: \"(27:20) {#each toasted(pos) as toastItem (toastItem.id)}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block(ctx) {\n    let show_if = (\n      /*toasted*/\n      ctx[1](\n        /*pos*/\n        ctx[5]\n      ).some(func3)\n    );\n    let if_block_anchor;\n    let current;\n    function func3(...args) {\n      return (\n        /*func*/\n        ctx[3](\n          /*pos*/\n          ctx[5],\n          ...args\n        )\n      );\n    }\n    let if_block = show_if && create_if_block_12(ctx);\n    const block2 = {\n      c: function create() {\n        if (if_block) if_block.c();\n        if_block_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        if (if_block) if_block.m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n        current = true;\n      },\n      p: function update2(new_ctx, dirty) {\n        ctx = new_ctx;\n        if (dirty & /*toasted*/\n        2) show_if = /*toasted*/\n        ctx[1](\n          /*pos*/\n          ctx[5]\n        ).some(func3);\n        if (show_if) {\n          if (if_block) {\n            if_block.p(ctx, dirty);\n            if (dirty & /*toasted*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block_12(ctx);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(if_block_anchor.parentNode, if_block_anchor);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if (if_block) if_block.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block.name,\n      type: \"each\",\n      source: \"(24:8) {#each positions as pos}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment6(ctx) {\n    let if_block_anchor;\n    let current;\n    let if_block = (\n      /*$toast*/\n      ctx[0].length && create_if_block3(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        if (if_block) if_block.c();\n        if_block_anchor = empty();\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        if (if_block) if_block.m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (\n          /*$toast*/\n          ctx2[0].length\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty & /*$toast*/\n            1) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block3(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(if_block_anchor.parentNode, if_block_anchor);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if (if_block) if_block.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment6.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance6($$self, $$props, $$invalidate) {\n    let toasted;\n    let $toast;\n    validate_store(toast, \"toast\");\n    component_subscribe($$self, toast, ($$value) => $$invalidate(0, $toast = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Toaster\", slots, []);\n    \"use strict\";\n    const intros = {\n      left: { x: -256 },\n      right: { x: 256 },\n      top: { y: -56 },\n      bottom: { y: 56 },\n      center: {}\n    };\n    const flying = (pos) => Object.entries(intros).find(([key]) => pos?.includes(key))?.[1];\n    const writable_props = [];\n    Object_1.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Toaster> was created with unknown prop '${key}'`);\n    });\n    const func3 = (pos, t) => t.pos === pos;\n    $$self.$capture_state = () => ({\n      flip,\n      fly,\n      positions,\n      toast,\n      Toast: Toast_default,\n      intros,\n      flying,\n      toasted,\n      $toast\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"toasted\" in $$props2) $$invalidate(1, toasted = $$props2.toasted);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    $$self.$$.update = () => {\n      if ($$self.$$.dirty & /*$toast*/\n      1) {\n        $: $$invalidate(1, toasted = (p) => $toast.filter((t) => t.pos === p).sort((a, b) => b.id - a.id));\n      }\n    };\n    return [$toast, toasted, flying, func3];\n  }\n  var Object_1, file6, Toaster, Toaster_default;\n  var init_Toaster2 = __esm({\n    \"src/client/components/Toaster/Toaster.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Toaster();\n      init_Toaster();\n      init_positions();\n      init_transition();\n      init_animate();\n      ({ Object: Object_1 } = globals);\n      file6 = \"src/client/components/Toaster/Toaster.svelte\";\n      Toaster = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance6, create_fragment6, safe_not_equal, {});\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Toaster\",\n            options: options2,\n            id: create_fragment6.name\n          });\n        }\n      };\n      Toaster_default = Toaster;\n    }\n  });\n\n  // src/client/stores/auth.ts\n  function createAuth() {\n    const { set, subscribe: subscribe2, update: update2 } = getable({});\n    return {\n      update: update2,\n      subscribe: subscribe2,\n      async login(creds) {\n        const user = await post(`/auth/login`, JSON.stringify(creds), {\n          headers: {\n            \"Content-Type\": \"application/json\"\n          }\n        });\n        set(user);\n      }\n    };\n  }\n  var auth;\n  var init_auth = __esm({\n    \"src/client/stores/auth.ts\"() {\n      \"use strict\";\n      init_reload();\n      init_getable();\n      init_methods();\n      init_utils2();\n      auth = createAuth();\n    }\n  });\n\n  // src/client/routes/auth/page.svelte\n  var page_exports = {};\n  __export(page_exports, {\n    default: () => page_default\n  });\n  function create_default_slot3(ctx) {\n    let fieldset;\n    let label0;\n    let input0;\n    let t0;\n    let label1;\n    let input1;\n    let t1;\n    let label2;\n    let input2;\n    let t2;\n    let t3;\n    let nav;\n    let button;\n    let t4;\n    let button_disabled_value;\n    const block2 = {\n      c: function create() {\n        fieldset = element(\"fieldset\");\n        label0 = element(\"label\");\n        input0 = element(\"input\");\n        t0 = space();\n        label1 = element(\"label\");\n        input1 = element(\"input\");\n        t1 = space();\n        label2 = element(\"label\");\n        input2 = element(\"input\");\n        t2 = text(\" Remeber me\");\n        t3 = space();\n        nav = element(\"nav\");\n        button = element(\"button\");\n        t4 = text(\"Login\");\n        attr_dev(input0, \"type\", \"email\");\n        attr_dev(input0, \"name\", \"email\");\n        attr_dev(input0, \"placeholder\", \"email\");\n        input0.required = true;\n        add_location(input0, file7, 22, 20, 582);\n        add_location(label0, file7, 21, 16, 554);\n        attr_dev(input1, \"type\", \"password\");\n        attr_dev(input1, \"name\", \"password\");\n        attr_dev(input1, \"placeholder\", \"password\");\n        attr_dev(input1, \"minlength\", \"8\");\n        input1.required = true;\n        add_location(input1, file7, 30, 20, 832);\n        add_location(label1, file7, 29, 16, 804);\n        attr_dev(input2, \"type\", \"checkbox\");\n        attr_dev(input2, \"name\", \"remember\");\n        add_location(input2, file7, 39, 20, 1129);\n        add_location(label2, file7, 38, 16, 1101);\n        add_location(fieldset, file7, 20, 12, 527);\n        attr_dev(button, \"type\", \"submit\");\n        attr_dev(button, \"class\", \"text-success\");\n        button.disabled = button_disabled_value = !/*valid*/\n        ctx[0];\n        add_location(button, file7, 43, 16, 1278);\n        attr_dev(nav, \"class\", \"cols\");\n        add_location(nav, file7, 42, 12, 1243);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, fieldset, anchor);\n        append_dev(fieldset, label0);\n        append_dev(label0, input0);\n        append_dev(fieldset, t0);\n        append_dev(fieldset, label1);\n        append_dev(label1, input1);\n        append_dev(fieldset, t1);\n        append_dev(fieldset, label2);\n        append_dev(label2, input2);\n        append_dev(label2, t2);\n        insert_dev(target, t3, anchor);\n        insert_dev(target, nav, anchor);\n        append_dev(nav, button);\n        append_dev(button, t4);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*valid*/\n        1 && button_disabled_value !== (button_disabled_value = !/*valid*/\n        ctx2[0])) {\n          prop_dev(button, \"disabled\", button_disabled_value);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(fieldset);\n          detach_dev(t3);\n          detach_dev(nav);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot3.name,\n      type: \"slot\",\n      source: \"(18:8) <Form on:submit={login} bind:valid>\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment7(ctx) {\n    let section;\n    let article;\n    let form;\n    let updating_valid;\n    let current;\n    function form_valid_binding(value) {\n      ctx[1](value);\n    }\n    let form_props = {\n      $$slots: { default: [create_default_slot3] },\n      $$scope: { ctx }\n    };\n    if (\n      /*valid*/\n      ctx[0] !== void 0\n    ) {\n      form_props.valid = /*valid*/\n      ctx[0];\n    }\n    form = new Form_default({ props: form_props, $$inline: true });\n    binding_callbacks.push(() => bind(form, \"valid\", form_valid_binding));\n    form.$on(\"submit\", login);\n    const block2 = {\n      c: function create() {\n        section = element(\"section\");\n        article = element(\"article\");\n        create_component(form.$$.fragment);\n        add_location(article, file7, 17, 4, 426);\n        add_location(section, file7, 16, 0, 412);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, section, anchor);\n        append_dev(section, article);\n        mount_component(form, article, null);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const form_changes = {};\n        if (dirty & /*$$scope, valid*/\n        5) {\n          form_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        if (!updating_valid && dirty & /*valid*/\n        1) {\n          updating_valid = true;\n          form_changes.valid = /*valid*/\n          ctx2[0];\n          add_flush_callback(() => updating_valid = false);\n        }\n        form.$set(form_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(form.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(form.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(section);\n        }\n        destroy_component(form);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment7.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function login(e) {\n    const data = new FormData(e.currentTarget);\n    const creds = Object.fromEntries(data);\n    redirect(\"/data\");\n  }\n  function instance7($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Page\", slots, []);\n    \"use strict\";\n    let valid = false;\n    const writable_props = [];\n    Object_12.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Page> was created with unknown prop '${key}'`);\n    });\n    function form_valid_binding(value) {\n      valid = value;\n      $$invalidate(0, valid);\n    }\n    $$self.$capture_state = () => ({ redirect, auth, Form: Form_default, valid, login });\n    $$self.$inject_state = ($$props2) => {\n      if (\"valid\" in $$props2) $$invalidate(0, valid = $$props2.valid);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [valid, form_valid_binding];\n  }\n  var Object_12, file7, Page, page_default;\n  var init_page = __esm({\n    \"src/client/routes/auth/page.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Form();\n      init_auth();\n      init_src();\n      ({ Object: Object_12 } = globals);\n      file7 = \"src/client/routes/auth/page.svelte\";\n      Page = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance7, create_fragment7, safe_not_equal, {});\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Page\",\n            options: options2,\n            id: create_fragment7.name\n          });\n        }\n      };\n      page_default = Page;\n    }\n  });\n\n  // node_modules/.pnpm/codejar@4.2.0/node_modules/codejar/dist/codejar.js\n  function CodeJar(editor, highlight, opt = {}) {\n    const options2 = {\n      tab: \"\t\",\n      indentOn: /[({\\[]$/,\n      moveToNewLine: /^[)}\\]]/,\n      spellcheck: false,\n      catchTab: true,\n      preserveIdent: true,\n      addClosing: true,\n      history: true,\n      window: globalWindow,\n      ...opt\n    };\n    const window2 = options2.window;\n    const document2 = window2.document;\n    const listeners = [];\n    const history2 = [];\n    let at = -1;\n    let focus = false;\n    let onUpdate = () => void 0;\n    let prev;\n    editor.setAttribute(\"contenteditable\", \"plaintext-only\");\n    editor.setAttribute(\"spellcheck\", options2.spellcheck ? \"true\" : \"false\");\n    editor.style.outline = \"none\";\n    editor.style.overflowWrap = \"break-word\";\n    editor.style.overflowY = \"auto\";\n    editor.style.whiteSpace = \"pre-wrap\";\n    const doHighlight = (editor2, pos) => {\n      highlight(editor2, pos);\n    };\n    let isLegacy = false;\n    if (editor.contentEditable !== \"plaintext-only\")\n      isLegacy = true;\n    if (isLegacy)\n      editor.setAttribute(\"contenteditable\", \"true\");\n    const debounceHighlight = debounce(() => {\n      const pos = save();\n      doHighlight(editor, pos);\n      restore(pos);\n    }, 30);\n    let recording = false;\n    const shouldRecord = (event) => {\n      return !isUndo(event) && !isRedo(event) && event.key !== \"Meta\" && event.key !== \"Control\" && event.key !== \"Alt\" && !event.key.startsWith(\"Arrow\");\n    };\n    const debounceRecordHistory = debounce((event) => {\n      if (shouldRecord(event)) {\n        recordHistory();\n        recording = false;\n      }\n    }, 300);\n    const on = (type, fn) => {\n      listeners.push([type, fn]);\n      editor.addEventListener(type, fn);\n    };\n    on(\"keydown\", (event) => {\n      if (event.defaultPrevented)\n        return;\n      prev = toString();\n      if (options2.preserveIdent)\n        handleNewLine(event);\n      else\n        legacyNewLineFix(event);\n      if (options2.catchTab)\n        handleTabCharacters(event);\n      if (options2.addClosing)\n        handleSelfClosingCharacters(event);\n      if (options2.history) {\n        handleUndoRedo(event);\n        if (shouldRecord(event) && !recording) {\n          recordHistory();\n          recording = true;\n        }\n      }\n      if (isLegacy && !isCopy(event))\n        restore(save());\n    });\n    on(\"keyup\", (event) => {\n      if (event.defaultPrevented)\n        return;\n      if (event.isComposing)\n        return;\n      if (prev !== toString())\n        debounceHighlight();\n      debounceRecordHistory(event);\n      onUpdate(toString());\n    });\n    on(\"focus\", (_event) => {\n      focus = true;\n    });\n    on(\"blur\", (_event) => {\n      focus = false;\n    });\n    on(\"paste\", (event) => {\n      recordHistory();\n      handlePaste(event);\n      recordHistory();\n      onUpdate(toString());\n    });\n    on(\"cut\", (event) => {\n      recordHistory();\n      handleCut(event);\n      recordHistory();\n      onUpdate(toString());\n    });\n    function save() {\n      const s2 = getSelection2();\n      const pos = { start: 0, end: 0, dir: void 0 };\n      let { anchorNode, anchorOffset, focusNode, focusOffset } = s2;\n      if (!anchorNode || !focusNode)\n        throw \"error1\";\n      if (anchorNode === editor && focusNode === editor) {\n        pos.start = anchorOffset > 0 && editor.textContent ? editor.textContent.length : 0;\n        pos.end = focusOffset > 0 && editor.textContent ? editor.textContent.length : 0;\n        pos.dir = focusOffset >= anchorOffset ? \"->\" : \"<-\";\n        return pos;\n      }\n      if (anchorNode.nodeType === Node.ELEMENT_NODE) {\n        const node = document2.createTextNode(\"\");\n        anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset]);\n        anchorNode = node;\n        anchorOffset = 0;\n      }\n      if (focusNode.nodeType === Node.ELEMENT_NODE) {\n        const node = document2.createTextNode(\"\");\n        focusNode.insertBefore(node, focusNode.childNodes[focusOffset]);\n        focusNode = node;\n        focusOffset = 0;\n      }\n      visit(editor, (el) => {\n        if (el === anchorNode && el === focusNode) {\n          pos.start += anchorOffset;\n          pos.end += focusOffset;\n          pos.dir = anchorOffset <= focusOffset ? \"->\" : \"<-\";\n          return \"stop\";\n        }\n        if (el === anchorNode) {\n          pos.start += anchorOffset;\n          if (!pos.dir) {\n            pos.dir = \"->\";\n          } else {\n            return \"stop\";\n          }\n        } else if (el === focusNode) {\n          pos.end += focusOffset;\n          if (!pos.dir) {\n            pos.dir = \"<-\";\n          } else {\n            return \"stop\";\n          }\n        }\n        if (el.nodeType === Node.TEXT_NODE) {\n          if (pos.dir != \"->\")\n            pos.start += el.nodeValue.length;\n          if (pos.dir != \"<-\")\n            pos.end += el.nodeValue.length;\n        }\n      });\n      editor.normalize();\n      return pos;\n    }\n    function restore(pos) {\n      const s2 = getSelection2();\n      let startNode, startOffset = 0;\n      let endNode, endOffset = 0;\n      if (!pos.dir)\n        pos.dir = \"->\";\n      if (pos.start < 0)\n        pos.start = 0;\n      if (pos.end < 0)\n        pos.end = 0;\n      if (pos.dir == \"<-\") {\n        const { start, end } = pos;\n        pos.start = end;\n        pos.end = start;\n      }\n      let current = 0;\n      visit(editor, (el) => {\n        if (el.nodeType !== Node.TEXT_NODE)\n          return;\n        const len2 = (el.nodeValue || \"\").length;\n        if (current + len2 > pos.start) {\n          if (!startNode) {\n            startNode = el;\n            startOffset = pos.start - current;\n          }\n          if (current + len2 > pos.end) {\n            endNode = el;\n            endOffset = pos.end - current;\n            return \"stop\";\n          }\n        }\n        current += len2;\n      });\n      if (!startNode)\n        startNode = editor, startOffset = editor.childNodes.length;\n      if (!endNode)\n        endNode = editor, endOffset = editor.childNodes.length;\n      if (pos.dir == \"<-\") {\n        [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset];\n      }\n      {\n        const startEl = uneditable(startNode);\n        if (startEl) {\n          const node = document2.createTextNode(\"\");\n          startEl.parentNode?.insertBefore(node, startEl);\n          startNode = node;\n          startOffset = 0;\n        }\n        const endEl = uneditable(endNode);\n        if (endEl) {\n          const node = document2.createTextNode(\"\");\n          endEl.parentNode?.insertBefore(node, endEl);\n          endNode = node;\n          endOffset = 0;\n        }\n      }\n      s2.setBaseAndExtent(startNode, startOffset, endNode, endOffset);\n      editor.normalize();\n    }\n    function uneditable(node) {\n      while (node && node !== editor) {\n        if (node.nodeType === Node.ELEMENT_NODE) {\n          const el = node;\n          if (el.getAttribute(\"contenteditable\") == \"false\") {\n            return el;\n          }\n        }\n        node = node.parentNode;\n      }\n    }\n    function beforeCursor() {\n      const s2 = getSelection2();\n      const r0 = s2.getRangeAt(0);\n      const r = document2.createRange();\n      r.selectNodeContents(editor);\n      r.setEnd(r0.startContainer, r0.startOffset);\n      return r.toString();\n    }\n    function afterCursor() {\n      const s2 = getSelection2();\n      const r0 = s2.getRangeAt(0);\n      const r = document2.createRange();\n      r.selectNodeContents(editor);\n      r.setStart(r0.endContainer, r0.endOffset);\n      return r.toString();\n    }\n    function handleNewLine(event) {\n      if (event.key === \"Enter\") {\n        const before2 = beforeCursor();\n        const after2 = afterCursor();\n        let [padding] = findPadding(before2);\n        let newLinePadding = padding;\n        if (options2.indentOn.test(before2)) {\n          newLinePadding += options2.tab;\n        }\n        if (newLinePadding.length > 0) {\n          preventDefault(event);\n          event.stopPropagation();\n          insert2(\"\\n\" + newLinePadding);\n        } else {\n          legacyNewLineFix(event);\n        }\n        if (newLinePadding !== padding && options2.moveToNewLine.test(after2)) {\n          const pos = save();\n          insert2(\"\\n\" + padding);\n          restore(pos);\n        }\n      }\n    }\n    function legacyNewLineFix(event) {\n      if (isLegacy && event.key === \"Enter\") {\n        preventDefault(event);\n        event.stopPropagation();\n        if (afterCursor() == \"\") {\n          insert2(\"\\n \");\n          const pos = save();\n          pos.start = --pos.end;\n          restore(pos);\n        } else {\n          insert2(\"\\n\");\n        }\n      }\n    }\n    function handleSelfClosingCharacters(event) {\n      const open = `([{'\"`;\n      const close4 = `)]}'\"`;\n      if (open.includes(event.key)) {\n        preventDefault(event);\n        const pos = save();\n        const wrapText = pos.start == pos.end ? \"\" : getSelection2().toString();\n        const text2 = event.key + wrapText + close4[open.indexOf(event.key)];\n        insert2(text2);\n        pos.start++;\n        pos.end++;\n        restore(pos);\n      }\n    }\n    function handleTabCharacters(event) {\n      if (event.key === \"Tab\") {\n        preventDefault(event);\n        if (event.shiftKey) {\n          const before2 = beforeCursor();\n          let [padding, start] = findPadding(before2);\n          if (padding.length > 0) {\n            const pos = save();\n            const len2 = Math.min(options2.tab.length, padding.length);\n            restore({ start, end: start + len2 });\n            document2.execCommand(\"delete\");\n            pos.start -= len2;\n            pos.end -= len2;\n            restore(pos);\n          }\n        } else {\n          insert2(options2.tab);\n        }\n      }\n    }\n    function handleUndoRedo(event) {\n      if (isUndo(event)) {\n        preventDefault(event);\n        at--;\n        const record = history2[at];\n        if (record) {\n          editor.innerHTML = record.html;\n          restore(record.pos);\n        }\n        if (at < 0)\n          at = 0;\n      }\n      if (isRedo(event)) {\n        preventDefault(event);\n        at++;\n        const record = history2[at];\n        if (record) {\n          editor.innerHTML = record.html;\n          restore(record.pos);\n        }\n        if (at >= history2.length)\n          at--;\n      }\n    }\n    function recordHistory() {\n      if (!focus)\n        return;\n      const html2 = editor.innerHTML;\n      const pos = save();\n      const lastRecord = history2[at];\n      if (lastRecord) {\n        if (lastRecord.html === html2 && lastRecord.pos.start === pos.start && lastRecord.pos.end === pos.end)\n          return;\n      }\n      at++;\n      history2[at] = { html: html2, pos };\n      history2.splice(at + 1);\n      const maxHistory = 300;\n      if (at > maxHistory) {\n        at = maxHistory;\n        history2.splice(0, 1);\n      }\n    }\n    function handlePaste(event) {\n      if (event.defaultPrevented)\n        return;\n      preventDefault(event);\n      const originalEvent = event.originalEvent ?? event;\n      const text2 = originalEvent.clipboardData.getData(\"text/plain\").replace(/\\r\\n?/g, \"\\n\");\n      const pos = save();\n      insert2(text2);\n      doHighlight(editor);\n      restore({\n        start: Math.min(pos.start, pos.end) + text2.length,\n        end: Math.min(pos.start, pos.end) + text2.length,\n        dir: \"<-\"\n      });\n    }\n    function handleCut(event) {\n      const pos = save();\n      const selection2 = getSelection2();\n      const originalEvent = event.originalEvent ?? event;\n      originalEvent.clipboardData.setData(\"text/plain\", selection2.toString());\n      document2.execCommand(\"delete\");\n      doHighlight(editor);\n      restore({\n        start: Math.min(pos.start, pos.end),\n        end: Math.min(pos.start, pos.end),\n        dir: \"<-\"\n      });\n      preventDefault(event);\n    }\n    function visit(editor2, visitor) {\n      const queue = [];\n      if (editor2.firstChild)\n        queue.push(editor2.firstChild);\n      let el = queue.pop();\n      while (el) {\n        if (visitor(el) === \"stop\")\n          break;\n        if (el.nextSibling)\n          queue.push(el.nextSibling);\n        if (el.firstChild)\n          queue.push(el.firstChild);\n        el = queue.pop();\n      }\n    }\n    function isCtrl(event) {\n      return event.metaKey || event.ctrlKey;\n    }\n    function isUndo(event) {\n      return isCtrl(event) && !event.shiftKey && getKeyCode(event) === \"Z\";\n    }\n    function isRedo(event) {\n      return isCtrl(event) && event.shiftKey && getKeyCode(event) === \"Z\";\n    }\n    function isCopy(event) {\n      return isCtrl(event) && getKeyCode(event) === \"C\";\n    }\n    function getKeyCode(event) {\n      let key = event.key || event.keyCode || event.which;\n      if (!key)\n        return void 0;\n      return (typeof key === \"string\" ? key : String.fromCharCode(key)).toUpperCase();\n    }\n    function insert2(text2) {\n      text2 = text2.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n      document2.execCommand(\"insertHTML\", false, text2);\n    }\n    function debounce(cb, wait2) {\n      let timeout = 0;\n      return (...args) => {\n        clearTimeout(timeout);\n        timeout = window2.setTimeout(() => cb(...args), wait2);\n      };\n    }\n    function findPadding(text2) {\n      let i = text2.length - 1;\n      while (i >= 0 && text2[i] !== \"\\n\")\n        i--;\n      i++;\n      let j = i;\n      while (j < text2.length && /[ \\t]/.test(text2[j]))\n        j++;\n      return [text2.substring(i, j) || \"\", i, j];\n    }\n    function toString() {\n      return editor.textContent || \"\";\n    }\n    function preventDefault(event) {\n      event.preventDefault();\n    }\n    function getSelection2() {\n      if (editor.parentNode?.nodeType == Node.DOCUMENT_FRAGMENT_NODE) {\n        return editor.parentNode.getSelection();\n      }\n      return window2.getSelection();\n    }\n    return {\n      updateOptions(newOptions) {\n        Object.assign(options2, newOptions);\n      },\n      updateCode(code) {\n        editor.textContent = code;\n        doHighlight(editor);\n        onUpdate(code);\n      },\n      onUpdate(callback) {\n        onUpdate = callback;\n      },\n      toString,\n      save,\n      restore,\n      recordHistory,\n      destroy() {\n        for (let [type, fn] of listeners) {\n          editor.removeEventListener(type, fn);\n        }\n      }\n    };\n  }\n  var globalWindow;\n  var init_codejar = __esm({\n    \"node_modules/.pnpm/codejar@4.2.0/node_modules/codejar/dist/codejar.js\"() {\n      init_reload();\n      globalWindow = window;\n    }\n  });\n\n  // src/client/components/Code.svelte\n  function create_fragment8(ctx) {\n    let pre;\n    let code;\n    let codedit_action;\n    let mounted;\n    let dispose;\n    const block2 = {\n      c: function create() {\n        pre = element(\"pre\");\n        code = element(\"code\");\n        toggle_class(\n          code,\n          \"invalid\",\n          /*invalid*/\n          ctx[1]\n        );\n        add_location(code, file8, 38, 5, 722);\n        add_location(pre, file8, 38, 0, 717);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, pre, anchor);\n        append_dev(pre, code);\n        if (!mounted) {\n          dispose = action_destroyer(codedit_action = /*codedit*/\n          ctx[2].call(\n            null,\n            code,\n            /*input*/\n            ctx[0]\n          ));\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (codedit_action && is_function(codedit_action.update) && dirty & /*input*/\n        1) codedit_action.update.call(\n          null,\n          /*input*/\n          ctx2[0]\n        );\n        if (dirty & /*invalid*/\n        2) {\n          toggle_class(\n            code,\n            \"invalid\",\n            /*invalid*/\n            ctx2[1]\n          );\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(pre);\n        }\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment8.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance8($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Code\", slots, []);\n    let { input = \"\" } = $$props;\n    let { output = \"\" } = $$props;\n    let { invalid = false } = $$props;\n    function codedit(node, cd) {\n      const highlight = (editor2) => {\n        const code = editor2.textContent;\n      };\n      node.onkeydown = (e) => e.stopPropagation();\n      const editor = CodeJar(node, highlight);\n      function update2(cd2) {\n        editor.updateCode(cd2);\n      }\n      editor.onUpdate((text2) => {\n        $$invalidate(3, output = text2);\n      });\n      update2(cd);\n      return {\n        update: update2,\n        destroy() {\n          editor.destroy();\n        }\n      };\n    }\n    const writable_props = [\"input\", \"output\", \"invalid\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Code> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"input\" in $$props2) $$invalidate(0, input = $$props2.input);\n      if (\"output\" in $$props2) $$invalidate(3, output = $$props2.output);\n      if (\"invalid\" in $$props2) $$invalidate(1, invalid = $$props2.invalid);\n    };\n    $$self.$capture_state = () => ({ CodeJar, input, output, invalid, codedit });\n    $$self.$inject_state = ($$props2) => {\n      if (\"input\" in $$props2) $$invalidate(0, input = $$props2.input);\n      if (\"output\" in $$props2) $$invalidate(3, output = $$props2.output);\n      if (\"invalid\" in $$props2) $$invalidate(1, invalid = $$props2.invalid);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [input, invalid, codedit, output];\n  }\n  var file8, Code, Code_default;\n  var init_Code = __esm({\n    \"src/client/components/Code.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_codejar();\n      file8 = \"src/client/components/Code.svelte\";\n      Code = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance8, create_fragment8, safe_not_equal, {\n            input: 0,\n            output: 3,\n            invalid: 1,\n            codedit: 2\n          });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Code\",\n            options: options2,\n            id: create_fragment8.name\n          });\n        }\n        get input() {\n          throw new Error(\"<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set input(value) {\n          throw new Error(\"<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get output() {\n          throw new Error(\"<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set output(value) {\n          throw new Error(\"<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get invalid() {\n          throw new Error(\"<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set invalid(value) {\n          throw new Error(\"<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get codedit() {\n          return this.$$.ctx[2];\n        }\n        set codedit(value) {\n          throw new Error(\"<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      Code_default = Code;\n    }\n  });\n\n  // node_modules/.pnpm/marked@13.0.2/node_modules/marked/lib/marked.esm.js\n  function _getDefaults() {\n    return {\n      async: false,\n      breaks: false,\n      extensions: null,\n      gfm: true,\n      hooks: null,\n      pedantic: false,\n      renderer: null,\n      silent: false,\n      tokenizer: null,\n      walkTokens: null\n    };\n  }\n  function changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n  }\n  function escape$1(html2, encode) {\n    if (encode) {\n      if (escapeTest.test(html2)) {\n        return html2.replace(escapeReplace, getEscapeReplacement);\n      }\n    } else {\n      if (escapeTestNoEncode.test(html2)) {\n        return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);\n      }\n    }\n    return html2;\n  }\n  function unescape(html2) {\n    return html2.replace(unescapeTest, (_, n) => {\n      n = n.toLowerCase();\n      if (n === \"colon\")\n        return \":\";\n      if (n.charAt(0) === \"#\") {\n        return n.charAt(1) === \"x\" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n      }\n      return \"\";\n    });\n  }\n  function edit(regex, opt) {\n    let source = typeof regex === \"string\" ? regex : regex.source;\n    opt = opt || \"\";\n    const obj = {\n      replace: (name2, val) => {\n        let valSource = typeof val === \"string\" ? val : val.source;\n        valSource = valSource.replace(caret, \"$1\");\n        source = source.replace(name2, valSource);\n        return obj;\n      },\n      getRegex: () => {\n        return new RegExp(source, opt);\n      }\n    };\n    return obj;\n  }\n  function cleanUrl(href) {\n    try {\n      href = encodeURI(href).replace(/%25/g, \"%\");\n    } catch (e) {\n      return null;\n    }\n    return href;\n  }\n  function splitCells(tableRow, count) {\n    const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n      let escaped = false;\n      let curr = offset;\n      while (--curr >= 0 && str[curr] === \"\\\\\")\n        escaped = !escaped;\n      if (escaped) {\n        return \"|\";\n      } else {\n        return \" |\";\n      }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    if (!cells[0].trim()) {\n      cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n      cells.pop();\n    }\n    if (count) {\n      if (cells.length > count) {\n        cells.splice(count);\n      } else {\n        while (cells.length < count)\n          cells.push(\"\");\n      }\n    }\n    for (; i < cells.length; i++) {\n      cells[i] = cells[i].trim().replace(/\\\\\\|/g, \"|\");\n    }\n    return cells;\n  }\n  function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n      return \"\";\n    }\n    let suffLen = 0;\n    while (suffLen < l) {\n      const currChar = str.charAt(l - suffLen - 1);\n      if (currChar === c && !invert) {\n        suffLen++;\n      } else if (currChar !== c && invert) {\n        suffLen++;\n      } else {\n        break;\n      }\n    }\n    return str.slice(0, l - suffLen);\n  }\n  function findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n      return -1;\n    }\n    let level = 0;\n    for (let i = 0; i < str.length; i++) {\n      if (str[i] === \"\\\\\") {\n        i++;\n      } else if (str[i] === b[0]) {\n        level++;\n      } else if (str[i] === b[1]) {\n        level--;\n        if (level < 0) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  function outputLink(cap, link2, raw, lexer2) {\n    const href = link2.href;\n    const title = link2.title ? escape$1(link2.title) : null;\n    const text2 = cap[1].replace(/\\\\([\\[\\]])/g, \"$1\");\n    if (cap[0].charAt(0) !== \"!\") {\n      lexer2.state.inLink = true;\n      const token = {\n        type: \"link\",\n        raw,\n        href,\n        title,\n        text: text2,\n        tokens: lexer2.inlineTokens(text2)\n      };\n      lexer2.state.inLink = false;\n      return token;\n    }\n    return {\n      type: \"image\",\n      raw,\n      href,\n      title,\n      text: escape$1(text2)\n    };\n  }\n  function indentCodeCompensation(raw, text2) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n      return text2;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text2.split(\"\\n\").map((node) => {\n      const matchIndentInNode = node.match(/^\\s+/);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n      const [indentInNode] = matchIndentInNode;\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n      return node;\n    }).join(\"\\n\");\n  }\n  function marked(src, opt) {\n    return markedInstance.parse(src, opt);\n  }\n  var _defaults, escapeTest, escapeReplace, escapeTestNoEncode, escapeReplaceNoEncode, escapeReplacements, getEscapeReplacement, unescapeTest, caret, noopTest, _Tokenizer, newline, blockCode, fences, hr, heading, bullet, lheading, _paragraph, blockText, _blockLabel, def, list, _tag, _comment, html, paragraph, blockquote, blockNormal, gfmTable, blockGfm, blockPedantic, escape, inlineCode, br, inlineText, _punctuation, punctuation, blockSkip, emStrongLDelim, emStrongRDelimAst, emStrongRDelimUnd, anyPunctuation, autolink, _inlineComment, tag, _inlineLabel, link, reflink, nolink, reflinkSearch, inlineNormal, inlinePedantic, inlineGfm, inlineBreaks, block, inline, _Lexer, _Renderer, _TextRenderer, _Parser, _Hooks, Marked, markedInstance, options, setOptions, use, walkTokens, parseInline, parser, lexer;\n  var init_marked_esm = __esm({\n    \"node_modules/.pnpm/marked@13.0.2/node_modules/marked/lib/marked.esm.js\"() {\n      init_reload();\n      _defaults = _getDefaults();\n      escapeTest = /[&<>\"']/;\n      escapeReplace = new RegExp(escapeTest.source, \"g\");\n      escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\n      escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, \"g\");\n      escapeReplacements = {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#39;\"\n      };\n      getEscapeReplacement = (ch) => escapeReplacements[ch];\n      unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n      caret = /(^|[^\\[])\\^/g;\n      noopTest = { exec: () => null };\n      _Tokenizer = class {\n        options;\n        rules;\n        // set by the lexer\n        lexer;\n        // set by the lexer\n        constructor(options2) {\n          this.options = options2 || _defaults;\n        }\n        space(src) {\n          const cap = this.rules.block.newline.exec(src);\n          if (cap && cap[0].length > 0) {\n            return {\n              type: \"space\",\n              raw: cap[0]\n            };\n          }\n        }\n        code(src) {\n          const cap = this.rules.block.code.exec(src);\n          if (cap) {\n            const text2 = cap[0].replace(/^ {1,4}/gm, \"\");\n            return {\n              type: \"code\",\n              raw: cap[0],\n              codeBlockStyle: \"indented\",\n              text: !this.options.pedantic ? rtrim(text2, \"\\n\") : text2\n            };\n          }\n        }\n        fences(src) {\n          const cap = this.rules.block.fences.exec(src);\n          if (cap) {\n            const raw = cap[0];\n            const text2 = indentCodeCompensation(raw, cap[3] || \"\");\n            return {\n              type: \"code\",\n              raw,\n              lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, \"$1\") : cap[2],\n              text: text2\n            };\n          }\n        }\n        heading(src) {\n          const cap = this.rules.block.heading.exec(src);\n          if (cap) {\n            let text2 = cap[2].trim();\n            if (/#$/.test(text2)) {\n              const trimmed = rtrim(text2, \"#\");\n              if (this.options.pedantic) {\n                text2 = trimmed.trim();\n              } else if (!trimmed || / $/.test(trimmed)) {\n                text2 = trimmed.trim();\n              }\n            }\n            return {\n              type: \"heading\",\n              raw: cap[0],\n              depth: cap[1].length,\n              text: text2,\n              tokens: this.lexer.inline(text2)\n            };\n          }\n        }\n        hr(src) {\n          const cap = this.rules.block.hr.exec(src);\n          if (cap) {\n            return {\n              type: \"hr\",\n              raw: rtrim(cap[0], \"\\n\")\n            };\n          }\n        }\n        blockquote(src) {\n          const cap = this.rules.block.blockquote.exec(src);\n          if (cap) {\n            let lines = rtrim(cap[0], \"\\n\").split(\"\\n\");\n            let raw = \"\";\n            let text2 = \"\";\n            const tokens = [];\n            while (lines.length > 0) {\n              let inBlockquote = false;\n              const currentLines = [];\n              let i;\n              for (i = 0; i < lines.length; i++) {\n                if (/^ {0,3}>/.test(lines[i])) {\n                  currentLines.push(lines[i]);\n                  inBlockquote = true;\n                } else if (!inBlockquote) {\n                  currentLines.push(lines[i]);\n                } else {\n                  break;\n                }\n              }\n              lines = lines.slice(i);\n              const currentRaw = currentLines.join(\"\\n\");\n              const currentText = currentRaw.replace(/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g, \"\\n    $1\").replace(/^ {0,3}>[ \\t]?/gm, \"\");\n              raw = raw ? `${raw}\n${currentRaw}` : currentRaw;\n              text2 = text2 ? `${text2}\n${currentText}` : currentText;\n              const top = this.lexer.state.top;\n              this.lexer.state.top = true;\n              this.lexer.blockTokens(currentText, tokens, true);\n              this.lexer.state.top = top;\n              if (lines.length === 0) {\n                break;\n              }\n              const lastToken = tokens[tokens.length - 1];\n              if (lastToken?.type === \"code\") {\n                break;\n              } else if (lastToken?.type === \"blockquote\") {\n                const oldToken = lastToken;\n                const newText = oldToken.raw + \"\\n\" + lines.join(\"\\n\");\n                const newToken = this.blockquote(newText);\n                tokens[tokens.length - 1] = newToken;\n                raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                text2 = text2.substring(0, text2.length - oldToken.text.length) + newToken.text;\n                break;\n              } else if (lastToken?.type === \"list\") {\n                const oldToken = lastToken;\n                const newText = oldToken.raw + \"\\n\" + lines.join(\"\\n\");\n                const newToken = this.list(newText);\n                tokens[tokens.length - 1] = newToken;\n                raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                text2 = text2.substring(0, text2.length - oldToken.raw.length) + newToken.raw;\n                lines = newText.substring(tokens[tokens.length - 1].raw.length).split(\"\\n\");\n                continue;\n              }\n            }\n            return {\n              type: \"blockquote\",\n              raw,\n              tokens,\n              text: text2\n            };\n          }\n        }\n        list(src) {\n          let cap = this.rules.block.list.exec(src);\n          if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list2 = {\n              type: \"list\",\n              raw: \"\",\n              ordered: isordered,\n              start: isordered ? +bull.slice(0, -1) : \"\",\n              loose: false,\n              items: []\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n              bull = isordered ? bull : \"[*+-]\";\n            }\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let endsWithBlankLine = false;\n            while (src) {\n              let endEarly = false;\n              let raw = \"\";\n              let itemContents = \"\";\n              if (!(cap = itemRegex.exec(src))) {\n                break;\n              }\n              if (this.rules.block.hr.test(src)) {\n                break;\n              }\n              raw = cap[0];\n              src = src.substring(raw.length);\n              let line = cap[2].split(\"\\n\", 1)[0].replace(/^\\t+/, (t) => \" \".repeat(3 * t.length));\n              let nextLine = src.split(\"\\n\", 1)[0];\n              let blankLine = !line.trim();\n              let indent = 0;\n              if (this.options.pedantic) {\n                indent = 2;\n                itemContents = line.trimStart();\n              } else if (blankLine) {\n                indent = cap[1].length + 1;\n              } else {\n                indent = cap[2].search(/[^ ]/);\n                indent = indent > 4 ? 1 : indent;\n                itemContents = line.slice(indent);\n                indent += cap[1].length;\n              }\n              if (blankLine && /^ *$/.test(nextLine)) {\n                raw += nextLine + \"\\n\";\n                src = src.substring(nextLine.length + 1);\n                endEarly = true;\n              }\n              if (!endEarly) {\n                const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \t][^\\\\n]*)?(?:\\\\n|$))`);\n                const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                while (src) {\n                  const rawLine = src.split(\"\\n\", 1)[0];\n                  nextLine = rawLine;\n                  if (this.options.pedantic) {\n                    nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, \"  \");\n                  }\n                  if (fencesBeginRegex.test(nextLine)) {\n                    break;\n                  }\n                  if (headingBeginRegex.test(nextLine)) {\n                    break;\n                  }\n                  if (nextBulletRegex.test(nextLine)) {\n                    break;\n                  }\n                  if (hrRegex.test(src)) {\n                    break;\n                  }\n                  if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {\n                    itemContents += \"\\n\" + nextLine.slice(indent);\n                  } else {\n                    if (blankLine) {\n                      break;\n                    }\n                    if (line.search(/[^ ]/) >= 4) {\n                      break;\n                    }\n                    if (fencesBeginRegex.test(line)) {\n                      break;\n                    }\n                    if (headingBeginRegex.test(line)) {\n                      break;\n                    }\n                    if (hrRegex.test(line)) {\n                      break;\n                    }\n                    itemContents += \"\\n\" + nextLine;\n                  }\n                  if (!blankLine && !nextLine.trim()) {\n                    blankLine = true;\n                  }\n                  raw += rawLine + \"\\n\";\n                  src = src.substring(rawLine.length + 1);\n                  line = nextLine.slice(indent);\n                }\n              }\n              if (!list2.loose) {\n                if (endsWithBlankLine) {\n                  list2.loose = true;\n                } else if (/\\n *\\n *$/.test(raw)) {\n                  endsWithBlankLine = true;\n                }\n              }\n              let istask = null;\n              let ischecked;\n              if (this.options.gfm) {\n                istask = /^\\[[ xX]\\] /.exec(itemContents);\n                if (istask) {\n                  ischecked = istask[0] !== \"[ ] \";\n                  itemContents = itemContents.replace(/^\\[[ xX]\\] +/, \"\");\n                }\n              }\n              list2.items.push({\n                type: \"list_item\",\n                raw,\n                task: !!istask,\n                checked: ischecked,\n                loose: false,\n                text: itemContents,\n                tokens: []\n              });\n              list2.raw += raw;\n            }\n            list2.items[list2.items.length - 1].raw = list2.items[list2.items.length - 1].raw.trimEnd();\n            list2.items[list2.items.length - 1].text = list2.items[list2.items.length - 1].text.trimEnd();\n            list2.raw = list2.raw.trimEnd();\n            for (let i = 0; i < list2.items.length; i++) {\n              this.lexer.state.top = false;\n              list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);\n              if (!list2.loose) {\n                const spacers = list2.items[i].tokens.filter((t) => t.type === \"space\");\n                const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\\n.*\\n/.test(t.raw));\n                list2.loose = hasMultipleLineBreaks;\n              }\n            }\n            if (list2.loose) {\n              for (let i = 0; i < list2.items.length; i++) {\n                list2.items[i].loose = true;\n              }\n            }\n            return list2;\n          }\n        }\n        html(src) {\n          const cap = this.rules.block.html.exec(src);\n          if (cap) {\n            const token = {\n              type: \"html\",\n              block: true,\n              raw: cap[0],\n              pre: cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\",\n              text: cap[0]\n            };\n            return token;\n          }\n        }\n        def(src) {\n          const cap = this.rules.block.def.exec(src);\n          if (cap) {\n            const tag2 = cap[1].toLowerCase().replace(/\\s+/g, \" \");\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, \"$1\").replace(this.rules.inline.anyPunctuation, \"$1\") : \"\";\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, \"$1\") : cap[3];\n            return {\n              type: \"def\",\n              tag: tag2,\n              raw: cap[0],\n              href,\n              title\n            };\n          }\n        }\n        table(src) {\n          const cap = this.rules.block.table.exec(src);\n          if (!cap) {\n            return;\n          }\n          if (!/[:|]/.test(cap[2])) {\n            return;\n          }\n          const headers = splitCells(cap[1]);\n          const aligns = cap[2].replace(/^\\||\\| *$/g, \"\").split(\"|\");\n          const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, \"\").split(\"\\n\") : [];\n          const item = {\n            type: \"table\",\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: []\n          };\n          if (headers.length !== aligns.length) {\n            return;\n          }\n          for (const align of aligns) {\n            if (/^ *-+: *$/.test(align)) {\n              item.align.push(\"right\");\n            } else if (/^ *:-+: *$/.test(align)) {\n              item.align.push(\"center\");\n            } else if (/^ *:-+ *$/.test(align)) {\n              item.align.push(\"left\");\n            } else {\n              item.align.push(null);\n            }\n          }\n          for (let i = 0; i < headers.length; i++) {\n            item.header.push({\n              text: headers[i],\n              tokens: this.lexer.inline(headers[i]),\n              header: true,\n              align: item.align[i]\n            });\n          }\n          for (const row of rows) {\n            item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n              return {\n                text: cell,\n                tokens: this.lexer.inline(cell),\n                header: false,\n                align: item.align[i]\n              };\n            }));\n          }\n          return item;\n        }\n        lheading(src) {\n          const cap = this.rules.block.lheading.exec(src);\n          if (cap) {\n            return {\n              type: \"heading\",\n              raw: cap[0],\n              depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n              text: cap[1],\n              tokens: this.lexer.inline(cap[1])\n            };\n          }\n        }\n        paragraph(src) {\n          const cap = this.rules.block.paragraph.exec(src);\n          if (cap) {\n            const text2 = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n            return {\n              type: \"paragraph\",\n              raw: cap[0],\n              text: text2,\n              tokens: this.lexer.inline(text2)\n            };\n          }\n        }\n        text(src) {\n          const cap = this.rules.block.text.exec(src);\n          if (cap) {\n            return {\n              type: \"text\",\n              raw: cap[0],\n              text: cap[0],\n              tokens: this.lexer.inline(cap[0])\n            };\n          }\n        }\n        escape(src) {\n          const cap = this.rules.inline.escape.exec(src);\n          if (cap) {\n            return {\n              type: \"escape\",\n              raw: cap[0],\n              text: escape$1(cap[1])\n            };\n          }\n        }\n        tag(src) {\n          const cap = this.rules.inline.tag.exec(src);\n          if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n              this.lexer.state.inLink = true;\n            } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n              this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n              this.lexer.state.inRawBlock = true;\n            } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n              this.lexer.state.inRawBlock = false;\n            }\n            return {\n              type: \"html\",\n              raw: cap[0],\n              inLink: this.lexer.state.inLink,\n              inRawBlock: this.lexer.state.inRawBlock,\n              block: false,\n              text: cap[0]\n            };\n          }\n        }\n        link(src) {\n          const cap = this.rules.inline.link.exec(src);\n          if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n              if (!/>$/.test(trimmedUrl)) {\n                return;\n              }\n              const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n              if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                return;\n              }\n            } else {\n              const lastParenIndex = findClosingBracket(cap[2], \"()\");\n              if (lastParenIndex > -1) {\n                const start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                const linkLen = start + cap[1].length + lastParenIndex;\n                cap[2] = cap[2].substring(0, lastParenIndex);\n                cap[0] = cap[0].substring(0, linkLen).trim();\n                cap[3] = \"\";\n              }\n            }\n            let href = cap[2];\n            let title = \"\";\n            if (this.options.pedantic) {\n              const link2 = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n              if (link2) {\n                href = link2[1];\n                title = link2[3];\n              }\n            } else {\n              title = cap[3] ? cap[3].slice(1, -1) : \"\";\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n              if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n                href = href.slice(1);\n              } else {\n                href = href.slice(1, -1);\n              }\n            }\n            return outputLink(cap, {\n              href: href ? href.replace(this.rules.inline.anyPunctuation, \"$1\") : href,\n              title: title ? title.replace(this.rules.inline.anyPunctuation, \"$1\") : title\n            }, cap[0], this.lexer);\n          }\n        }\n        reflink(src, links) {\n          let cap;\n          if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(/\\s+/g, \" \");\n            const link2 = links[linkString.toLowerCase()];\n            if (!link2) {\n              const text2 = cap[0].charAt(0);\n              return {\n                type: \"text\",\n                raw: text2,\n                text: text2\n              };\n            }\n            return outputLink(cap, link2, cap[0], this.lexer);\n          }\n        }\n        emStrong(src, maskedSrc, prevChar = \"\") {\n          let match = this.rules.inline.emStrongLDelim.exec(src);\n          if (!match)\n            return;\n          if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u))\n            return;\n          const nextChar = match[1] || match[2] || \"\";\n          if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            const lLength = [...match[0]].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === \"*\" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while ((match = endReg.exec(maskedSrc)) != null) {\n              rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n              if (!rDelim)\n                continue;\n              rLength = [...rDelim].length;\n              if (match[3] || match[4]) {\n                delimTotal += rLength;\n                continue;\n              } else if (match[5] || match[6]) {\n                if (lLength % 3 && !((lLength + rLength) % 3)) {\n                  midDelimTotal += rLength;\n                  continue;\n                }\n              }\n              delimTotal -= rLength;\n              if (delimTotal > 0)\n                continue;\n              rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n              const lastCharLength = [...match[0]][0].length;\n              const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n              if (Math.min(lLength, rLength) % 2) {\n                const text3 = raw.slice(1, -1);\n                return {\n                  type: \"em\",\n                  raw,\n                  text: text3,\n                  tokens: this.lexer.inlineTokens(text3)\n                };\n              }\n              const text2 = raw.slice(2, -2);\n              return {\n                type: \"strong\",\n                raw,\n                text: text2,\n                tokens: this.lexer.inlineTokens(text2)\n              };\n            }\n          }\n        }\n        codespan(src) {\n          const cap = this.rules.inline.code.exec(src);\n          if (cap) {\n            let text2 = cap[2].replace(/\\n/g, \" \");\n            const hasNonSpaceChars = /[^ ]/.test(text2);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n              text2 = text2.substring(1, text2.length - 1);\n            }\n            text2 = escape$1(text2, true);\n            return {\n              type: \"codespan\",\n              raw: cap[0],\n              text: text2\n            };\n          }\n        }\n        br(src) {\n          const cap = this.rules.inline.br.exec(src);\n          if (cap) {\n            return {\n              type: \"br\",\n              raw: cap[0]\n            };\n          }\n        }\n        del(src) {\n          const cap = this.rules.inline.del.exec(src);\n          if (cap) {\n            return {\n              type: \"del\",\n              raw: cap[0],\n              text: cap[2],\n              tokens: this.lexer.inlineTokens(cap[2])\n            };\n          }\n        }\n        autolink(src) {\n          const cap = this.rules.inline.autolink.exec(src);\n          if (cap) {\n            let text2, href;\n            if (cap[2] === \"@\") {\n              text2 = escape$1(cap[1]);\n              href = \"mailto:\" + text2;\n            } else {\n              text2 = escape$1(cap[1]);\n              href = text2;\n            }\n            return {\n              type: \"link\",\n              raw: cap[0],\n              text: text2,\n              href,\n              tokens: [\n                {\n                  type: \"text\",\n                  raw: text2,\n                  text: text2\n                }\n              ]\n            };\n          }\n        }\n        url(src) {\n          let cap;\n          if (cap = this.rules.inline.url.exec(src)) {\n            let text2, href;\n            if (cap[2] === \"@\") {\n              text2 = escape$1(cap[0]);\n              href = \"mailto:\" + text2;\n            } else {\n              let prevCapZero;\n              do {\n                prevCapZero = cap[0];\n                cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? \"\";\n              } while (prevCapZero !== cap[0]);\n              text2 = escape$1(cap[0]);\n              if (cap[1] === \"www.\") {\n                href = \"http://\" + cap[0];\n              } else {\n                href = cap[0];\n              }\n            }\n            return {\n              type: \"link\",\n              raw: cap[0],\n              text: text2,\n              href,\n              tokens: [\n                {\n                  type: \"text\",\n                  raw: text2,\n                  text: text2\n                }\n              ]\n            };\n          }\n        }\n        inlineText(src) {\n          const cap = this.rules.inline.text.exec(src);\n          if (cap) {\n            let text2;\n            if (this.lexer.state.inRawBlock) {\n              text2 = cap[0];\n            } else {\n              text2 = escape$1(cap[0]);\n            }\n            return {\n              type: \"text\",\n              raw: cap[0],\n              text: text2\n            };\n          }\n        }\n      };\n      newline = /^(?: *(?:\\n|$))+/;\n      blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\n      fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\n      hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\n      heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\n      bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n      lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/).replace(/bull/g, bullet).replace(/blockCode/g, / {4}/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\\n>]+>\\n/).getRegex();\n      _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\n      blockText = /^[^\\n]+/;\n      _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n      def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/).replace(\"label\", _blockLabel).replace(\"title\", /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/).getRegex();\n      list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g, bullet).getRegex();\n      _tag = \"address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul\";\n      _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\n      html = edit(\"^ {0,3}(?:<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)|comment[^\\\\n]*(\\\\n+|$)|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$))\", \"i\").replace(\"comment\", _comment).replace(\"tag\", _tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n      paragraph = edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\").replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \").replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag).getRegex();\n      blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace(\"paragraph\", paragraph).getRegex();\n      blockNormal = {\n        blockquote,\n        code: blockCode,\n        def,\n        fences,\n        heading,\n        hr,\n        html,\n        lheading,\n        list,\n        newline,\n        paragraph,\n        table: noopTest,\n        text: blockText\n      };\n      gfmTable = edit(\"^ *([^\\\\n ].*)\\\\n {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\").replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \" {4}[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \").replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag).getRegex();\n      blockGfm = {\n        ...blockNormal,\n        table: gfmTable,\n        paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\").replace(\"table\", gfmTable).replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \").replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag).getRegex()\n      };\n      blockPedantic = {\n        ...blockNormal,\n        html: edit(`^ *(?:comment *(?:\\\\n|\\\\s*$)|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\\\s[^'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))`).replace(\"comment\", _comment).replace(/tag/g, \"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n        def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n        heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n        fences: noopTest,\n        // fences not supported\n        lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n        paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", lheading).replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").replace(\"|tag\", \"\").getRegex()\n      };\n      escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\n      inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\n      br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\n      inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n      _punctuation = \"\\\\p{P}\\\\p{S}\";\n      punctuation = edit(/^((?![*_])[\\spunctuation])/, \"u\").replace(/punctuation/g, _punctuation).getRegex();\n      blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\n      emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, \"u\").replace(/punct/g, _punctuation).getRegex();\n      emStrongRDelimAst = edit(\"^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])\", \"gu\").replace(/punct/g, _punctuation).getRegex();\n      emStrongRDelimUnd = edit(\"^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\\\s]|$)|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])|[\\\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])\", \"gu\").replace(/punct/g, _punctuation).getRegex();\n      anyPunctuation = edit(/\\\\([punct])/, \"gu\").replace(/punct/g, _punctuation).getRegex();\n      autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace(\"scheme\", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace(\"email\", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();\n      _inlineComment = edit(_comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\n      tag = edit(\"^comment|^</[a-zA-Z][\\\\w:-]*\\\\s*>|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>|^<\\\\?[\\\\s\\\\S]*?\\\\?>|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\").replace(\"comment\", _inlineComment).replace(\"attribute\", /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/).getRegex();\n      _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n      link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/).replace(\"label\", _inlineLabel).replace(\"href\", /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/).replace(\"title\", /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex();\n      reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/).replace(\"label\", _inlineLabel).replace(\"ref\", _blockLabel).getRegex();\n      nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/).replace(\"ref\", _blockLabel).getRegex();\n      reflinkSearch = edit(\"reflink|nolink(?!\\\\()\", \"g\").replace(\"reflink\", reflink).replace(\"nolink\", nolink).getRegex();\n      inlineNormal = {\n        _backpedal: noopTest,\n        // only used for GFM url\n        anyPunctuation,\n        autolink,\n        blockSkip,\n        br,\n        code: inlineCode,\n        del: noopTest,\n        emStrongLDelim,\n        emStrongRDelimAst,\n        emStrongRDelimUnd,\n        escape,\n        link,\n        nolink,\n        punctuation,\n        reflink,\n        reflinkSearch,\n        tag,\n        text: inlineText,\n        url: noopTest\n      };\n      inlinePedantic = {\n        ...inlineNormal,\n        link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", _inlineLabel).getRegex(),\n        reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", _inlineLabel).getRegex()\n      };\n      inlineGfm = {\n        ...inlineNormal,\n        escape: edit(escape).replace(\"])\", \"~|])\").getRegex(),\n        url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, \"i\").replace(\"email\", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),\n        _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n        del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n        text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n      };\n      inlineBreaks = {\n        ...inlineGfm,\n        br: edit(br).replace(\"{2,}\", \"*\").getRegex(),\n        text: edit(inlineGfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n      };\n      block = {\n        normal: blockNormal,\n        gfm: blockGfm,\n        pedantic: blockPedantic\n      };\n      inline = {\n        normal: inlineNormal,\n        gfm: inlineGfm,\n        breaks: inlineBreaks,\n        pedantic: inlinePedantic\n      };\n      _Lexer = class __Lexer {\n        tokens;\n        options;\n        state;\n        tokenizer;\n        inlineQueue;\n        constructor(options2) {\n          this.tokens = [];\n          this.tokens.links = /* @__PURE__ */ Object.create(null);\n          this.options = options2 || _defaults;\n          this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n          this.tokenizer = this.options.tokenizer;\n          this.tokenizer.options = this.options;\n          this.tokenizer.lexer = this;\n          this.inlineQueue = [];\n          this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n          };\n          const rules = {\n            block: block.normal,\n            inline: inline.normal\n          };\n          if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n          } else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n              rules.inline = inline.breaks;\n            } else {\n              rules.inline = inline.gfm;\n            }\n          }\n          this.tokenizer.rules = rules;\n        }\n        /**\n         * Expose Rules\n         */\n        static get rules() {\n          return {\n            block,\n            inline\n          };\n        }\n        /**\n         * Static Lex Method\n         */\n        static lex(src, options2) {\n          const lexer2 = new __Lexer(options2);\n          return lexer2.lex(src);\n        }\n        /**\n         * Static Lex Inline Method\n         */\n        static lexInline(src, options2) {\n          const lexer2 = new __Lexer(options2);\n          return lexer2.inlineTokens(src);\n        }\n        /**\n         * Preprocessing\n         */\n        lex(src) {\n          src = src.replace(/\\r\\n|\\r/g, \"\\n\");\n          this.blockTokens(src, this.tokens);\n          for (let i = 0; i < this.inlineQueue.length; i++) {\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n          }\n          this.inlineQueue = [];\n          return this.tokens;\n        }\n        blockTokens(src, tokens = [], lastParagraphClipped = false) {\n          if (this.options.pedantic) {\n            src = src.replace(/\\t/g, \"    \").replace(/^ +$/gm, \"\");\n          } else {\n            src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n              return leading + \"    \".repeat(tabs.length);\n            });\n          }\n          let token;\n          let lastToken;\n          let cutSrc;\n          while (src) {\n            if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {\n              if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                return true;\n              }\n              return false;\n            })) {\n              continue;\n            }\n            if (token = this.tokenizer.space(src)) {\n              src = src.substring(token.raw.length);\n              if (token.raw.length === 1 && tokens.length > 0) {\n                tokens[tokens.length - 1].raw += \"\\n\";\n              } else {\n                tokens.push(token);\n              }\n              continue;\n            }\n            if (token = this.tokenizer.code(src)) {\n              src = src.substring(token.raw.length);\n              lastToken = tokens[tokens.length - 1];\n              if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                lastToken.raw += \"\\n\" + token.raw;\n                lastToken.text += \"\\n\" + token.text;\n                this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n              } else {\n                tokens.push(token);\n              }\n              continue;\n            }\n            if (token = this.tokenizer.fences(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (token = this.tokenizer.heading(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (token = this.tokenizer.hr(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (token = this.tokenizer.blockquote(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (token = this.tokenizer.list(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (token = this.tokenizer.html(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (token = this.tokenizer.def(src)) {\n              src = src.substring(token.raw.length);\n              lastToken = tokens[tokens.length - 1];\n              if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                lastToken.raw += \"\\n\" + token.raw;\n                lastToken.text += \"\\n\" + token.raw;\n                this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n              } else if (!this.tokens.links[token.tag]) {\n                this.tokens.links[token.tag] = {\n                  href: token.href,\n                  title: token.title\n                };\n              }\n              continue;\n            }\n            if (token = this.tokenizer.table(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (token = this.tokenizer.lheading(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n              let startIndex = Infinity;\n              const tempSrc = src.slice(1);\n              let tempStart;\n              this.options.extensions.startBlock.forEach((getStartIndex) => {\n                tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                if (typeof tempStart === \"number\" && tempStart >= 0) {\n                  startIndex = Math.min(startIndex, tempStart);\n                }\n              });\n              if (startIndex < Infinity && startIndex >= 0) {\n                cutSrc = src.substring(0, startIndex + 1);\n              }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n              lastToken = tokens[tokens.length - 1];\n              if (lastParagraphClipped && lastToken?.type === \"paragraph\") {\n                lastToken.raw += \"\\n\" + token.raw;\n                lastToken.text += \"\\n\" + token.text;\n                this.inlineQueue.pop();\n                this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n              } else {\n                tokens.push(token);\n              }\n              lastParagraphClipped = cutSrc.length !== src.length;\n              src = src.substring(token.raw.length);\n              continue;\n            }\n            if (token = this.tokenizer.text(src)) {\n              src = src.substring(token.raw.length);\n              lastToken = tokens[tokens.length - 1];\n              if (lastToken && lastToken.type === \"text\") {\n                lastToken.raw += \"\\n\" + token.raw;\n                lastToken.text += \"\\n\" + token.text;\n                this.inlineQueue.pop();\n                this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n              } else {\n                tokens.push(token);\n              }\n              continue;\n            }\n            if (src) {\n              const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n              if (this.options.silent) {\n                console.error(errMsg);\n                break;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n          }\n          this.state.top = true;\n          return tokens;\n        }\n        inline(src, tokens = []) {\n          this.inlineQueue.push({ src, tokens });\n          return tokens;\n        }\n        /**\n         * Lexing/Compiling\n         */\n        inlineTokens(src, tokens = []) {\n          let token, lastToken, cutSrc;\n          let maskedSrc = src;\n          let match;\n          let keepPrevChar, prevChar;\n          if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n              while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) {\n                  maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                }\n              }\n            }\n          }\n          while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n          }\n          while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n          }\n          while (src) {\n            if (!keepPrevChar) {\n              prevChar = \"\";\n            }\n            keepPrevChar = false;\n            if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {\n              if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                return true;\n              }\n              return false;\n            })) {\n              continue;\n            }\n            if (token = this.tokenizer.escape(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (token = this.tokenizer.tag(src)) {\n              src = src.substring(token.raw.length);\n              lastToken = tokens[tokens.length - 1];\n              if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                lastToken.raw += token.raw;\n                lastToken.text += token.text;\n              } else {\n                tokens.push(token);\n              }\n              continue;\n            }\n            if (token = this.tokenizer.link(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n              src = src.substring(token.raw.length);\n              lastToken = tokens[tokens.length - 1];\n              if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                lastToken.raw += token.raw;\n                lastToken.text += token.text;\n              } else {\n                tokens.push(token);\n              }\n              continue;\n            }\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (token = this.tokenizer.codespan(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (token = this.tokenizer.br(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (token = this.tokenizer.del(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (token = this.tokenizer.autolink(src)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              continue;\n            }\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n              let startIndex = Infinity;\n              const tempSrc = src.slice(1);\n              let tempStart;\n              this.options.extensions.startInline.forEach((getStartIndex) => {\n                tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                if (typeof tempStart === \"number\" && tempStart >= 0) {\n                  startIndex = Math.min(startIndex, tempStart);\n                }\n              });\n              if (startIndex < Infinity && startIndex >= 0) {\n                cutSrc = src.substring(0, startIndex + 1);\n              }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n              src = src.substring(token.raw.length);\n              if (token.raw.slice(-1) !== \"_\") {\n                prevChar = token.raw.slice(-1);\n              }\n              keepPrevChar = true;\n              lastToken = tokens[tokens.length - 1];\n              if (lastToken && lastToken.type === \"text\") {\n                lastToken.raw += token.raw;\n                lastToken.text += token.text;\n              } else {\n                tokens.push(token);\n              }\n              continue;\n            }\n            if (src) {\n              const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n              if (this.options.silent) {\n                console.error(errMsg);\n                break;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n          }\n          return tokens;\n        }\n      };\n      _Renderer = class {\n        options;\n        parser;\n        // set by the parser\n        constructor(options2) {\n          this.options = options2 || _defaults;\n        }\n        space(token) {\n          return \"\";\n        }\n        code({ text: text2, lang, escaped }) {\n          const langString = (lang || \"\").match(/^\\S*/)?.[0];\n          const code = text2.replace(/\\n$/, \"\") + \"\\n\";\n          if (!langString) {\n            return \"<pre><code>\" + (escaped ? code : escape$1(code, true)) + \"</code></pre>\\n\";\n          }\n          return '<pre><code class=\"language-' + escape$1(langString) + '\">' + (escaped ? code : escape$1(code, true)) + \"</code></pre>\\n\";\n        }\n        blockquote({ tokens }) {\n          const body = this.parser.parse(tokens);\n          return `<blockquote>\n${body}</blockquote>\n`;\n        }\n        html({ text: text2 }) {\n          return text2;\n        }\n        heading({ tokens, depth }) {\n          return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\n`;\n        }\n        hr(token) {\n          return \"<hr>\\n\";\n        }\n        list(token) {\n          const ordered = token.ordered;\n          const start = token.start;\n          let body = \"\";\n          for (let j = 0; j < token.items.length; j++) {\n            const item = token.items[j];\n            body += this.listitem(item);\n          }\n          const type = ordered ? \"ol\" : \"ul\";\n          const startAttr = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n          return \"<\" + type + startAttr + \">\\n\" + body + \"</\" + type + \">\\n\";\n        }\n        listitem(item) {\n          let itemBody = \"\";\n          if (item.task) {\n            const checkbox = this.checkbox({ checked: !!item.checked });\n            if (item.loose) {\n              if (item.tokens.length > 0 && item.tokens[0].type === \"paragraph\") {\n                item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") {\n                  item.tokens[0].tokens[0].text = checkbox + \" \" + item.tokens[0].tokens[0].text;\n                }\n              } else {\n                item.tokens.unshift({\n                  type: \"text\",\n                  raw: checkbox + \" \",\n                  text: checkbox + \" \"\n                });\n              }\n            } else {\n              itemBody += checkbox + \" \";\n            }\n          }\n          itemBody += this.parser.parse(item.tokens, !!item.loose);\n          return `<li>${itemBody}</li>\n`;\n        }\n        checkbox({ checked }) {\n          return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\">';\n        }\n        paragraph({ tokens }) {\n          return `<p>${this.parser.parseInline(tokens)}</p>\n`;\n        }\n        table(token) {\n          let header = \"\";\n          let cell = \"\";\n          for (let j = 0; j < token.header.length; j++) {\n            cell += this.tablecell(token.header[j]);\n          }\n          header += this.tablerow({ text: cell });\n          let body = \"\";\n          for (let j = 0; j < token.rows.length; j++) {\n            const row = token.rows[j];\n            cell = \"\";\n            for (let k = 0; k < row.length; k++) {\n              cell += this.tablecell(row[k]);\n            }\n            body += this.tablerow({ text: cell });\n          }\n          if (body)\n            body = `<tbody>${body}</tbody>`;\n          return \"<table>\\n<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n        }\n        tablerow({ text: text2 }) {\n          return `<tr>\n${text2}</tr>\n`;\n        }\n        tablecell(token) {\n          const content = this.parser.parseInline(token.tokens);\n          const type = token.header ? \"th\" : \"td\";\n          const tag2 = token.align ? `<${type} align=\"${token.align}\">` : `<${type}>`;\n          return tag2 + content + `</${type}>\n`;\n        }\n        /**\n         * span level renderer\n         */\n        strong({ tokens }) {\n          return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n        }\n        em({ tokens }) {\n          return `<em>${this.parser.parseInline(tokens)}</em>`;\n        }\n        codespan({ text: text2 }) {\n          return `<code>${text2}</code>`;\n        }\n        br(token) {\n          return \"<br>\";\n        }\n        del({ tokens }) {\n          return `<del>${this.parser.parseInline(tokens)}</del>`;\n        }\n        link({ href, title, tokens }) {\n          const text2 = this.parser.parseInline(tokens);\n          const cleanHref = cleanUrl(href);\n          if (cleanHref === null) {\n            return text2;\n          }\n          href = cleanHref;\n          let out = '<a href=\"' + href + '\"';\n          if (title) {\n            out += ' title=\"' + title + '\"';\n          }\n          out += \">\" + text2 + \"</a>\";\n          return out;\n        }\n        image({ href, title, text: text2 }) {\n          const cleanHref = cleanUrl(href);\n          if (cleanHref === null) {\n            return text2;\n          }\n          href = cleanHref;\n          let out = `<img src=\"${href}\" alt=\"${text2}\"`;\n          if (title) {\n            out += ` title=\"${title}\"`;\n          }\n          out += \">\";\n          return out;\n        }\n        text(token) {\n          return \"tokens\" in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;\n        }\n      };\n      _TextRenderer = class {\n        // no need for block level renderers\n        strong({ text: text2 }) {\n          return text2;\n        }\n        em({ text: text2 }) {\n          return text2;\n        }\n        codespan({ text: text2 }) {\n          return text2;\n        }\n        del({ text: text2 }) {\n          return text2;\n        }\n        html({ text: text2 }) {\n          return text2;\n        }\n        text({ text: text2 }) {\n          return text2;\n        }\n        link({ text: text2 }) {\n          return \"\" + text2;\n        }\n        image({ text: text2 }) {\n          return \"\" + text2;\n        }\n        br() {\n          return \"\";\n        }\n      };\n      _Parser = class __Parser {\n        options;\n        renderer;\n        textRenderer;\n        constructor(options2) {\n          this.options = options2 || _defaults;\n          this.options.renderer = this.options.renderer || new _Renderer();\n          this.renderer = this.options.renderer;\n          this.renderer.options = this.options;\n          this.renderer.parser = this;\n          this.textRenderer = new _TextRenderer();\n        }\n        /**\n         * Static Parse Method\n         */\n        static parse(tokens, options2) {\n          const parser2 = new __Parser(options2);\n          return parser2.parse(tokens);\n        }\n        /**\n         * Static Parse Inline Method\n         */\n        static parseInline(tokens, options2) {\n          const parser2 = new __Parser(options2);\n          return parser2.parseInline(tokens);\n        }\n        /**\n         * Parse Loop\n         */\n        parse(tokens, top = true) {\n          let out = \"\";\n          for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n              const genericToken = anyToken;\n              const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n              if (ret !== false || ![\"space\", \"hr\", \"heading\", \"code\", \"table\", \"blockquote\", \"list\", \"html\", \"paragraph\", \"text\"].includes(genericToken.type)) {\n                out += ret || \"\";\n                continue;\n              }\n            }\n            const token = anyToken;\n            switch (token.type) {\n              case \"space\": {\n                out += this.renderer.space(token);\n                continue;\n              }\n              case \"hr\": {\n                out += this.renderer.hr(token);\n                continue;\n              }\n              case \"heading\": {\n                out += this.renderer.heading(token);\n                continue;\n              }\n              case \"code\": {\n                out += this.renderer.code(token);\n                continue;\n              }\n              case \"table\": {\n                out += this.renderer.table(token);\n                continue;\n              }\n              case \"blockquote\": {\n                out += this.renderer.blockquote(token);\n                continue;\n              }\n              case \"list\": {\n                out += this.renderer.list(token);\n                continue;\n              }\n              case \"html\": {\n                out += this.renderer.html(token);\n                continue;\n              }\n              case \"paragraph\": {\n                out += this.renderer.paragraph(token);\n                continue;\n              }\n              case \"text\": {\n                let textToken = token;\n                let body = this.renderer.text(textToken);\n                while (i + 1 < tokens.length && tokens[i + 1].type === \"text\") {\n                  textToken = tokens[++i];\n                  body += \"\\n\" + this.renderer.text(textToken);\n                }\n                if (top) {\n                  out += this.renderer.paragraph({\n                    type: \"paragraph\",\n                    raw: body,\n                    text: body,\n                    tokens: [{ type: \"text\", raw: body, text: body }]\n                  });\n                } else {\n                  out += body;\n                }\n                continue;\n              }\n              default: {\n                const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                if (this.options.silent) {\n                  console.error(errMsg);\n                  return \"\";\n                } else {\n                  throw new Error(errMsg);\n                }\n              }\n            }\n          }\n          return out;\n        }\n        /**\n         * Parse Inline Tokens\n         */\n        parseInline(tokens, renderer) {\n          renderer = renderer || this.renderer;\n          let out = \"\";\n          for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n              const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n              if (ret !== false || ![\"escape\", \"html\", \"link\", \"image\", \"strong\", \"em\", \"codespan\", \"br\", \"del\", \"text\"].includes(anyToken.type)) {\n                out += ret || \"\";\n                continue;\n              }\n            }\n            const token = anyToken;\n            switch (token.type) {\n              case \"escape\": {\n                out += renderer.text(token);\n                break;\n              }\n              case \"html\": {\n                out += renderer.html(token);\n                break;\n              }\n              case \"link\": {\n                out += renderer.link(token);\n                break;\n              }\n              case \"image\": {\n                out += renderer.image(token);\n                break;\n              }\n              case \"strong\": {\n                out += renderer.strong(token);\n                break;\n              }\n              case \"em\": {\n                out += renderer.em(token);\n                break;\n              }\n              case \"codespan\": {\n                out += renderer.codespan(token);\n                break;\n              }\n              case \"br\": {\n                out += renderer.br(token);\n                break;\n              }\n              case \"del\": {\n                out += renderer.del(token);\n                break;\n              }\n              case \"text\": {\n                out += renderer.text(token);\n                break;\n              }\n              default: {\n                const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                if (this.options.silent) {\n                  console.error(errMsg);\n                  return \"\";\n                } else {\n                  throw new Error(errMsg);\n                }\n              }\n            }\n          }\n          return out;\n        }\n      };\n      _Hooks = class {\n        options;\n        constructor(options2) {\n          this.options = options2 || _defaults;\n        }\n        static passThroughHooks = /* @__PURE__ */ new Set([\n          \"preprocess\",\n          \"postprocess\",\n          \"processAllTokens\"\n        ]);\n        /**\n         * Process markdown before marked\n         */\n        preprocess(markdown) {\n          return markdown;\n        }\n        /**\n         * Process HTML after marked is finished\n         */\n        postprocess(html2) {\n          return html2;\n        }\n        /**\n         * Process all tokens before walk tokens\n         */\n        processAllTokens(tokens) {\n          return tokens;\n        }\n      };\n      Marked = class {\n        defaults = _getDefaults();\n        options = this.setOptions;\n        parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n        parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n        Parser = _Parser;\n        Renderer = _Renderer;\n        TextRenderer = _TextRenderer;\n        Lexer = _Lexer;\n        Tokenizer = _Tokenizer;\n        Hooks = _Hooks;\n        constructor(...args) {\n          this.use(...args);\n        }\n        /**\n         * Run callback for every token\n         */\n        walkTokens(tokens, callback) {\n          let values = [];\n          for (const token of tokens) {\n            values = values.concat(callback.call(this, token));\n            switch (token.type) {\n              case \"table\": {\n                const tableToken = token;\n                for (const cell of tableToken.header) {\n                  values = values.concat(this.walkTokens(cell.tokens, callback));\n                }\n                for (const row of tableToken.rows) {\n                  for (const cell of row) {\n                    values = values.concat(this.walkTokens(cell.tokens, callback));\n                  }\n                }\n                break;\n              }\n              case \"list\": {\n                const listToken = token;\n                values = values.concat(this.walkTokens(listToken.items, callback));\n                break;\n              }\n              default: {\n                const genericToken = token;\n                if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                  this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                    const tokens2 = genericToken[childTokens].flat(Infinity);\n                    values = values.concat(this.walkTokens(tokens2, callback));\n                  });\n                } else if (genericToken.tokens) {\n                  values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                }\n              }\n            }\n          }\n          return values;\n        }\n        use(...args) {\n          const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n          args.forEach((pack) => {\n            const opts = { ...pack };\n            opts.async = this.defaults.async || opts.async || false;\n            if (pack.extensions) {\n              pack.extensions.forEach((ext) => {\n                if (!ext.name) {\n                  throw new Error(\"extension name required\");\n                }\n                if (\"renderer\" in ext) {\n                  const prevRenderer = extensions.renderers[ext.name];\n                  if (prevRenderer) {\n                    extensions.renderers[ext.name] = function(...args2) {\n                      let ret = ext.renderer.apply(this, args2);\n                      if (ret === false) {\n                        ret = prevRenderer.apply(this, args2);\n                      }\n                      return ret;\n                    };\n                  } else {\n                    extensions.renderers[ext.name] = ext.renderer;\n                  }\n                }\n                if (\"tokenizer\" in ext) {\n                  if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") {\n                    throw new Error(\"extension level must be 'block' or 'inline'\");\n                  }\n                  const extLevel = extensions[ext.level];\n                  if (extLevel) {\n                    extLevel.unshift(ext.tokenizer);\n                  } else {\n                    extensions[ext.level] = [ext.tokenizer];\n                  }\n                  if (ext.start) {\n                    if (ext.level === \"block\") {\n                      if (extensions.startBlock) {\n                        extensions.startBlock.push(ext.start);\n                      } else {\n                        extensions.startBlock = [ext.start];\n                      }\n                    } else if (ext.level === \"inline\") {\n                      if (extensions.startInline) {\n                        extensions.startInline.push(ext.start);\n                      } else {\n                        extensions.startInline = [ext.start];\n                      }\n                    }\n                  }\n                }\n                if (\"childTokens\" in ext && ext.childTokens) {\n                  extensions.childTokens[ext.name] = ext.childTokens;\n                }\n              });\n              opts.extensions = extensions;\n            }\n            if (pack.renderer) {\n              const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n              for (const prop in pack.renderer) {\n                if (!(prop in renderer)) {\n                  throw new Error(`renderer '${prop}' does not exist`);\n                }\n                if ([\"options\", \"parser\"].includes(prop)) {\n                  continue;\n                }\n                const rendererProp = prop;\n                let rendererFunc = pack.renderer[rendererProp];\n                const prevRenderer = renderer[rendererProp];\n                renderer[rendererProp] = (...args2) => {\n                  if (!pack.useNewRenderer) {\n                    rendererFunc = this.#convertRendererFunction(rendererFunc, rendererProp, renderer);\n                  }\n                  let ret = rendererFunc.apply(renderer, args2);\n                  if (ret === false) {\n                    ret = prevRenderer.apply(renderer, args2);\n                  }\n                  return ret || \"\";\n                };\n              }\n              opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n              const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n              for (const prop in pack.tokenizer) {\n                if (!(prop in tokenizer)) {\n                  throw new Error(`tokenizer '${prop}' does not exist`);\n                }\n                if ([\"options\", \"rules\", \"lexer\"].includes(prop)) {\n                  continue;\n                }\n                const tokenizerProp = prop;\n                const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                const prevTokenizer = tokenizer[tokenizerProp];\n                tokenizer[tokenizerProp] = (...args2) => {\n                  let ret = tokenizerFunc.apply(tokenizer, args2);\n                  if (ret === false) {\n                    ret = prevTokenizer.apply(tokenizer, args2);\n                  }\n                  return ret;\n                };\n              }\n              opts.tokenizer = tokenizer;\n            }\n            if (pack.hooks) {\n              const hooks = this.defaults.hooks || new _Hooks();\n              for (const prop in pack.hooks) {\n                if (!(prop in hooks)) {\n                  throw new Error(`hook '${prop}' does not exist`);\n                }\n                if (prop === \"options\") {\n                  continue;\n                }\n                const hooksProp = prop;\n                const hooksFunc = pack.hooks[hooksProp];\n                const prevHook = hooks[hooksProp];\n                if (_Hooks.passThroughHooks.has(prop)) {\n                  hooks[hooksProp] = (arg) => {\n                    if (this.defaults.async) {\n                      return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {\n                        return prevHook.call(hooks, ret2);\n                      });\n                    }\n                    const ret = hooksFunc.call(hooks, arg);\n                    return prevHook.call(hooks, ret);\n                  };\n                } else {\n                  hooks[hooksProp] = (...args2) => {\n                    let ret = hooksFunc.apply(hooks, args2);\n                    if (ret === false) {\n                      ret = prevHook.apply(hooks, args2);\n                    }\n                    return ret;\n                  };\n                }\n              }\n              opts.hooks = hooks;\n            }\n            if (pack.walkTokens) {\n              const walkTokens2 = this.defaults.walkTokens;\n              const packWalktokens = pack.walkTokens;\n              opts.walkTokens = function(token) {\n                let values = [];\n                values.push(packWalktokens.call(this, token));\n                if (walkTokens2) {\n                  values = values.concat(walkTokens2.call(this, token));\n                }\n                return values;\n              };\n            }\n            this.defaults = { ...this.defaults, ...opts };\n          });\n          return this;\n        }\n        // TODO: Remove this in next major release\n        #convertRendererFunction(func3, prop, renderer) {\n          switch (prop) {\n            case \"heading\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                return func3.call(this, renderer.parser.parseInline(token.tokens), token.depth, unescape(renderer.parser.parseInline(token.tokens, renderer.parser.textRenderer)));\n              };\n            case \"code\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                return func3.call(this, token.text, token.lang, !!token.escaped);\n              };\n            case \"table\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                let header = \"\";\n                let cell = \"\";\n                for (let j = 0; j < token.header.length; j++) {\n                  cell += this.tablecell({\n                    text: token.header[j].text,\n                    tokens: token.header[j].tokens,\n                    header: true,\n                    align: token.align[j]\n                  });\n                }\n                header += this.tablerow({ text: cell });\n                let body = \"\";\n                for (let j = 0; j < token.rows.length; j++) {\n                  const row = token.rows[j];\n                  cell = \"\";\n                  for (let k = 0; k < row.length; k++) {\n                    cell += this.tablecell({\n                      text: row[k].text,\n                      tokens: row[k].tokens,\n                      header: false,\n                      align: token.align[k]\n                    });\n                  }\n                  body += this.tablerow({ text: cell });\n                }\n                return func3.call(this, header, body);\n              };\n            case \"blockquote\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                const body = this.parser.parse(token.tokens);\n                return func3.call(this, body);\n              };\n            case \"list\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                const ordered = token.ordered;\n                const start = token.start;\n                const loose = token.loose;\n                let body = \"\";\n                for (let j = 0; j < token.items.length; j++) {\n                  const item = token.items[j];\n                  const checked = item.checked;\n                  const task = item.task;\n                  let itemBody = \"\";\n                  if (item.task) {\n                    const checkbox = this.checkbox({ checked: !!checked });\n                    if (loose) {\n                      if (item.tokens.length > 0 && item.tokens[0].type === \"paragraph\") {\n                        item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") {\n                          item.tokens[0].tokens[0].text = checkbox + \" \" + item.tokens[0].tokens[0].text;\n                        }\n                      } else {\n                        item.tokens.unshift({\n                          type: \"text\",\n                          text: checkbox + \" \"\n                        });\n                      }\n                    } else {\n                      itemBody += checkbox + \" \";\n                    }\n                  }\n                  itemBody += this.parser.parse(item.tokens, loose);\n                  body += this.listitem({\n                    type: \"list_item\",\n                    raw: itemBody,\n                    text: itemBody,\n                    task,\n                    checked: !!checked,\n                    loose,\n                    tokens: item.tokens\n                  });\n                }\n                return func3.call(this, body, ordered, start);\n              };\n            case \"html\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                return func3.call(this, token.text, token.block);\n              };\n            case \"paragraph\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                return func3.call(this, this.parser.parseInline(token.tokens));\n              };\n            case \"escape\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                return func3.call(this, token.text);\n              };\n            case \"link\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                return func3.call(this, token.href, token.title, this.parser.parseInline(token.tokens));\n              };\n            case \"image\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                return func3.call(this, token.href, token.title, token.text);\n              };\n            case \"strong\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                return func3.call(this, this.parser.parseInline(token.tokens));\n              };\n            case \"em\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                return func3.call(this, this.parser.parseInline(token.tokens));\n              };\n            case \"codespan\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                return func3.call(this, token.text);\n              };\n            case \"del\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                return func3.call(this, this.parser.parseInline(token.tokens));\n              };\n            case \"text\":\n              return function(token) {\n                if (!token.type || token.type !== prop) {\n                  return func3.apply(this, arguments);\n                }\n                return func3.call(this, token.text);\n              };\n          }\n          return func3;\n        }\n        setOptions(opt) {\n          this.defaults = { ...this.defaults, ...opt };\n          return this;\n        }\n        lexer(src, options2) {\n          return _Lexer.lex(src, options2 ?? this.defaults);\n        }\n        parser(tokens, options2) {\n          return _Parser.parse(tokens, options2 ?? this.defaults);\n        }\n        #parseMarkdown(lexer2, parser2) {\n          return (src, options2) => {\n            const origOpt = { ...options2 };\n            const opt = { ...this.defaults, ...origOpt };\n            if (this.defaults.async === true && origOpt.async === false) {\n              if (!opt.silent) {\n                console.warn(\"marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.\");\n              }\n              opt.async = true;\n            }\n            const throwError = this.#onError(!!opt.silent, !!opt.async);\n            if (typeof src === \"undefined\" || src === null) {\n              return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n            }\n            if (typeof src !== \"string\") {\n              return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n            }\n            if (opt.hooks) {\n              opt.hooks.options = opt;\n            }\n            if (opt.async) {\n              return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);\n            }\n            try {\n              if (opt.hooks) {\n                src = opt.hooks.preprocess(src);\n              }\n              let tokens = lexer2(src, opt);\n              if (opt.hooks) {\n                tokens = opt.hooks.processAllTokens(tokens);\n              }\n              if (opt.walkTokens) {\n                this.walkTokens(tokens, opt.walkTokens);\n              }\n              let html2 = parser2(tokens, opt);\n              if (opt.hooks) {\n                html2 = opt.hooks.postprocess(html2);\n              }\n              return html2;\n            } catch (e) {\n              return throwError(e);\n            }\n          };\n        }\n        #onError(silent, async) {\n          return (e) => {\n            e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n            if (silent) {\n              const msg = \"<p>An error occurred:</p><pre>\" + escape$1(e.message + \"\", true) + \"</pre>\";\n              if (async) {\n                return Promise.resolve(msg);\n              }\n              return msg;\n            }\n            if (async) {\n              return Promise.reject(e);\n            }\n            throw e;\n          };\n        }\n      };\n      markedInstance = new Marked();\n      marked.options = marked.setOptions = function(options2) {\n        markedInstance.setOptions(options2);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n      };\n      marked.getDefaults = _getDefaults;\n      marked.defaults = _defaults;\n      marked.use = function(...args) {\n        markedInstance.use(...args);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n      };\n      marked.walkTokens = function(tokens, callback) {\n        return markedInstance.walkTokens(tokens, callback);\n      };\n      marked.parseInline = markedInstance.parseInline;\n      marked.Parser = _Parser;\n      marked.parser = _Parser.parse;\n      marked.Renderer = _Renderer;\n      marked.TextRenderer = _TextRenderer;\n      marked.Lexer = _Lexer;\n      marked.lexer = _Lexer.lex;\n      marked.Tokenizer = _Tokenizer;\n      marked.Hooks = _Hooks;\n      marked.parse = marked;\n      options = marked.options;\n      setOptions = marked.setOptions;\n      use = marked.use;\n      walkTokens = marked.walkTokens;\n      parseInline = marked.parseInline;\n      parser = _Parser.parse;\n      lexer = _Lexer.lex;\n    }\n  });\n\n  // src/client/routes/data/record/markdown.svelte\n  function create_fragment9(ctx) {\n    let label;\n    let textarea;\n    let t0;\n    let small;\n    let icon_1;\n    let t1;\n    let t2;\n    let t3;\n    let code;\n    let updating_output;\n    let current;\n    icon_1 = new Icon_default({\n      props: { icon: (\n        /*icon*/\n        ctx[0]\n      ) },\n      $$inline: true\n    });\n    function code_output_binding(value) {\n      ctx[5](value);\n    }\n    let code_props = {\n      invalid: (\n        /*required*/\n        ctx[2] && !/*output*/\n        ctx[4]\n      ),\n      input: (\n        /*value*/\n        ctx[3]\n      )\n    };\n    if (\n      /*output*/\n      ctx[4] !== void 0\n    ) {\n      code_props.output = /*output*/\n      ctx[4];\n    }\n    code = new Code_default({ props: code_props, $$inline: true });\n    binding_callbacks.push(() => bind(code, \"output\", code_output_binding));\n    const block2 = {\n      c: function create() {\n        label = element(\"label\");\n        textarea = element(\"textarea\");\n        t0 = space();\n        small = element(\"small\");\n        create_component(icon_1.$$.fragment);\n        t1 = space();\n        t2 = text(\n          /*name*/\n          ctx[1]\n        );\n        t3 = space();\n        create_component(code.$$.fragment);\n        attr_dev(textarea, \"class\", \"hidden\");\n        attr_dev(\n          textarea,\n          \"name\",\n          /*name*/\n          ctx[1]\n        );\n        textarea.required = /*required*/\n        ctx[2];\n        textarea.value = /*output*/\n        ctx[4];\n        add_location(textarea, file9, 17, 4, 340);\n        add_location(small, file9, 18, 4, 405);\n        add_location(label, file9, 16, 0, 328);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, label, anchor);\n        append_dev(label, textarea);\n        append_dev(label, t0);\n        append_dev(label, small);\n        mount_component(icon_1, small, null);\n        append_dev(small, t1);\n        append_dev(small, t2);\n        append_dev(label, t3);\n        mount_component(code, label, null);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (!current || dirty & /*name*/\n        2) {\n          attr_dev(\n            textarea,\n            \"name\",\n            /*name*/\n            ctx2[1]\n          );\n        }\n        if (!current || dirty & /*required*/\n        4) {\n          prop_dev(\n            textarea,\n            \"required\",\n            /*required*/\n            ctx2[2]\n          );\n        }\n        if (!current || dirty & /*output*/\n        16) {\n          prop_dev(\n            textarea,\n            \"value\",\n            /*output*/\n            ctx2[4]\n          );\n        }\n        const icon_1_changes = {};\n        if (dirty & /*icon*/\n        1) icon_1_changes.icon = /*icon*/\n        ctx2[0];\n        icon_1.$set(icon_1_changes);\n        if (!current || dirty & /*name*/\n        2) set_data_dev(\n          t2,\n          /*name*/\n          ctx2[1]\n        );\n        const code_changes = {};\n        if (dirty & /*required, output*/\n        20) code_changes.invalid = /*required*/\n        ctx2[2] && !/*output*/\n        ctx2[4];\n        if (dirty & /*value*/\n        8) code_changes.input = /*value*/\n        ctx2[3];\n        if (!updating_output && dirty & /*output*/\n        16) {\n          updating_output = true;\n          code_changes.output = /*output*/\n          ctx2[4];\n          add_flush_callback(() => updating_output = false);\n        }\n        code.$set(code_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon_1.$$.fragment, local);\n        transition_in(code.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon_1.$$.fragment, local);\n        transition_out(code.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(label);\n        }\n        destroy_component(icon_1);\n        destroy_component(code);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment9.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance9($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Markdown\", slots, []);\n    let { icon } = $$props;\n    let { name: name2 } = $$props;\n    let { required } = $$props;\n    let { value } = $$props;\n    let output = value;\n    $$self.$$.on_mount.push(function() {\n      if (icon === void 0 && !(\"icon\" in $$props || $$self.$$.bound[$$self.$$.props[\"icon\"]])) {\n        console.warn(\"<Markdown> was created without expected prop 'icon'\");\n      }\n      if (name2 === void 0 && !(\"name\" in $$props || $$self.$$.bound[$$self.$$.props[\"name\"]])) {\n        console.warn(\"<Markdown> was created without expected prop 'name'\");\n      }\n      if (required === void 0 && !(\"required\" in $$props || $$self.$$.bound[$$self.$$.props[\"required\"]])) {\n        console.warn(\"<Markdown> was created without expected prop 'required'\");\n      }\n      if (value === void 0 && !(\"value\" in $$props || $$self.$$.bound[$$self.$$.props[\"value\"]])) {\n        console.warn(\"<Markdown> was created without expected prop 'value'\");\n      }\n    });\n    const writable_props = [\"icon\", \"name\", \"required\", \"value\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Markdown> was created with unknown prop '${key}'`);\n    });\n    function code_output_binding(value2) {\n      output = value2;\n      $$invalidate(4, output);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(0, icon = $$props2.icon);\n      if (\"name\" in $$props2) $$invalidate(1, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(2, required = $$props2.required);\n      if (\"value\" in $$props2) $$invalidate(3, value = $$props2.value);\n    };\n    $$self.$capture_state = () => ({\n      marked,\n      Code: Code_default,\n      Icon: Icon_default,\n      icon,\n      name: name2,\n      required,\n      value,\n      output\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(0, icon = $$props2.icon);\n      if (\"name\" in $$props2) $$invalidate(1, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(2, required = $$props2.required);\n      if (\"value\" in $$props2) $$invalidate(3, value = $$props2.value);\n      if (\"output\" in $$props2) $$invalidate(4, output = $$props2.output);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [icon, name2, required, value, output, code_output_binding];\n  }\n  var file9, Markdown, markdown_default;\n  var init_markdown = __esm({\n    \"src/client/routes/data/record/markdown.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Icon();\n      init_Code();\n      init_marked_esm();\n      file9 = \"src/client/routes/data/record/markdown.svelte\";\n      Markdown = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance9, create_fragment9, safe_not_equal, { icon: 0, name: 1, required: 2, value: 3 });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Markdown\",\n            options: options2,\n            id: create_fragment9.name\n          });\n        }\n        get icon() {\n          throw new Error(\"<Markdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set icon(value) {\n          throw new Error(\"<Markdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get name() {\n          throw new Error(\"<Markdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set name(value) {\n          throw new Error(\"<Markdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get required() {\n          throw new Error(\"<Markdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set required(value) {\n          throw new Error(\"<Markdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get value() {\n          throw new Error(\"<Markdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set value(value) {\n          throw new Error(\"<Markdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      markdown_default = Markdown;\n    }\n  });\n\n  // src/client/routes/data/record/json.svelte\n  function create_fragment10(ctx) {\n    let label;\n    let textarea;\n    let t0;\n    let small;\n    let icon_1;\n    let t1;\n    let t2;\n    let t3;\n    let code;\n    let updating_output;\n    let current;\n    icon_1 = new Icon_default({\n      props: { icon: (\n        /*icon*/\n        ctx[0]\n      ) },\n      $$inline: true\n    });\n    function code_output_binding(value) {\n      ctx[5](value);\n    }\n    let code_props = {\n      invalid: (\n        /*required*/\n        ctx[2] && !/*output*/\n        ctx[4]\n      ),\n      input: (\n        /*value*/\n        ctx[3]\n      )\n    };\n    if (\n      /*output*/\n      ctx[4] !== void 0\n    ) {\n      code_props.output = /*output*/\n      ctx[4];\n    }\n    code = new Code_default({ props: code_props, $$inline: true });\n    binding_callbacks.push(() => bind(code, \"output\", code_output_binding));\n    const block2 = {\n      c: function create() {\n        label = element(\"label\");\n        textarea = element(\"textarea\");\n        t0 = space();\n        small = element(\"small\");\n        create_component(icon_1.$$.fragment);\n        t1 = space();\n        t2 = text(\n          /*name*/\n          ctx[1]\n        );\n        t3 = space();\n        create_component(code.$$.fragment);\n        attr_dev(textarea, \"class\", \"hidden\");\n        attr_dev(\n          textarea,\n          \"name\",\n          /*name*/\n          ctx[1]\n        );\n        textarea.required = /*required*/\n        ctx[2];\n        textarea.value = /*output*/\n        ctx[4];\n        add_location(textarea, file10, 16, 4, 307);\n        add_location(small, file10, 17, 4, 372);\n        add_location(label, file10, 15, 0, 295);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, label, anchor);\n        append_dev(label, textarea);\n        append_dev(label, t0);\n        append_dev(label, small);\n        mount_component(icon_1, small, null);\n        append_dev(small, t1);\n        append_dev(small, t2);\n        append_dev(label, t3);\n        mount_component(code, label, null);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (!current || dirty & /*name*/\n        2) {\n          attr_dev(\n            textarea,\n            \"name\",\n            /*name*/\n            ctx2[1]\n          );\n        }\n        if (!current || dirty & /*required*/\n        4) {\n          prop_dev(\n            textarea,\n            \"required\",\n            /*required*/\n            ctx2[2]\n          );\n        }\n        if (!current || dirty & /*output*/\n        16) {\n          prop_dev(\n            textarea,\n            \"value\",\n            /*output*/\n            ctx2[4]\n          );\n        }\n        const icon_1_changes = {};\n        if (dirty & /*icon*/\n        1) icon_1_changes.icon = /*icon*/\n        ctx2[0];\n        icon_1.$set(icon_1_changes);\n        if (!current || dirty & /*name*/\n        2) set_data_dev(\n          t2,\n          /*name*/\n          ctx2[1]\n        );\n        const code_changes = {};\n        if (dirty & /*required, output*/\n        20) code_changes.invalid = /*required*/\n        ctx2[2] && !/*output*/\n        ctx2[4];\n        if (dirty & /*value*/\n        8) code_changes.input = /*value*/\n        ctx2[3];\n        if (!updating_output && dirty & /*output*/\n        16) {\n          updating_output = true;\n          code_changes.output = /*output*/\n          ctx2[4];\n          add_flush_callback(() => updating_output = false);\n        }\n        code.$set(code_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon_1.$$.fragment, local);\n        transition_in(code.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon_1.$$.fragment, local);\n        transition_out(code.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(label);\n        }\n        destroy_component(icon_1);\n        destroy_component(code);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment10.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance10($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Json\", slots, []);\n    let { icon } = $$props;\n    let { name: name2 } = $$props;\n    let { required } = $$props;\n    let { value } = $$props;\n    let output = value;\n    $$self.$$.on_mount.push(function() {\n      if (icon === void 0 && !(\"icon\" in $$props || $$self.$$.bound[$$self.$$.props[\"icon\"]])) {\n        console.warn(\"<Json> was created without expected prop 'icon'\");\n      }\n      if (name2 === void 0 && !(\"name\" in $$props || $$self.$$.bound[$$self.$$.props[\"name\"]])) {\n        console.warn(\"<Json> was created without expected prop 'name'\");\n      }\n      if (required === void 0 && !(\"required\" in $$props || $$self.$$.bound[$$self.$$.props[\"required\"]])) {\n        console.warn(\"<Json> was created without expected prop 'required'\");\n      }\n      if (value === void 0 && !(\"value\" in $$props || $$self.$$.bound[$$self.$$.props[\"value\"]])) {\n        console.warn(\"<Json> was created without expected prop 'value'\");\n      }\n    });\n    const writable_props = [\"icon\", \"name\", \"required\", \"value\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Json> was created with unknown prop '${key}'`);\n    });\n    function code_output_binding(value2) {\n      output = value2;\n      $$invalidate(4, output);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(0, icon = $$props2.icon);\n      if (\"name\" in $$props2) $$invalidate(1, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(2, required = $$props2.required);\n      if (\"value\" in $$props2) $$invalidate(3, value = $$props2.value);\n    };\n    $$self.$capture_state = () => ({\n      Code: Code_default,\n      Icon: Icon_default,\n      icon,\n      name: name2,\n      required,\n      value,\n      output\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(0, icon = $$props2.icon);\n      if (\"name\" in $$props2) $$invalidate(1, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(2, required = $$props2.required);\n      if (\"value\" in $$props2) $$invalidate(3, value = $$props2.value);\n      if (\"output\" in $$props2) $$invalidate(4, output = $$props2.output);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [icon, name2, required, value, output, code_output_binding];\n  }\n  var file10, Json, json_default;\n  var init_json = __esm({\n    \"src/client/routes/data/record/json.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Icon();\n      init_Code();\n      file10 = \"src/client/routes/data/record/json.svelte\";\n      Json = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance10, create_fragment10, safe_not_equal, { icon: 0, name: 1, required: 2, value: 3 });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Json\",\n            options: options2,\n            id: create_fragment10.name\n          });\n        }\n        get icon() {\n          throw new Error(\"<Json>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set icon(value) {\n          throw new Error(\"<Json>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get name() {\n          throw new Error(\"<Json>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set name(value) {\n          throw new Error(\"<Json>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get required() {\n          throw new Error(\"<Json>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set required(value) {\n          throw new Error(\"<Json>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get value() {\n          throw new Error(\"<Json>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set value(value) {\n          throw new Error(\"<Json>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      json_default = Json;\n    }\n  });\n\n  // fakecss:/Users/valexr/Desktop/Jsonik/src/client/components/LightBox/Thumb.esbuild-svelte-fake-css\n  var init_Thumb = __esm({\n    \"fakecss:/Users/valexr/Desktop/Jsonik/src/client/components/LightBox/Thumb.esbuild-svelte-fake-css\"() {\n    }\n  });\n\n  // src/client/components/LightBox/Thumb.svelte\n  function create_fragment11(ctx) {\n    let a;\n    let t;\n    let a_href_value;\n    const block2 = {\n      c: function create() {\n        a = element(\"a\");\n        t = text(\n          /*filename*/\n          ctx[0]\n        );\n        attr_dev(a, \"role\", \"button\");\n        attr_dev(a, \"class\", \"outline box svelte-kjjj8o\");\n        attr_dev(a, \"href\", a_href_value = \"#file-\" + encodeURI(\n          /*filename*/\n          ctx[0]\n        ));\n        set_style(a, \"background-image\", \"url(/api/files/\" + /*$route*/\n        ctx[1].collection + \"/\" + /*filename*/\n        ctx[0] + \")\");\n        attr_dev(a, \"draggable\", \"false\");\n        attr_dev(\n          a,\n          \"title\",\n          /*filename*/\n          ctx[0]\n        );\n        add_location(a, file11, 9, 0, 192);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, a, anchor);\n        append_dev(a, t);\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (dirty & /*filename*/\n        1) set_data_dev(\n          t,\n          /*filename*/\n          ctx2[0]\n        );\n        if (dirty & /*filename*/\n        1 && a_href_value !== (a_href_value = \"#file-\" + encodeURI(\n          /*filename*/\n          ctx2[0]\n        ))) {\n          attr_dev(a, \"href\", a_href_value);\n        }\n        if (dirty & /*$route, filename*/\n        3) {\n          set_style(a, \"background-image\", \"url(/api/files/\" + /*$route*/\n          ctx2[1].collection + \"/\" + /*filename*/\n          ctx2[0] + \")\");\n        }\n        if (dirty & /*filename*/\n        1) {\n          attr_dev(\n            a,\n            \"title\",\n            /*filename*/\n            ctx2[0]\n          );\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(a);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment11.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance11($$self, $$props, $$invalidate) {\n    let $route;\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Thumb\", slots, []);\n    let { filename } = $$props;\n    const route = paramable(\"/:folder/:collection\");\n    validate_store(route, \"route\");\n    component_subscribe($$self, route, (value) => $$invalidate(1, $route = value));\n    $$self.$$.on_mount.push(function() {\n      if (filename === void 0 && !(\"filename\" in $$props || $$self.$$.bound[$$self.$$.props[\"filename\"]])) {\n        console.warn(\"<Thumb> was created without expected prop 'filename'\");\n      }\n    });\n    const writable_props = [\"filename\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Thumb> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"filename\" in $$props2) $$invalidate(0, filename = $$props2.filename);\n    };\n    $$self.$capture_state = () => ({ paramable, filename, route, $route });\n    $$self.$inject_state = ($$props2) => {\n      if (\"filename\" in $$props2) $$invalidate(0, filename = $$props2.filename);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [filename, $route, route];\n  }\n  var file11, Thumb, Thumb_default;\n  var init_Thumb2 = __esm({\n    \"src/client/components/LightBox/Thumb.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_src();\n      init_Thumb();\n      file11 = \"src/client/components/LightBox/Thumb.svelte\";\n      Thumb = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance11, create_fragment11, safe_not_equal, { filename: 0 });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Thumb\",\n            options: options2,\n            id: create_fragment11.name\n          });\n        }\n        get filename() {\n          throw new Error(\"<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set filename(value) {\n          throw new Error(\"<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      Thumb_default = Thumb;\n    }\n  });\n\n  // src/client/components/Await.svelte\n  function create_if_block4(ctx) {\n    let current_block_type_index;\n    let if_block;\n    let if_block_anchor;\n    let current;\n    const if_block_creators = [create_if_block_13, create_if_block_2, create_else_block];\n    const if_blocks = [];\n    function select_block_type(ctx2, dirty) {\n      if (\n        /*promise*/\n        ctx2[0]\n      ) return 0;\n      if (\n        /*result*/\n        ctx2[1]\n      ) return 1;\n      return 2;\n    }\n    current_block_type_index = select_block_type(ctx, -1);\n    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n    const block2 = {\n      c: function create() {\n        if_block.c();\n        if_block_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        if_blocks[current_block_type_index].m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        let previous_block_index = current_block_type_index;\n        current_block_type_index = select_block_type(ctx2, dirty);\n        if (current_block_type_index === previous_block_index) {\n          if_blocks[current_block_type_index].p(ctx2, dirty);\n        } else {\n          group_outros();\n          transition_out(if_blocks[previous_block_index], 1, 1, () => {\n            if_blocks[previous_block_index] = null;\n          });\n          check_outros();\n          if_block = if_blocks[current_block_type_index];\n          if (!if_block) {\n            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);\n            if_block.c();\n          } else {\n            if_block.p(ctx2, dirty);\n          }\n          transition_in(if_block, 1);\n          if_block.m(if_block_anchor.parentNode, if_block_anchor);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if_blocks[current_block_type_index].d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block4.name,\n      type: \"if\",\n      source: \"(34:0) {#if !hidden}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_else_block(ctx) {\n    let current;\n    const catch_slot_template = (\n      /*#slots*/\n      ctx[8].catch\n    );\n    const catch_slot = create_slot(\n      catch_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[7],\n      get_catch_slot_context\n    );\n    const catch_slot_or_fallback = catch_slot || fallback_block_1(ctx);\n    const block2 = {\n      c: function create() {\n        if (catch_slot_or_fallback) catch_slot_or_fallback.c();\n      },\n      m: function mount(target, anchor) {\n        if (catch_slot_or_fallback) {\n          catch_slot_or_fallback.m(target, anchor);\n        }\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (catch_slot) {\n          if (catch_slot.p && (!current || dirty & /*$$scope, error*/\n          132)) {\n            update_slot_base(\n              catch_slot,\n              catch_slot_template,\n              ctx2,\n              /*$$scope*/\n              ctx2[7],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx2[7]\n              ) : get_slot_changes(\n                catch_slot_template,\n                /*$$scope*/\n                ctx2[7],\n                dirty,\n                get_catch_slot_changes\n              ),\n              get_catch_slot_context\n            );\n          }\n        } else {\n          if (catch_slot_or_fallback && catch_slot_or_fallback.p && (!current || dirty & /*error*/\n          4)) {\n            catch_slot_or_fallback.p(ctx2, !current ? -1 : dirty);\n          }\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(catch_slot_or_fallback, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(catch_slot_or_fallback, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (catch_slot_or_fallback) catch_slot_or_fallback.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_else_block.name,\n      type: \"else\",\n      source: \"(41:4) {:else}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_2(ctx) {\n    let current;\n    const default_slot_template = (\n      /*#slots*/\n      ctx[8].default\n    );\n    const default_slot = create_slot(\n      default_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[7],\n      get_default_slot_context\n    );\n    const block2 = {\n      c: function create() {\n        if (default_slot) default_slot.c();\n      },\n      m: function mount(target, anchor) {\n        if (default_slot) {\n          default_slot.m(target, anchor);\n        }\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (default_slot) {\n          if (default_slot.p && (!current || dirty & /*$$scope, result*/\n          130)) {\n            update_slot_base(\n              default_slot,\n              default_slot_template,\n              ctx2,\n              /*$$scope*/\n              ctx2[7],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx2[7]\n              ) : get_slot_changes(\n                default_slot_template,\n                /*$$scope*/\n                ctx2[7],\n                dirty,\n                get_default_slot_changes\n              ),\n              get_default_slot_context\n            );\n          }\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(default_slot, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(default_slot, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (default_slot) default_slot.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_2.name,\n      type: \"if\",\n      source: \"(39:21) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_13(ctx) {\n    let current;\n    const await_slot_template = (\n      /*#slots*/\n      ctx[8].await\n    );\n    const await_slot = create_slot(\n      await_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[7],\n      get_await_slot_context\n    );\n    const await_slot_or_fallback = await_slot || fallback_block3(ctx);\n    const block2 = {\n      c: function create() {\n        if (await_slot_or_fallback) await_slot_or_fallback.c();\n      },\n      m: function mount(target, anchor) {\n        if (await_slot_or_fallback) {\n          await_slot_or_fallback.m(target, anchor);\n        }\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (await_slot) {\n          if (await_slot.p && (!current || dirty & /*$$scope*/\n          128)) {\n            update_slot_base(\n              await_slot,\n              await_slot_template,\n              ctx2,\n              /*$$scope*/\n              ctx2[7],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx2[7]\n              ) : get_slot_changes(\n                await_slot_template,\n                /*$$scope*/\n                ctx2[7],\n                dirty,\n                get_await_slot_changes\n              ),\n              get_await_slot_context\n            );\n          }\n        } else {\n          if (await_slot_or_fallback && await_slot_or_fallback.p && (!current || dirty & /*sm*/\n          16)) {\n            await_slot_or_fallback.p(ctx2, !current ? -1 : dirty);\n          }\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(await_slot_or_fallback, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(await_slot_or_fallback, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (await_slot_or_fallback) await_slot_or_fallback.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_13.name,\n      type: \"if\",\n      source: \"(35:4) {#if promise}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_3(ctx) {\n    let samp;\n    let t;\n    const block2 = {\n      c: function create() {\n        samp = element(\"samp\");\n        t = text(\n          /*error*/\n          ctx[2]\n        );\n        attr_dev(samp, \"class\", \"error\");\n        add_location(samp, file12, 48, 16, 1176);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, samp, anchor);\n        append_dev(samp, t);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*error*/\n        4) set_data_dev(\n          t,\n          /*error*/\n          ctx2[2]\n        );\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(samp);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_3.name,\n      type: \"if\",\n      source: \"(43:12) {#if error}\",\n      ctx\n    });\n    return block2;\n  }\n  function fallback_block_1(ctx) {\n    let if_block_anchor;\n    let if_block = (\n      /*error*/\n      ctx[2] && create_if_block_3(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        if (if_block) if_block.c();\n        if_block_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        if (if_block) if_block.m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*error*/\n          ctx2[2]\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n          } else {\n            if_block = create_if_block_3(ctx2);\n            if_block.c();\n            if_block.m(if_block_anchor.parentNode, if_block_anchor);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if (if_block) if_block.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: fallback_block_1.name,\n      type: \"fallback\",\n      source: \"(42:35)              \",\n      ctx\n    });\n    return block2;\n  }\n  function fallback_block3(ctx) {\n    let p;\n    const block2 = {\n      c: function create() {\n        p = element(\"p\");\n        attr_dev(p, \"aria-busy\", \"true\");\n        toggle_class(p, \"lg\", !/*sm*/\n        ctx[4]);\n        add_location(p, file12, 41, 12, 986);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, p, anchor);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*sm*/\n        16) {\n          toggle_class(p, \"lg\", !/*sm*/\n          ctx2[4]);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(p);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: fallback_block3.name,\n      type: \"fallback\",\n      source: \"(36:27)              \",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment12(ctx) {\n    let if_block_anchor;\n    let current;\n    let if_block = !/*hidden*/\n    ctx[3] && create_if_block4(ctx);\n    const block2 = {\n      c: function create() {\n        if (if_block) if_block.c();\n        if_block_anchor = empty();\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        if (if_block) if_block.m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (!/*hidden*/\n        ctx2[3]) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty & /*hidden*/\n            8) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block4(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(if_block_anchor.parentNode, if_block_anchor);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if (if_block) if_block.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment12.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance12($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Await\", slots, [\"await\", \"default\", \"catch\"]);\n    let { promise: promise2 } = $$props;\n    let { result = null } = $$props;\n    let { error = \"\" } = $$props;\n    let { success = \"\" } = $$props;\n    let { notify = false } = $$props;\n    let { hidden = false } = $$props;\n    let { sm = false } = $$props;\n    const dispatch2 = createEventDispatcher();\n    $$self.$$.on_mount.push(function() {\n      if (promise2 === void 0 && !(\"promise\" in $$props || $$self.$$.bound[$$self.$$.props[\"promise\"]])) {\n        console.warn(\"<Await> was created without expected prop 'promise'\");\n      }\n    });\n    const writable_props = [\"promise\", \"result\", \"error\", \"success\", \"notify\", \"hidden\", \"sm\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Await> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"promise\" in $$props2) $$invalidate(0, promise2 = $$props2.promise);\n      if (\"result\" in $$props2) $$invalidate(1, result = $$props2.result);\n      if (\"error\" in $$props2) $$invalidate(2, error = $$props2.error);\n      if (\"success\" in $$props2) $$invalidate(5, success = $$props2.success);\n      if (\"notify\" in $$props2) $$invalidate(6, notify = $$props2.notify);\n      if (\"hidden\" in $$props2) $$invalidate(3, hidden = $$props2.hidden);\n      if (\"sm\" in $$props2) $$invalidate(4, sm = $$props2.sm);\n      if (\"$$scope\" in $$props2) $$invalidate(7, $$scope = $$props2.$$scope);\n    };\n    $$self.$capture_state = () => ({\n      createEventDispatcher,\n      toast,\n      promise: promise2,\n      result,\n      error,\n      success,\n      notify,\n      hidden,\n      sm,\n      dispatch: dispatch2\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"promise\" in $$props2) $$invalidate(0, promise2 = $$props2.promise);\n      if (\"result\" in $$props2) $$invalidate(1, result = $$props2.result);\n      if (\"error\" in $$props2) $$invalidate(2, error = $$props2.error);\n      if (\"success\" in $$props2) $$invalidate(5, success = $$props2.success);\n      if (\"notify\" in $$props2) $$invalidate(6, notify = $$props2.notify);\n      if (\"hidden\" in $$props2) $$invalidate(3, hidden = $$props2.hidden);\n      if (\"sm\" in $$props2) $$invalidate(4, sm = $$props2.sm);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    $$self.$$.update = () => {\n      if ($$self.$$.dirty & /*promise, result, success, notify, error*/\n      103) {\n        $: if (promise2) {\n          dispatch2(\"await\", promise2);\n          promise2.then((res) => {\n            $$invalidate(0, promise2 = null);\n            $$invalidate(1, result = res ?? true);\n            dispatch2(\"success\", result);\n            if (success && notify) toast.success({ msg: success, timeout: 3e3 });\n          }).catch((e) => {\n            $$invalidate(0, promise2 = null);\n            $$invalidate(2, error = error || e.reason || e.message || e);\n            dispatch2(\"error\", error);\n            if (notify) toast.error({ msg: error, timeout: 3e3 });\n          });\n        }\n      }\n    };\n    return [promise2, result, error, hidden, sm, success, notify, $$scope, slots];\n  }\n  var file12, get_catch_slot_changes, get_catch_slot_context, get_default_slot_changes, get_default_slot_context, get_await_slot_changes, get_await_slot_context, Await, Await_default;\n  var init_Await = __esm({\n    \"src/client/components/Await.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Toaster();\n      init_runtime();\n      file12 = \"src/client/components/Await.svelte\";\n      get_catch_slot_changes = (dirty) => ({ error: dirty & /*error*/\n      4 });\n      get_catch_slot_context = (ctx) => ({ error: (\n        /*error*/\n        ctx[2]\n      ) });\n      get_default_slot_changes = (dirty) => ({ result: dirty & /*result*/\n      2 });\n      get_default_slot_context = (ctx) => ({ result: (\n        /*result*/\n        ctx[1]\n      ) });\n      get_await_slot_changes = (dirty) => ({});\n      get_await_slot_context = (ctx) => ({});\n      Await = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance12, create_fragment12, safe_not_equal, {\n            promise: 0,\n            result: 1,\n            error: 2,\n            success: 5,\n            notify: 6,\n            hidden: 3,\n            sm: 4\n          });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Await\",\n            options: options2,\n            id: create_fragment12.name\n          });\n        }\n        get promise() {\n          throw new Error(\"<Await>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set promise(value) {\n          throw new Error(\"<Await>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get result() {\n          throw new Error(\"<Await>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set result(value) {\n          throw new Error(\"<Await>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get error() {\n          throw new Error(\"<Await>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set error(value) {\n          throw new Error(\"<Await>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get success() {\n          throw new Error(\"<Await>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set success(value) {\n          throw new Error(\"<Await>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get notify() {\n          throw new Error(\"<Await>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set notify(value) {\n          throw new Error(\"<Await>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get hidden() {\n          throw new Error(\"<Await>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set hidden(value) {\n          throw new Error(\"<Await>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get sm() {\n          throw new Error(\"<Await>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set sm(value) {\n          throw new Error(\"<Await>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      Await_default = Await;\n    }\n  });\n\n  // fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/data/record/file.esbuild-svelte-fake-css\n  var init_file = __esm({\n    \"fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/data/record/file.esbuild-svelte-fake-css\"() {\n    }\n  });\n\n  // src/client/routes/data/record/file.svelte\n  function get_each_context2(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[12] = list2[i];\n    return child_ctx;\n  }\n  function create_if_block5(ctx) {\n    let ul;\n    let each_blocks = [];\n    let each_1_lookup = /* @__PURE__ */ new Map();\n    let current;\n    let each_value = ensure_array_like_dev(\n      /*value*/\n      ctx[0]\n    );\n    const get_key = (ctx2) => (\n      /*file*/\n      ctx2[12]\n    );\n    validate_each_keys(ctx, each_value, get_each_context2, get_key);\n    for (let i = 0; i < each_value.length; i += 1) {\n      let child_ctx = get_each_context2(ctx, each_value, i);\n      let key = get_key(child_ctx);\n      each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));\n    }\n    const block2 = {\n      c: function create() {\n        ul = element(\"ul\");\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        attr_dev(ul, \"role\", \"listbox\");\n        attr_dev(ul, \"class\", \"svelte-i8zzmi\");\n        add_location(ul, file_1, 92, 8, 2576);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, ul, anchor);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(ul, null);\n          }\n        }\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*value, deleteFile*/\n        257) {\n          each_value = ensure_array_like_dev(\n            /*value*/\n            ctx2[0]\n          );\n          group_outros();\n          validate_each_keys(ctx2, each_value, get_each_context2, get_key);\n          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block2, null, get_each_context2);\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        for (let i = 0; i < each_value.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        current = true;\n      },\n      o: function outro(local) {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(ul);\n        }\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].d();\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block5.name,\n      type: \"if\",\n      source: \"(78:4) {#if value.length}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block2(key_1, ctx) {\n    let li;\n    let lbthumb;\n    let t0;\n    let span;\n    let t1_value = (\n      /*file*/\n      ctx[12].name + \"\"\n    );\n    let t1;\n    let t2;\n    let button;\n    let icon_1;\n    let button_id_value;\n    let t3;\n    let current;\n    let mounted;\n    let dispose;\n    lbthumb = new Thumb_default({\n      props: { filename: (\n        /*file*/\n        ctx[12].name\n      ) },\n      $$inline: true\n    });\n    icon_1 = new Icon_default({ props: { icon: \"trash\" }, $$inline: true });\n    const block2 = {\n      key: key_1,\n      first: null,\n      c: function create() {\n        li = element(\"li\");\n        create_component(lbthumb.$$.fragment);\n        t0 = space();\n        span = element(\"span\");\n        t1 = text(t1_value);\n        t2 = space();\n        button = element(\"button\");\n        create_component(icon_1.$$.fragment);\n        t3 = space();\n        attr_dev(span, \"class\", \"scroll-x svelte-i8zzmi\");\n        add_location(span, file_1, 96, 20, 2765);\n        attr_dev(button, \"id\", button_id_value = /*file*/\n        ctx[12].name);\n        attr_dev(button, \"type\", \"button\");\n        attr_dev(button, \"class\", \"box link text-error\");\n        add_location(button, file_1, 97, 20, 2827);\n        attr_dev(li, \"class\", \"cols col-fit align-center svelte-i8zzmi\");\n        add_location(li, file_1, 94, 16, 2653);\n        this.first = li;\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, li, anchor);\n        mount_component(lbthumb, li, null);\n        append_dev(li, t0);\n        append_dev(li, span);\n        append_dev(span, t1);\n        append_dev(li, t2);\n        append_dev(li, button);\n        mount_component(icon_1, button, null);\n        append_dev(li, t3);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            button,\n            \"click\",\n            /*deleteFile*/\n            ctx[8],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(new_ctx, dirty) {\n        ctx = new_ctx;\n        const lbthumb_changes = {};\n        if (dirty & /*value*/\n        1) lbthumb_changes.filename = /*file*/\n        ctx[12].name;\n        lbthumb.$set(lbthumb_changes);\n        if ((!current || dirty & /*value*/\n        1) && t1_value !== (t1_value = /*file*/\n        ctx[12].name + \"\")) set_data_dev(t1, t1_value);\n        if (!current || dirty & /*value*/\n        1 && button_id_value !== (button_id_value = /*file*/\n        ctx[12].name)) {\n          attr_dev(button, \"id\", button_id_value);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(lbthumb.$$.fragment, local);\n        transition_in(icon_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(lbthumb.$$.fragment, local);\n        transition_out(icon_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(li);\n        }\n        destroy_component(lbthumb);\n        destroy_component(icon_1);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block2.name,\n      type: \"each\",\n      source: \"(80:12) {#each value as file (file)}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment13(ctx) {\n    let label1;\n    let small;\n    let icon0;\n    let t0;\n    let t1;\n    let t2;\n    let t3;\n    let label0;\n    let icon1;\n    let t4;\n    let input0;\n    let input0_accept_value;\n    let input0_multiple_value;\n    let input0_disabled_value;\n    let label0_aria_disabled_value;\n    let t5;\n    let input1;\n    let input1_value_value;\n    let label1_data_note_value;\n    let current;\n    let mounted;\n    let dispose;\n    icon0 = new Icon_default({\n      props: { icon: (\n        /*icon*/\n        ctx[1]\n      ) },\n      $$inline: true\n    });\n    let if_block = (\n      /*value*/\n      ctx[0].length && create_if_block5(ctx)\n    );\n    icon1 = new Icon_default({\n      props: { icon: \"file-plus\" },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        label1 = element(\"label\");\n        small = element(\"small\");\n        create_component(icon0.$$.fragment);\n        t0 = space();\n        t1 = text(\n          /*name*/\n          ctx[2]\n        );\n        t2 = space();\n        if (if_block) if_block.c();\n        t3 = space();\n        label0 = element(\"label\");\n        create_component(icon1.$$.fragment);\n        t4 = text(\" Add files\\n        \");\n        input0 = element(\"input\");\n        t5 = space();\n        input1 = element(\"input\");\n        add_location(small, file_1, 90, 4, 2507);\n        attr_dev(\n          input0,\n          \"name\",\n          /*name*/\n          ctx[2]\n        );\n        input0.required = /*required*/\n        ctx[3];\n        attr_dev(input0, \"type\", \"file\");\n        attr_dev(input0, \"accept\", input0_accept_value = /*opts*/\n        ctx[4].accept);\n        input0.multiple = input0_multiple_value = /*opts*/\n        ctx[4].maxFiles > 1;\n        input0.disabled = input0_disabled_value = /*value*/\n        ctx[0].length >= /*opts*/\n        ctx[4].maxFiles;\n        attr_dev(input0, \"class\", \"svelte-i8zzmi\");\n        add_location(input0, file_1, 113, 8, 3377);\n        attr_dev(label0, \"role\", \"button\");\n        attr_dev(label0, \"aria-disabled\", label0_aria_disabled_value = /*value*/\n        ctx[0].length >= /*opts*/\n        ctx[4].maxFiles);\n        attr_dev(label0, \"class\", \"svelte-i8zzmi\");\n        add_location(label0, file_1, 111, 4, 3257);\n        attr_dev(input1, \"type\", \"hidden\");\n        attr_dev(\n          input1,\n          \"name\",\n          /*name*/\n          ctx[2]\n        );\n        input1.value = input1_value_value = JSON.stringify(\n          /*value*/\n          ctx[0]\n        );\n        add_location(input1, file_1, 124, 4, 3676);\n        attr_dev(label1, \"data-note\", label1_data_note_value = /*dataNote*/\n        ctx[6]());\n        attr_dev(label1, \"for\", \"\");\n        add_location(label1, file_1, 89, 0, 2465);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, label1, anchor);\n        append_dev(label1, small);\n        mount_component(icon0, small, null);\n        append_dev(small, t0);\n        append_dev(small, t1);\n        append_dev(label1, t2);\n        if (if_block) if_block.m(label1, null);\n        append_dev(label1, t3);\n        append_dev(label1, label0);\n        mount_component(icon1, label0, null);\n        append_dev(label0, t4);\n        append_dev(label0, input0);\n        append_dev(label1, t5);\n        append_dev(label1, input1);\n        current = true;\n        if (!mounted) {\n          dispose = [\n            listen_dev(\n              input0,\n              \"input\",\n              /*checkLimits*/\n              ctx[5],\n              false,\n              false,\n              false,\n              false\n            ),\n            listen_dev(\n              input0,\n              \"change\",\n              /*uploadFiles*/\n              ctx[7],\n              false,\n              false,\n              false,\n              false\n            )\n          ];\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, [dirty]) {\n        const icon0_changes = {};\n        if (dirty & /*icon*/\n        2) icon0_changes.icon = /*icon*/\n        ctx2[1];\n        icon0.$set(icon0_changes);\n        if (!current || dirty & /*name*/\n        4) set_data_dev(\n          t1,\n          /*name*/\n          ctx2[2]\n        );\n        if (\n          /*value*/\n          ctx2[0].length\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty & /*value*/\n            1) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block5(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(label1, t3);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n        if (!current || dirty & /*name*/\n        4) {\n          attr_dev(\n            input0,\n            \"name\",\n            /*name*/\n            ctx2[2]\n          );\n        }\n        if (!current || dirty & /*required*/\n        8) {\n          prop_dev(\n            input0,\n            \"required\",\n            /*required*/\n            ctx2[3]\n          );\n        }\n        if (!current || dirty & /*opts*/\n        16 && input0_accept_value !== (input0_accept_value = /*opts*/\n        ctx2[4].accept)) {\n          attr_dev(input0, \"accept\", input0_accept_value);\n        }\n        if (!current || dirty & /*opts*/\n        16 && input0_multiple_value !== (input0_multiple_value = /*opts*/\n        ctx2[4].maxFiles > 1)) {\n          prop_dev(input0, \"multiple\", input0_multiple_value);\n        }\n        if (!current || dirty & /*value, opts*/\n        17 && input0_disabled_value !== (input0_disabled_value = /*value*/\n        ctx2[0].length >= /*opts*/\n        ctx2[4].maxFiles)) {\n          prop_dev(input0, \"disabled\", input0_disabled_value);\n        }\n        if (!current || dirty & /*value, opts*/\n        17 && label0_aria_disabled_value !== (label0_aria_disabled_value = /*value*/\n        ctx2[0].length >= /*opts*/\n        ctx2[4].maxFiles)) {\n          attr_dev(label0, \"aria-disabled\", label0_aria_disabled_value);\n        }\n        if (!current || dirty & /*name*/\n        4) {\n          attr_dev(\n            input1,\n            \"name\",\n            /*name*/\n            ctx2[2]\n          );\n        }\n        if (!current || dirty & /*value*/\n        1 && input1_value_value !== (input1_value_value = JSON.stringify(\n          /*value*/\n          ctx2[0]\n        ))) {\n          prop_dev(input1, \"value\", input1_value_value);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon0.$$.fragment, local);\n        transition_in(if_block);\n        transition_in(icon1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon0.$$.fragment, local);\n        transition_out(if_block);\n        transition_out(icon1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(label1);\n        }\n        destroy_component(icon0);\n        if (if_block) if_block.d();\n        destroy_component(icon1);\n        mounted = false;\n        run_all(dispose);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment13.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function fileSize(size) {\n    if (size < 1024) {\n      return `${size} bytes`;\n    } else if (size >= 1024 && size < 1048576) {\n      return `${(size / 1024).toFixed(1)} KB`;\n    } else if (size >= 1048576) {\n      return `${(size / 1048576).toFixed(1)} MB`;\n    }\n  }\n  function instance13($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"File\", slots, []);\n    let { icon } = $$props;\n    let { name: name2 } = $$props;\n    let { required } = $$props;\n    let { opts } = $$props;\n    let { value = [] } = $$props;\n    let { collection } = $$props;\n    let { recordID } = $$props;\n    function checkLimits(e) {\n      const input = e.currentTarget;\n      const { maxFiles, maxSize } = opts;\n      const toastError = (msg) => toast.error({ msg, timeout: 3e3, pos: \"bottom_right\" });\n      if (value.length > maxFiles) {\n        const msg = `Only ${opts.maxFiles} files can be selected`;\n        toastError(msg);\n        input.value = \"\";\n      } else if (maxSize && input.files) {\n        for (const file48 of input.files) {\n          if (file48.size > maxSize) {\n            const msg = `${file48.name} larger then ${fileSize(maxSize)}`;\n            toastError(msg);\n            input.value = \"\";\n          }\n        }\n      }\n    }\n    function dataNote() {\n      const accept2 = opts?.accept ? `Accept: ${opts?.accept}` : \"\";\n      const maxFiles = opts?.maxFiles ? `maxFiles: ${opts?.maxFiles}` : \"\";\n      const maxSize = opts?.maxSize ? `maxSize: ${fileSize(opts?.maxSize)}` : \"\";\n      return `${accept2} ${maxFiles} ${maxSize}`;\n    }\n    let fileList = [];\n    async function uploadFiles(e) {\n      const input = e.currentTarget;\n      if (input.files) {\n        for (const file48 of input.files) {\n          if (file48.name) {\n            const { name: fname, type, size } = file48;\n            const filename = `${recordID}-${name2}-${encodeURI(fname)}`;\n            value.push({ name: filename, type, size, collection });\n            fileList.push(files.add(collection, file48, filename));\n          }\n        }\n        await Promise.all(fileList);\n        $$invalidate(0, value);\n      }\n    }\n    async function deleteFile(e) {\n      const { id: filename } = e.currentTarget;\n      $$invalidate(0, value = value.filter(({ name: name3 }) => name3.localeCompare(filename)));\n      await files.delete(collection, [filename]);\n    }\n    $$self.$$.on_mount.push(function() {\n      if (icon === void 0 && !(\"icon\" in $$props || $$self.$$.bound[$$self.$$.props[\"icon\"]])) {\n        console.warn(\"<File> was created without expected prop 'icon'\");\n      }\n      if (name2 === void 0 && !(\"name\" in $$props || $$self.$$.bound[$$self.$$.props[\"name\"]])) {\n        console.warn(\"<File> was created without expected prop 'name'\");\n      }\n      if (required === void 0 && !(\"required\" in $$props || $$self.$$.bound[$$self.$$.props[\"required\"]])) {\n        console.warn(\"<File> was created without expected prop 'required'\");\n      }\n      if (opts === void 0 && !(\"opts\" in $$props || $$self.$$.bound[$$self.$$.props[\"opts\"]])) {\n        console.warn(\"<File> was created without expected prop 'opts'\");\n      }\n      if (collection === void 0 && !(\"collection\" in $$props || $$self.$$.bound[$$self.$$.props[\"collection\"]])) {\n        console.warn(\"<File> was created without expected prop 'collection'\");\n      }\n      if (recordID === void 0 && !(\"recordID\" in $$props || $$self.$$.bound[$$self.$$.props[\"recordID\"]])) {\n        console.warn(\"<File> was created without expected prop 'recordID'\");\n      }\n    });\n    const writable_props = [\"icon\", \"name\", \"required\", \"opts\", \"value\", \"collection\", \"recordID\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<File> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(1, icon = $$props2.icon);\n      if (\"name\" in $$props2) $$invalidate(2, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(3, required = $$props2.required);\n      if (\"opts\" in $$props2) $$invalidate(4, opts = $$props2.opts);\n      if (\"value\" in $$props2) $$invalidate(0, value = $$props2.value);\n      if (\"collection\" in $$props2) $$invalidate(9, collection = $$props2.collection);\n      if (\"recordID\" in $$props2) $$invalidate(10, recordID = $$props2.recordID);\n    };\n    $$self.$capture_state = () => ({\n      files,\n      toast,\n      Icon: Icon_default,\n      Await: Await_default,\n      LBThumb: Thumb_default,\n      icon,\n      name: name2,\n      required,\n      opts,\n      value,\n      collection,\n      recordID,\n      fileSize,\n      checkLimits,\n      dataNote,\n      fileList,\n      uploadFiles,\n      deleteFile\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(1, icon = $$props2.icon);\n      if (\"name\" in $$props2) $$invalidate(2, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(3, required = $$props2.required);\n      if (\"opts\" in $$props2) $$invalidate(4, opts = $$props2.opts);\n      if (\"value\" in $$props2) $$invalidate(0, value = $$props2.value);\n      if (\"collection\" in $$props2) $$invalidate(9, collection = $$props2.collection);\n      if (\"recordID\" in $$props2) $$invalidate(10, recordID = $$props2.recordID);\n      if (\"fileList\" in $$props2) fileList = $$props2.fileList;\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      value,\n      icon,\n      name2,\n      required,\n      opts,\n      checkLimits,\n      dataNote,\n      uploadFiles,\n      deleteFile,\n      collection,\n      recordID\n    ];\n  }\n  var file_1, File, file_default;\n  var init_file2 = __esm({\n    \"src/client/routes/data/record/file.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Thumb2();\n      init_Await();\n      init_Icon();\n      init_toast();\n      init_files();\n      init_file();\n      file_1 = \"src/client/routes/data/record/file.svelte\";\n      File = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance13, create_fragment13, safe_not_equal, {\n            icon: 1,\n            name: 2,\n            required: 3,\n            opts: 4,\n            value: 0,\n            collection: 9,\n            recordID: 10\n          });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"File\",\n            options: options2,\n            id: create_fragment13.name\n          });\n        }\n        get icon() {\n          throw new Error(\"<File>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set icon(value) {\n          throw new Error(\"<File>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get name() {\n          throw new Error(\"<File>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set name(value) {\n          throw new Error(\"<File>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get required() {\n          throw new Error(\"<File>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set required(value) {\n          throw new Error(\"<File>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get opts() {\n          throw new Error(\"<File>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set opts(value) {\n          throw new Error(\"<File>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get value() {\n          throw new Error(\"<File>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set value(value) {\n          throw new Error(\"<File>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get collection() {\n          throw new Error(\"<File>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set collection(value) {\n          throw new Error(\"<File>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get recordID() {\n          throw new Error(\"<File>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set recordID(value) {\n          throw new Error(\"<File>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      file_default = File;\n    }\n  });\n\n  // src/client/routes/data/record/select.svelte\n  function get_each_context_12(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[7] = list2[i];\n    return child_ctx;\n  }\n  function get_each_context3(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[7] = list2[i];\n    return child_ctx;\n  }\n  function create_else_block2(ctx) {\n    let select;\n    let select_size_value;\n    let mounted;\n    let dispose;\n    let each_value_1 = ensure_array_like_dev(\n      /*opts*/\n      ctx[4]?.options?.split(\",\")\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value_1.length; i += 1) {\n      each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));\n    }\n    const block2 = {\n      c: function create() {\n        select = element(\"select\");\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        attr_dev(\n          select,\n          \"name\",\n          /*name*/\n          ctx[2]\n        );\n        attr_dev(select, \"size\", select_size_value = /*opts*/\n        ctx[4].size);\n        select.required = /*required*/\n        ctx[3];\n        if (\n          /*value*/\n          ctx[0] === void 0\n        ) add_render_callback(() => (\n          /*select_change_handler_1*/\n          ctx[6].call(select)\n        ));\n        add_location(select, file13, 21, 8, 523);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, select, anchor);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(select, null);\n          }\n        }\n        select_option(\n          select,\n          /*value*/\n          ctx[0],\n          true\n        );\n        if (!mounted) {\n          dispose = listen_dev(\n            select,\n            \"change\",\n            /*select_change_handler_1*/\n            ctx[6]\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*opts*/\n        16) {\n          each_value_1 = ensure_array_like_dev(\n            /*opts*/\n            ctx2[4]?.options?.split(\",\")\n          );\n          let i;\n          for (i = 0; i < each_value_1.length; i += 1) {\n            const child_ctx = get_each_context_12(ctx2, each_value_1, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n            } else {\n              each_blocks[i] = create_each_block_12(child_ctx);\n              each_blocks[i].c();\n              each_blocks[i].m(select, null);\n            }\n          }\n          for (; i < each_blocks.length; i += 1) {\n            each_blocks[i].d(1);\n          }\n          each_blocks.length = each_value_1.length;\n        }\n        if (dirty & /*name*/\n        4) {\n          attr_dev(\n            select,\n            \"name\",\n            /*name*/\n            ctx2[2]\n          );\n        }\n        if (dirty & /*opts*/\n        16 && select_size_value !== (select_size_value = /*opts*/\n        ctx2[4].size)) {\n          attr_dev(select, \"size\", select_size_value);\n        }\n        if (dirty & /*required*/\n        8) {\n          prop_dev(\n            select,\n            \"required\",\n            /*required*/\n            ctx2[3]\n          );\n        }\n        if (dirty & /*value, opts*/\n        17) {\n          select_option(\n            select,\n            /*value*/\n            ctx2[0]\n          );\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(select);\n        }\n        destroy_each(each_blocks, detaching);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_else_block2.name,\n      type: \"else\",\n      source: \"(19:4) {:else}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block6(ctx) {\n    let select;\n    let select_size_value;\n    let mounted;\n    let dispose;\n    let each_value = ensure_array_like_dev(\n      /*opts*/\n      ctx[4]?.options?.split(\",\")\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));\n    }\n    const block2 = {\n      c: function create() {\n        select = element(\"select\");\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        attr_dev(\n          select,\n          \"name\",\n          /*name*/\n          ctx[2]\n        );\n        select.multiple = true;\n        attr_dev(select, \"size\", select_size_value = /*opts*/\n        ctx[4].size);\n        select.required = /*required*/\n        ctx[3];\n        if (\n          /*value*/\n          ctx[0] === void 0\n        ) add_render_callback(() => (\n          /*select_change_handler*/\n          ctx[5].call(select)\n        ));\n        add_location(select, file13, 15, 8, 303);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, select, anchor);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(select, null);\n          }\n        }\n        select_options(\n          select,\n          /*value*/\n          ctx[0]\n        );\n        if (!mounted) {\n          dispose = listen_dev(\n            select,\n            \"change\",\n            /*select_change_handler*/\n            ctx[5]\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*opts*/\n        16) {\n          each_value = ensure_array_like_dev(\n            /*opts*/\n            ctx2[4]?.options?.split(\",\")\n          );\n          let i;\n          for (i = 0; i < each_value.length; i += 1) {\n            const child_ctx = get_each_context3(ctx2, each_value, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n            } else {\n              each_blocks[i] = create_each_block3(child_ctx);\n              each_blocks[i].c();\n              each_blocks[i].m(select, null);\n            }\n          }\n          for (; i < each_blocks.length; i += 1) {\n            each_blocks[i].d(1);\n          }\n          each_blocks.length = each_value.length;\n        }\n        if (dirty & /*name*/\n        4) {\n          attr_dev(\n            select,\n            \"name\",\n            /*name*/\n            ctx2[2]\n          );\n        }\n        if (dirty & /*opts*/\n        16 && select_size_value !== (select_size_value = /*opts*/\n        ctx2[4].size)) {\n          attr_dev(select, \"size\", select_size_value);\n        }\n        if (dirty & /*required*/\n        8) {\n          prop_dev(\n            select,\n            \"required\",\n            /*required*/\n            ctx2[3]\n          );\n        }\n        if (dirty & /*value, opts*/\n        17) {\n          select_options(\n            select,\n            /*value*/\n            ctx2[0]\n          );\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(select);\n        }\n        destroy_each(each_blocks, detaching);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block6.name,\n      type: \"if\",\n      source: \"(13:4) {#if opts.size > 1}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block_12(ctx) {\n    let option_1;\n    let t_value = (\n      /*option*/\n      ctx[7] + \"\"\n    );\n    let t;\n    let option_1_value_value;\n    const block2 = {\n      c: function create() {\n        option_1 = element(\"option\");\n        t = text(t_value);\n        option_1.__value = option_1_value_value = /*option*/\n        ctx[7];\n        set_input_value(option_1, option_1.__value);\n        add_location(option_1, file13, 23, 16, 650);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, option_1, anchor);\n        append_dev(option_1, t);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*opts*/\n        16 && t_value !== (t_value = /*option*/\n        ctx2[7] + \"\")) set_data_dev(t, t_value);\n        if (dirty & /*opts*/\n        16 && option_1_value_value !== (option_1_value_value = /*option*/\n        ctx2[7])) {\n          prop_dev(option_1, \"__value\", option_1_value_value);\n          set_input_value(option_1, option_1.__value);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(option_1);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block_12.name,\n      type: \"each\",\n      source: '(21:12) {#each opts?.options?.split(\\\\\",\\\\\") as option}',\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block3(ctx) {\n    let option_1;\n    let t_value = (\n      /*option*/\n      ctx[7] + \"\"\n    );\n    let t;\n    let option_1_value_value;\n    const block2 = {\n      c: function create() {\n        option_1 = element(\"option\");\n        t = text(t_value);\n        option_1.__value = option_1_value_value = /*option*/\n        ctx[7];\n        set_input_value(option_1, option_1.__value);\n        add_location(option_1, file13, 17, 16, 439);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, option_1, anchor);\n        append_dev(option_1, t);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*opts*/\n        16 && t_value !== (t_value = /*option*/\n        ctx2[7] + \"\")) set_data_dev(t, t_value);\n        if (dirty & /*opts*/\n        16 && option_1_value_value !== (option_1_value_value = /*option*/\n        ctx2[7])) {\n          prop_dev(option_1, \"__value\", option_1_value_value);\n          set_input_value(option_1, option_1.__value);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(option_1);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block3.name,\n      type: \"each\",\n      source: '(15:12) {#each opts?.options?.split(\\\\\",\\\\\") as option}',\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment14(ctx) {\n    let label;\n    let small;\n    let icon_1;\n    let t0;\n    let t1;\n    let t2;\n    let t3;\n    let input;\n    let input_value_value;\n    let current;\n    icon_1 = new Icon_default({\n      props: { icon: (\n        /*icon*/\n        ctx[1]\n      ) },\n      $$inline: true\n    });\n    function select_block_type(ctx2, dirty) {\n      if (\n        /*opts*/\n        ctx2[4].size > 1\n      ) return create_if_block6;\n      return create_else_block2;\n    }\n    let current_block_type = select_block_type(ctx, -1);\n    let if_block = current_block_type(ctx);\n    const block2 = {\n      c: function create() {\n        label = element(\"label\");\n        small = element(\"small\");\n        create_component(icon_1.$$.fragment);\n        t0 = space();\n        t1 = text(\n          /*name*/\n          ctx[2]\n        );\n        t2 = space();\n        if_block.c();\n        t3 = space();\n        input = element(\"input\");\n        add_location(small, file13, 13, 4, 233);\n        attr_dev(input, \"type\", \"hidden\");\n        attr_dev(\n          input,\n          \"name\",\n          /*name*/\n          ctx[2]\n        );\n        input.value = input_value_value = /*value*/\n        ctx[0] || \"\";\n        add_location(input, file13, 27, 4, 728);\n        add_location(label, file13, 12, 0, 221);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, label, anchor);\n        append_dev(label, small);\n        mount_component(icon_1, small, null);\n        append_dev(small, t0);\n        append_dev(small, t1);\n        append_dev(label, t2);\n        if_block.m(label, null);\n        append_dev(label, t3);\n        append_dev(label, input);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const icon_1_changes = {};\n        if (dirty & /*icon*/\n        2) icon_1_changes.icon = /*icon*/\n        ctx2[1];\n        icon_1.$set(icon_1_changes);\n        if (!current || dirty & /*name*/\n        4) set_data_dev(\n          t1,\n          /*name*/\n          ctx2[2]\n        );\n        if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {\n          if_block.p(ctx2, dirty);\n        } else {\n          if_block.d(1);\n          if_block = current_block_type(ctx2);\n          if (if_block) {\n            if_block.c();\n            if_block.m(label, t3);\n          }\n        }\n        if (!current || dirty & /*name*/\n        4) {\n          attr_dev(\n            input,\n            \"name\",\n            /*name*/\n            ctx2[2]\n          );\n        }\n        if (!current || dirty & /*value, opts*/\n        17 && input_value_value !== (input_value_value = /*value*/\n        ctx2[0] || \"\")) {\n          prop_dev(input, \"value\", input_value_value);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(label);\n        }\n        destroy_component(icon_1);\n        if_block.d();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment14.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance14($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Select\", slots, []);\n    let { icon } = $$props;\n    let { name: name2 } = $$props;\n    let { required } = $$props;\n    let { opts } = $$props;\n    let { value = \"\" } = $$props;\n    $$self.$$.on_mount.push(function() {\n      if (icon === void 0 && !(\"icon\" in $$props || $$self.$$.bound[$$self.$$.props[\"icon\"]])) {\n        console.warn(\"<Select> was created without expected prop 'icon'\");\n      }\n      if (name2 === void 0 && !(\"name\" in $$props || $$self.$$.bound[$$self.$$.props[\"name\"]])) {\n        console.warn(\"<Select> was created without expected prop 'name'\");\n      }\n      if (required === void 0 && !(\"required\" in $$props || $$self.$$.bound[$$self.$$.props[\"required\"]])) {\n        console.warn(\"<Select> was created without expected prop 'required'\");\n      }\n      if (opts === void 0 && !(\"opts\" in $$props || $$self.$$.bound[$$self.$$.props[\"opts\"]])) {\n        console.warn(\"<Select> was created without expected prop 'opts'\");\n      }\n    });\n    const writable_props = [\"icon\", \"name\", \"required\", \"opts\", \"value\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Select> was created with unknown prop '${key}'`);\n    });\n    function select_change_handler() {\n      value = select_multiple_value(this);\n      $$invalidate(0, value);\n      $$invalidate(4, opts);\n    }\n    function select_change_handler_1() {\n      value = select_value(this);\n      $$invalidate(0, value);\n      $$invalidate(4, opts);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(1, icon = $$props2.icon);\n      if (\"name\" in $$props2) $$invalidate(2, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(3, required = $$props2.required);\n      if (\"opts\" in $$props2) $$invalidate(4, opts = $$props2.opts);\n      if (\"value\" in $$props2) $$invalidate(0, value = $$props2.value);\n    };\n    $$self.$capture_state = () => ({ Icon: Icon_default, icon, name: name2, required, opts, value });\n    $$self.$inject_state = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(1, icon = $$props2.icon);\n      if (\"name\" in $$props2) $$invalidate(2, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(3, required = $$props2.required);\n      if (\"opts\" in $$props2) $$invalidate(4, opts = $$props2.opts);\n      if (\"value\" in $$props2) $$invalidate(0, value = $$props2.value);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      value,\n      icon,\n      name2,\n      required,\n      opts,\n      select_change_handler,\n      select_change_handler_1\n    ];\n  }\n  var file13, Select, select_default;\n  var init_select = __esm({\n    \"src/client/routes/data/record/select.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Icon();\n      file13 = \"src/client/routes/data/record/select.svelte\";\n      Select = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance14, create_fragment14, safe_not_equal, {\n            icon: 1,\n            name: 2,\n            required: 3,\n            opts: 4,\n            value: 0\n          });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Select\",\n            options: options2,\n            id: create_fragment14.name\n          });\n        }\n        get icon() {\n          throw new Error(\"<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set icon(value) {\n          throw new Error(\"<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get name() {\n          throw new Error(\"<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set name(value) {\n          throw new Error(\"<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get required() {\n          throw new Error(\"<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set required(value) {\n          throw new Error(\"<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get opts() {\n          throw new Error(\"<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set opts(value) {\n          throw new Error(\"<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get value() {\n          throw new Error(\"<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set value(value) {\n          throw new Error(\"<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      select_default = Select;\n    }\n  });\n\n  // src/client/routes/data/record/textarea.svelte\n  function create_fragment15(ctx) {\n    let label;\n    let small;\n    let icon_1;\n    let t0;\n    let t1;\n    let t2;\n    let textarea;\n    let expand_action;\n    let current;\n    let mounted;\n    let dispose;\n    icon_1 = new Icon_default({\n      props: { icon: (\n        /*icon*/\n        ctx[0]\n      ) },\n      $$inline: true\n    });\n    let textarea_levels = [\n      { value: (\n        /*value*/\n        ctx[4]\n      ) },\n      { name: (\n        /*name*/\n        ctx[1]\n      ) },\n      { required: (\n        /*required*/\n        ctx[2]\n      ) },\n      /*opts*/\n      ctx[3]\n    ];\n    let textarea_data = {};\n    for (let i = 0; i < textarea_levels.length; i += 1) {\n      textarea_data = assign(textarea_data, textarea_levels[i]);\n    }\n    const block2 = {\n      c: function create() {\n        label = element(\"label\");\n        small = element(\"small\");\n        create_component(icon_1.$$.fragment);\n        t0 = space();\n        t1 = text(\n          /*name*/\n          ctx[1]\n        );\n        t2 = space();\n        textarea = element(\"textarea\");\n        add_location(small, file14, 14, 4, 276);\n        set_attributes(textarea, textarea_data);\n        add_location(textarea, file14, 15, 4, 318);\n        add_location(label, file14, 13, 0, 264);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, label, anchor);\n        append_dev(label, small);\n        mount_component(icon_1, small, null);\n        append_dev(small, t0);\n        append_dev(small, t1);\n        append_dev(label, t2);\n        append_dev(label, textarea);\n        if (textarea.autofocus) textarea.focus();\n        current = true;\n        if (!mounted) {\n          dispose = action_destroyer(expand_action = expand.call(null, textarea));\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, [dirty]) {\n        const icon_1_changes = {};\n        if (dirty & /*icon*/\n        1) icon_1_changes.icon = /*icon*/\n        ctx2[0];\n        icon_1.$set(icon_1_changes);\n        if (!current || dirty & /*name*/\n        2) set_data_dev(\n          t1,\n          /*name*/\n          ctx2[1]\n        );\n        set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [\n          (!current || dirty & /*value*/\n          16) && { value: (\n            /*value*/\n            ctx2[4]\n          ) },\n          (!current || dirty & /*name*/\n          2) && { name: (\n            /*name*/\n            ctx2[1]\n          ) },\n          (!current || dirty & /*required*/\n          4) && { required: (\n            /*required*/\n            ctx2[2]\n          ) },\n          dirty & /*opts*/\n          8 && /*opts*/\n          ctx2[3]\n        ]));\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(label);\n        }\n        destroy_component(icon_1);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment15.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance15($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Textarea\", slots, []);\n    let { icon } = $$props;\n    let { name: name2 } = $$props;\n    let { required } = $$props;\n    let { opts } = $$props;\n    let { value } = $$props;\n    $$self.$$.on_mount.push(function() {\n      if (icon === void 0 && !(\"icon\" in $$props || $$self.$$.bound[$$self.$$.props[\"icon\"]])) {\n        console.warn(\"<Textarea> was created without expected prop 'icon'\");\n      }\n      if (name2 === void 0 && !(\"name\" in $$props || $$self.$$.bound[$$self.$$.props[\"name\"]])) {\n        console.warn(\"<Textarea> was created without expected prop 'name'\");\n      }\n      if (required === void 0 && !(\"required\" in $$props || $$self.$$.bound[$$self.$$.props[\"required\"]])) {\n        console.warn(\"<Textarea> was created without expected prop 'required'\");\n      }\n      if (opts === void 0 && !(\"opts\" in $$props || $$self.$$.bound[$$self.$$.props[\"opts\"]])) {\n        console.warn(\"<Textarea> was created without expected prop 'opts'\");\n      }\n      if (value === void 0 && !(\"value\" in $$props || $$self.$$.bound[$$self.$$.props[\"value\"]])) {\n        console.warn(\"<Textarea> was created without expected prop 'value'\");\n      }\n    });\n    const writable_props = [\"icon\", \"name\", \"required\", \"opts\", \"value\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Textarea> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(0, icon = $$props2.icon);\n      if (\"name\" in $$props2) $$invalidate(1, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(2, required = $$props2.required);\n      if (\"opts\" in $$props2) $$invalidate(3, opts = $$props2.opts);\n      if (\"value\" in $$props2) $$invalidate(4, value = $$props2.value);\n    };\n    $$self.$capture_state = () => ({\n      expand,\n      Icon: Icon_default,\n      icon,\n      name: name2,\n      required,\n      opts,\n      value\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(0, icon = $$props2.icon);\n      if (\"name\" in $$props2) $$invalidate(1, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(2, required = $$props2.required);\n      if (\"opts\" in $$props2) $$invalidate(3, opts = $$props2.opts);\n      if (\"value\" in $$props2) $$invalidate(4, value = $$props2.value);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [icon, name2, required, opts, value];\n  }\n  var file14, Textarea, textarea_default;\n  var init_textarea = __esm({\n    \"src/client/routes/data/record/textarea.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Icon();\n      init_actions();\n      file14 = \"src/client/routes/data/record/textarea.svelte\";\n      Textarea = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance15, create_fragment15, safe_not_equal, {\n            icon: 0,\n            name: 1,\n            required: 2,\n            opts: 3,\n            value: 4\n          });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Textarea\",\n            options: options2,\n            id: create_fragment15.name\n          });\n        }\n        get icon() {\n          throw new Error(\"<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set icon(value) {\n          throw new Error(\"<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get name() {\n          throw new Error(\"<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set name(value) {\n          throw new Error(\"<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get required() {\n          throw new Error(\"<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set required(value) {\n          throw new Error(\"<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get opts() {\n          throw new Error(\"<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set opts(value) {\n          throw new Error(\"<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get value() {\n          throw new Error(\"<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set value(value) {\n          throw new Error(\"<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      textarea_default = Textarea;\n    }\n  });\n\n  // src/client/routes/data/record/checkbox.svelte\n  function create_fragment16(ctx) {\n    let label;\n    let input0;\n    let t0;\n    let small;\n    let t1;\n    let t2;\n    let input1;\n    let input1_value_value;\n    let mounted;\n    let dispose;\n    const block2 = {\n      c: function create() {\n        label = element(\"label\");\n        input0 = element(\"input\");\n        t0 = text(\"\\xA0\\n    \");\n        small = element(\"small\");\n        t1 = text(\n          /*name*/\n          ctx[1]\n        );\n        t2 = space();\n        input1 = element(\"input\");\n        attr_dev(input0, \"type\", \"checkbox\");\n        attr_dev(input0, \"role\", \"switch\");\n        attr_dev(\n          input0,\n          \"name\",\n          /*name*/\n          ctx[1]\n        );\n        input0.required = /*required*/\n        ctx[2];\n        add_location(input0, file15, 7, 4, 97);\n        add_location(small, file15, 14, 4, 230);\n        attr_dev(input1, \"type\", \"hidden\");\n        attr_dev(\n          input1,\n          \"name\",\n          /*name*/\n          ctx[1]\n        );\n        input1.value = input1_value_value = /*value*/\n        ctx[0] || \"\";\n        add_location(input1, file15, 15, 4, 256);\n        add_location(label, file15, 6, 0, 85);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, label, anchor);\n        append_dev(label, input0);\n        input0.checked = /*value*/\n        ctx[0];\n        append_dev(label, t0);\n        append_dev(label, small);\n        append_dev(small, t1);\n        append_dev(label, t2);\n        append_dev(label, input1);\n        if (!mounted) {\n          dispose = listen_dev(\n            input0,\n            \"change\",\n            /*input0_change_handler*/\n            ctx[3]\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (dirty & /*name*/\n        2) {\n          attr_dev(\n            input0,\n            \"name\",\n            /*name*/\n            ctx2[1]\n          );\n        }\n        if (dirty & /*required*/\n        4) {\n          prop_dev(\n            input0,\n            \"required\",\n            /*required*/\n            ctx2[2]\n          );\n        }\n        if (dirty & /*value*/\n        1) {\n          input0.checked = /*value*/\n          ctx2[0];\n        }\n        if (dirty & /*name*/\n        2) set_data_dev(\n          t1,\n          /*name*/\n          ctx2[1]\n        );\n        if (dirty & /*name*/\n        2) {\n          attr_dev(\n            input1,\n            \"name\",\n            /*name*/\n            ctx2[1]\n          );\n        }\n        if (dirty & /*value*/\n        1 && input1_value_value !== (input1_value_value = /*value*/\n        ctx2[0] || \"\")) {\n          prop_dev(input1, \"value\", input1_value_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(label);\n        }\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment16.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance16($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Checkbox\", slots, []);\n    let { name: name2 } = $$props;\n    let { required } = $$props;\n    let { value } = $$props;\n    $$self.$$.on_mount.push(function() {\n      if (name2 === void 0 && !(\"name\" in $$props || $$self.$$.bound[$$self.$$.props[\"name\"]])) {\n        console.warn(\"<Checkbox> was created without expected prop 'name'\");\n      }\n      if (required === void 0 && !(\"required\" in $$props || $$self.$$.bound[$$self.$$.props[\"required\"]])) {\n        console.warn(\"<Checkbox> was created without expected prop 'required'\");\n      }\n      if (value === void 0 && !(\"value\" in $$props || $$self.$$.bound[$$self.$$.props[\"value\"]])) {\n        console.warn(\"<Checkbox> was created without expected prop 'value'\");\n      }\n    });\n    const writable_props = [\"name\", \"required\", \"value\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Checkbox> was created with unknown prop '${key}'`);\n    });\n    function input0_change_handler() {\n      value = this.checked;\n      $$invalidate(0, value);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"name\" in $$props2) $$invalidate(1, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(2, required = $$props2.required);\n      if (\"value\" in $$props2) $$invalidate(0, value = $$props2.value);\n    };\n    $$self.$capture_state = () => ({ name: name2, required, value });\n    $$self.$inject_state = ($$props2) => {\n      if (\"name\" in $$props2) $$invalidate(1, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(2, required = $$props2.required);\n      if (\"value\" in $$props2) $$invalidate(0, value = $$props2.value);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [value, name2, required, input0_change_handler];\n  }\n  var file15, Checkbox, checkbox_default;\n  var init_checkbox = __esm({\n    \"src/client/routes/data/record/checkbox.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      file15 = \"src/client/routes/data/record/checkbox.svelte\";\n      Checkbox = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance16, create_fragment16, safe_not_equal, { name: 1, required: 2, value: 0 });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Checkbox\",\n            options: options2,\n            id: create_fragment16.name\n          });\n        }\n        get name() {\n          throw new Error(\"<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set name(value) {\n          throw new Error(\"<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get required() {\n          throw new Error(\"<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set required(value) {\n          throw new Error(\"<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get value() {\n          throw new Error(\"<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set value(value) {\n          throw new Error(\"<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      checkbox_default = Checkbox;\n    }\n  });\n\n  // src/client/routes/data/record/input.svelte\n  function create_fragment17(ctx) {\n    let label;\n    let small;\n    let icon_1;\n    let t0;\n    let t1;\n    let t2;\n    let input;\n    let input_value_value;\n    let current;\n    icon_1 = new Icon_default({\n      props: { icon: (\n        /*icon*/\n        ctx[0]\n      ) },\n      $$inline: true\n    });\n    let input_levels = [\n      { type: (\n        /*type*/\n        ctx[1]\n      ) },\n      { name: (\n        /*name*/\n        ctx[2]\n      ) },\n      { required: (\n        /*required*/\n        ctx[3]\n      ) },\n      /*clean*/\n      ctx[6](\n        /*opts*/\n        ctx[5]\n      ),\n      {\n        value: input_value_value = /*clean*/\n        ctx[6](\n          /*value*/\n          ctx[4]\n        )\n      }\n    ];\n    let input_data = {};\n    for (let i = 0; i < input_levels.length; i += 1) {\n      input_data = assign(input_data, input_levels[i]);\n    }\n    const block2 = {\n      c: function create() {\n        label = element(\"label\");\n        small = element(\"small\");\n        create_component(icon_1.$$.fragment);\n        t0 = space();\n        t1 = text(\n          /*name*/\n          ctx[2]\n        );\n        t2 = space();\n        input = element(\"input\");\n        add_location(small, file16, 21, 4, 420);\n        set_attributes(input, input_data);\n        add_location(input, file16, 22, 4, 462);\n        add_location(label, file16, 20, 0, 408);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, label, anchor);\n        append_dev(label, small);\n        mount_component(icon_1, small, null);\n        append_dev(small, t0);\n        append_dev(small, t1);\n        append_dev(label, t2);\n        append_dev(label, input);\n        if (\"value\" in input_data) {\n          input.value = input_data.value;\n        }\n        if (input.autofocus) input.focus();\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const icon_1_changes = {};\n        if (dirty & /*icon*/\n        1) icon_1_changes.icon = /*icon*/\n        ctx2[0];\n        icon_1.$set(icon_1_changes);\n        if (!current || dirty & /*name*/\n        4) set_data_dev(\n          t1,\n          /*name*/\n          ctx2[2]\n        );\n        set_attributes(input, input_data = get_spread_update(input_levels, [\n          (!current || dirty & /*type*/\n          2) && { type: (\n            /*type*/\n            ctx2[1]\n          ) },\n          (!current || dirty & /*name*/\n          4) && { name: (\n            /*name*/\n            ctx2[2]\n          ) },\n          (!current || dirty & /*required*/\n          8) && { required: (\n            /*required*/\n            ctx2[3]\n          ) },\n          dirty & /*opts*/\n          32 && /*clean*/\n          ctx2[6](\n            /*opts*/\n            ctx2[5]\n          ),\n          (!current || dirty & /*value*/\n          16 && input_value_value !== (input_value_value = /*clean*/\n          ctx2[6](\n            /*value*/\n            ctx2[4]\n          )) && input.value !== input_value_value) && { value: input_value_value }\n        ]));\n        if (\"value\" in input_data) {\n          input.value = input_data.value;\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(label);\n        }\n        destroy_component(icon_1);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment17.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance17($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Input\", slots, []);\n    let { icon } = $$props;\n    let { type } = $$props;\n    let { name: name2 } = $$props;\n    let { required } = $$props;\n    let { value } = $$props;\n    let { opts } = $$props;\n    function clean(obj) {\n      const isObj2 = typeof obj === \"object\";\n      return isObj2 ? JSON.parse(JSON.stringify(obj, (_, v) => v || void 0)) : value || \"\";\n    }\n    $$self.$$.on_mount.push(function() {\n      if (icon === void 0 && !(\"icon\" in $$props || $$self.$$.bound[$$self.$$.props[\"icon\"]])) {\n        console.warn(\"<Input> was created without expected prop 'icon'\");\n      }\n      if (type === void 0 && !(\"type\" in $$props || $$self.$$.bound[$$self.$$.props[\"type\"]])) {\n        console.warn(\"<Input> was created without expected prop 'type'\");\n      }\n      if (name2 === void 0 && !(\"name\" in $$props || $$self.$$.bound[$$self.$$.props[\"name\"]])) {\n        console.warn(\"<Input> was created without expected prop 'name'\");\n      }\n      if (required === void 0 && !(\"required\" in $$props || $$self.$$.bound[$$self.$$.props[\"required\"]])) {\n        console.warn(\"<Input> was created without expected prop 'required'\");\n      }\n      if (value === void 0 && !(\"value\" in $$props || $$self.$$.bound[$$self.$$.props[\"value\"]])) {\n        console.warn(\"<Input> was created without expected prop 'value'\");\n      }\n      if (opts === void 0 && !(\"opts\" in $$props || $$self.$$.bound[$$self.$$.props[\"opts\"]])) {\n        console.warn(\"<Input> was created without expected prop 'opts'\");\n      }\n    });\n    const writable_props = [\"icon\", \"type\", \"name\", \"required\", \"value\", \"opts\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Input> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(0, icon = $$props2.icon);\n      if (\"type\" in $$props2) $$invalidate(1, type = $$props2.type);\n      if (\"name\" in $$props2) $$invalidate(2, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(3, required = $$props2.required);\n      if (\"value\" in $$props2) $$invalidate(4, value = $$props2.value);\n      if (\"opts\" in $$props2) $$invalidate(5, opts = $$props2.opts);\n    };\n    $$self.$capture_state = () => ({\n      Icon: Icon_default,\n      icon,\n      type,\n      name: name2,\n      required,\n      value,\n      opts,\n      clean\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"icon\" in $$props2) $$invalidate(0, icon = $$props2.icon);\n      if (\"type\" in $$props2) $$invalidate(1, type = $$props2.type);\n      if (\"name\" in $$props2) $$invalidate(2, name2 = $$props2.name);\n      if (\"required\" in $$props2) $$invalidate(3, required = $$props2.required);\n      if (\"value\" in $$props2) $$invalidate(4, value = $$props2.value);\n      if (\"opts\" in $$props2) $$invalidate(5, opts = $$props2.opts);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [icon, type, name2, required, value, opts, clean];\n  }\n  var file16, Input, input_default;\n  var init_input = __esm({\n    \"src/client/routes/data/record/input.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Icon();\n      file16 = \"src/client/routes/data/record/input.svelte\";\n      Input = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance17, create_fragment17, safe_not_equal, {\n            icon: 0,\n            type: 1,\n            name: 2,\n            required: 3,\n            value: 4,\n            opts: 5\n          });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Input\",\n            options: options2,\n            id: create_fragment17.name\n          });\n        }\n        get icon() {\n          throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set icon(value) {\n          throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get type() {\n          throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set type(value) {\n          throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get name() {\n          throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set name(value) {\n          throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get required() {\n          throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set required(value) {\n          throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get value() {\n          throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set value(value) {\n          throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get opts() {\n          throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set opts(value) {\n          throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      input_default = Input;\n    }\n  });\n\n  // src/client/components/Aside.svelte\n  function create_if_block7(ctx) {\n    let aside_1;\n    let form;\n    let updating_valid;\n    let keyEscape_action;\n    let closeAction_action;\n    let focusTrap_action;\n    let aside_1_transition;\n    let current;\n    let mounted;\n    let dispose;\n    function form_valid_binding(value) {\n      ctx[13](value);\n    }\n    let form_props = {\n      method: \"POST\",\n      $$slots: { default: [create_default_slot4] },\n      $$scope: { ctx }\n    };\n    if (\n      /*valid*/\n      ctx[0] !== void 0\n    ) {\n      form_props.valid = /*valid*/\n      ctx[0];\n    }\n    form = new Form_default({ props: form_props, $$inline: true });\n    binding_callbacks.push(() => bind(form, \"valid\", form_valid_binding));\n    form.$on(\n      \"submit\",\n      /*submit_handler*/\n      ctx[14]\n    );\n    form.$on(\n      \"reset\",\n      /*reset_handler*/\n      ctx[15]\n    );\n    form.$on(\n      \"input\",\n      /*input_handler*/\n      ctx[16]\n    );\n    const block2 = {\n      c: function create() {\n        aside_1 = element(\"aside\");\n        create_component(form.$$.fragment);\n        attr_dev(\n          aside_1,\n          \"id\",\n          /*id*/\n          ctx[1]\n        );\n        toggle_class(\n          aside_1,\n          \"top\",\n          /*top*/\n          ctx[3]\n        );\n        toggle_class(\n          aside_1,\n          \"right\",\n          /*right*/\n          ctx[4]\n        );\n        toggle_class(\n          aside_1,\n          \"bottom\",\n          /*bottom*/\n          ctx[5]\n        );\n        toggle_class(\n          aside_1,\n          \"left\",\n          /*left*/\n          ctx[6]\n        );\n        toggle_class(\n          aside_1,\n          \"open\",\n          /*open*/\n          ctx[2]\n        );\n        add_location(aside_1, file17, 44, 4, 974);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, aside_1, anchor);\n        mount_component(form, aside_1, null);\n        ctx[17](aside_1);\n        current = true;\n        if (!mounted) {\n          dispose = [\n            action_destroyer(keyEscape_action = keyEscape.call(\n              null,\n              aside_1,\n              /*close*/\n              ctx[7]\n            )),\n            action_destroyer(closeAction_action = /*closeAction*/\n            ctx[11].call(null, aside_1)),\n            action_destroyer(focusTrap_action = focusTrap.call(null, aside_1))\n          ];\n          mounted = true;\n        }\n      },\n      p: function update2(new_ctx, dirty) {\n        ctx = new_ctx;\n        const form_changes = {};\n        if (dirty & /*$$scope, valid, close*/\n        262273) {\n          form_changes.$$scope = { dirty, ctx };\n        }\n        if (!updating_valid && dirty & /*valid*/\n        1) {\n          updating_valid = true;\n          form_changes.valid = /*valid*/\n          ctx[0];\n          add_flush_callback(() => updating_valid = false);\n        }\n        form.$set(form_changes);\n        if (!current || dirty & /*id*/\n        2) {\n          attr_dev(\n            aside_1,\n            \"id\",\n            /*id*/\n            ctx[1]\n          );\n        }\n        if (keyEscape_action && is_function(keyEscape_action.update) && dirty & /*close*/\n        128) keyEscape_action.update.call(\n          null,\n          /*close*/\n          ctx[7]\n        );\n        if (!current || dirty & /*top*/\n        8) {\n          toggle_class(\n            aside_1,\n            \"top\",\n            /*top*/\n            ctx[3]\n          );\n        }\n        if (!current || dirty & /*right*/\n        16) {\n          toggle_class(\n            aside_1,\n            \"right\",\n            /*right*/\n            ctx[4]\n          );\n        }\n        if (!current || dirty & /*bottom*/\n        32) {\n          toggle_class(\n            aside_1,\n            \"bottom\",\n            /*bottom*/\n            ctx[5]\n          );\n        }\n        if (!current || dirty & /*left*/\n        64) {\n          toggle_class(\n            aside_1,\n            \"left\",\n            /*left*/\n            ctx[6]\n          );\n        }\n        if (!current || dirty & /*open*/\n        4) {\n          toggle_class(\n            aside_1,\n            \"open\",\n            /*open*/\n            ctx[2]\n          );\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(form.$$.fragment, local);\n        if (local) {\n          add_render_callback(() => {\n            if (!current) return;\n            if (!aside_1_transition) aside_1_transition = create_bidirectional_transition(\n              aside_1,\n              fly,\n              {\n                x: (\n                  /*aside*/\n                  ctx[8].offsetWidth * /*X*/\n                  ctx[9]\n                ),\n                y: (\n                  /*aside*/\n                  ctx[8].offsetHeight * /*Y*/\n                  ctx[10]\n                ),\n                opacity: 1\n              },\n              true\n            );\n            aside_1_transition.run(1);\n          });\n        }\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(form.$$.fragment, local);\n        if (local) {\n          if (!aside_1_transition) aside_1_transition = create_bidirectional_transition(\n            aside_1,\n            fly,\n            {\n              x: (\n                /*aside*/\n                ctx[8].offsetWidth * /*X*/\n                ctx[9]\n              ),\n              y: (\n                /*aside*/\n                ctx[8].offsetHeight * /*Y*/\n                ctx[10]\n              ),\n              opacity: 1\n            },\n            false\n          );\n          aside_1_transition.run(0);\n        }\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(aside_1);\n        }\n        destroy_component(form);\n        ctx[17](null);\n        if (detaching && aside_1_transition) aside_1_transition.end();\n        mounted = false;\n        run_all(dispose);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block7.name,\n      type: \"if\",\n      source: \"(33:0) {#if open}\",\n      ctx\n    });\n    return block2;\n  }\n  function fallback_block4(ctx) {\n    let nav;\n    let button0;\n    let t1;\n    let button1;\n    let t2;\n    let button1_disabled_value;\n    const block2 = {\n      c: function create() {\n        nav = element(\"nav\");\n        button0 = element(\"button\");\n        button0.textContent = \"Cancel\";\n        t1 = space();\n        button1 = element(\"button\");\n        t2 = text(\"Confirm\");\n        attr_dev(button0, \"type\", \"reset\");\n        attr_dev(button0, \"class\", \"link\");\n        add_location(button0, file17, 79, 24, 1951);\n        attr_dev(button1, \"type\", \"submit\");\n        attr_dev(button1, \"class\", \"success\");\n        button1.disabled = button1_disabled_value = !/*valid*/\n        ctx[0];\n        add_location(button1, file17, 80, 24, 2025);\n        attr_dev(nav, \"class\", \"cols col-fit justify-end\");\n        add_location(nav, file17, 78, 20, 1888);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, nav, anchor);\n        append_dev(nav, button0);\n        append_dev(nav, t1);\n        append_dev(nav, button1);\n        append_dev(button1, t2);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*valid*/\n        1 && button1_disabled_value !== (button1_disabled_value = !/*valid*/\n        ctx2[0])) {\n          prop_dev(button1, \"disabled\", button1_disabled_value);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(nav);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: fallback_block4.name,\n      type: \"fallback\",\n      source: \"(67:36)                      \",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot4(ctx) {\n    let header;\n    let t0;\n    let button;\n    let icon;\n    let t1;\n    let article;\n    let t2;\n    let footer;\n    let current;\n    let mounted;\n    let dispose;\n    const header_slot_template = (\n      /*#slots*/\n      ctx[12].header\n    );\n    const header_slot = create_slot(\n      header_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[18],\n      get_header_slot_context2\n    );\n    icon = new Icon_default({ $$inline: true });\n    const default_slot_template = (\n      /*#slots*/\n      ctx[12].default\n    );\n    const default_slot = create_slot(\n      default_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[18],\n      null\n    );\n    const footer_slot_template = (\n      /*#slots*/\n      ctx[12].footer\n    );\n    const footer_slot = create_slot(\n      footer_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[18],\n      get_footer_slot_context2\n    );\n    const footer_slot_or_fallback = footer_slot || fallback_block4(ctx);\n    const block2 = {\n      c: function create() {\n        header = element(\"header\");\n        if (header_slot) header_slot.c();\n        t0 = space();\n        button = element(\"button\");\n        create_component(icon.$$.fragment);\n        t1 = space();\n        article = element(\"article\");\n        if (default_slot) default_slot.c();\n        t2 = space();\n        footer = element(\"footer\");\n        if (footer_slot_or_fallback) footer_slot_or_fallback.c();\n        attr_dev(button, \"type\", \"reset\");\n        attr_dev(button, \"id\", \"close\");\n        attr_dev(button, \"class\", \"action link\");\n        add_location(button, file17, 64, 16, 1481);\n        add_location(header, file17, 62, 12, 1417);\n        attr_dev(article, \"class\", \"scroll\");\n        add_location(article, file17, 73, 12, 1737);\n        add_location(footer, file17, 76, 12, 1822);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, header, anchor);\n        if (header_slot) {\n          header_slot.m(header, null);\n        }\n        append_dev(header, t0);\n        append_dev(header, button);\n        mount_component(icon, button, null);\n        insert_dev(target, t1, anchor);\n        insert_dev(target, article, anchor);\n        if (default_slot) {\n          default_slot.m(article, null);\n        }\n        insert_dev(target, t2, anchor);\n        insert_dev(target, footer, anchor);\n        if (footer_slot_or_fallback) {\n          footer_slot_or_fallback.m(footer, null);\n        }\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            button,\n            \"click\",\n            function() {\n              if (is_function(\n                /*close*/\n                ctx[7]\n              )) ctx[7].apply(this, arguments);\n            },\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(new_ctx, dirty) {\n        ctx = new_ctx;\n        if (header_slot) {\n          if (header_slot.p && (!current || dirty & /*$$scope*/\n          262144)) {\n            update_slot_base(\n              header_slot,\n              header_slot_template,\n              ctx,\n              /*$$scope*/\n              ctx[18],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx[18]\n              ) : get_slot_changes(\n                header_slot_template,\n                /*$$scope*/\n                ctx[18],\n                dirty,\n                get_header_slot_changes2\n              ),\n              get_header_slot_context2\n            );\n          }\n        }\n        if (default_slot) {\n          if (default_slot.p && (!current || dirty & /*$$scope*/\n          262144)) {\n            update_slot_base(\n              default_slot,\n              default_slot_template,\n              ctx,\n              /*$$scope*/\n              ctx[18],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx[18]\n              ) : get_slot_changes(\n                default_slot_template,\n                /*$$scope*/\n                ctx[18],\n                dirty,\n                null\n              ),\n              null\n            );\n          }\n        }\n        if (footer_slot) {\n          if (footer_slot.p && (!current || dirty & /*$$scope*/\n          262144)) {\n            update_slot_base(\n              footer_slot,\n              footer_slot_template,\n              ctx,\n              /*$$scope*/\n              ctx[18],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx[18]\n              ) : get_slot_changes(\n                footer_slot_template,\n                /*$$scope*/\n                ctx[18],\n                dirty,\n                get_footer_slot_changes2\n              ),\n              get_footer_slot_context2\n            );\n          }\n        } else {\n          if (footer_slot_or_fallback && footer_slot_or_fallback.p && (!current || dirty & /*valid*/\n          1)) {\n            footer_slot_or_fallback.p(ctx, !current ? -1 : dirty);\n          }\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(header_slot, local);\n        transition_in(icon.$$.fragment, local);\n        transition_in(default_slot, local);\n        transition_in(footer_slot_or_fallback, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(header_slot, local);\n        transition_out(icon.$$.fragment, local);\n        transition_out(default_slot, local);\n        transition_out(footer_slot_or_fallback, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(header);\n          detach_dev(t1);\n          detach_dev(article);\n          detach_dev(t2);\n          detach_dev(footer);\n        }\n        if (header_slot) header_slot.d(detaching);\n        destroy_component(icon);\n        if (default_slot) default_slot.d(detaching);\n        if (footer_slot_or_fallback) footer_slot_or_fallback.d(detaching);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot4.name,\n      type: \"slot\",\n      source: '(51:8) <Form method=\\\\\"POST\\\\\" bind:valid on:submit on:reset on:input>',\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment18(ctx) {\n    let if_block_anchor;\n    let current;\n    let if_block = (\n      /*open*/\n      ctx[2] && create_if_block7(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        if (if_block) if_block.c();\n        if_block_anchor = empty();\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        if (if_block) if_block.m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (\n          /*open*/\n          ctx2[2]\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty & /*open*/\n            4) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block7(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(if_block_anchor.parentNode, if_block_anchor);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if (if_block) if_block.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment18.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance18($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Aside\", slots, [\"header\", \"default\", \"footer\"]);\n    let { id = \"\" } = $$props;\n    let { open = false } = $$props;\n    let { top = false } = $$props;\n    let { right = false } = $$props;\n    let { bottom = false } = $$props;\n    let { left = false } = $$props;\n    let { valid = false } = $$props;\n    let { close: close4 = () => fragment2.set(\"\") } = $$props;\n    let aside;\n    const X = left ? -1 : right ? 1 : 0;\n    const Y = top ? -1 : bottom ? 1 : 0;\n    function closeAction(aside2) {\n      const form = aside2.firstChild;\n      form.onsubmit = () => close4();\n      form.onreset = () => close4();\n      aside2.onclick = (e) => {\n        e.stopPropagation();\n        const { nodeName } = e.target;\n        if (nodeName === \"ASIDE\") {\n          close4();\n        }\n      };\n    }\n    const writable_props = [\"id\", \"open\", \"top\", \"right\", \"bottom\", \"left\", \"valid\", \"close\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Aside> was created with unknown prop '${key}'`);\n    });\n    function form_valid_binding(value) {\n      valid = value;\n      $$invalidate(0, valid);\n    }\n    function submit_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    function reset_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    function input_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    function aside_1_binding($$value) {\n      binding_callbacks[$$value ? \"unshift\" : \"push\"](() => {\n        aside = $$value;\n        $$invalidate(8, aside);\n      });\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"id\" in $$props2) $$invalidate(1, id = $$props2.id);\n      if (\"open\" in $$props2) $$invalidate(2, open = $$props2.open);\n      if (\"top\" in $$props2) $$invalidate(3, top = $$props2.top);\n      if (\"right\" in $$props2) $$invalidate(4, right = $$props2.right);\n      if (\"bottom\" in $$props2) $$invalidate(5, bottom = $$props2.bottom);\n      if (\"left\" in $$props2) $$invalidate(6, left = $$props2.left);\n      if (\"valid\" in $$props2) $$invalidate(0, valid = $$props2.valid);\n      if (\"close\" in $$props2) $$invalidate(7, close4 = $$props2.close);\n      if (\"$$scope\" in $$props2) $$invalidate(18, $$scope = $$props2.$$scope);\n    };\n    $$self.$capture_state = () => ({\n      fly,\n      fragment: fragment2,\n      clickout,\n      clickOutside,\n      focusTrap,\n      keyEscape,\n      Form: Form_default,\n      Icon: Icon_default,\n      id,\n      open,\n      top,\n      right,\n      bottom,\n      left,\n      valid,\n      close: close4,\n      aside,\n      X,\n      Y,\n      closeAction\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"id\" in $$props2) $$invalidate(1, id = $$props2.id);\n      if (\"open\" in $$props2) $$invalidate(2, open = $$props2.open);\n      if (\"top\" in $$props2) $$invalidate(3, top = $$props2.top);\n      if (\"right\" in $$props2) $$invalidate(4, right = $$props2.right);\n      if (\"bottom\" in $$props2) $$invalidate(5, bottom = $$props2.bottom);\n      if (\"left\" in $$props2) $$invalidate(6, left = $$props2.left);\n      if (\"valid\" in $$props2) $$invalidate(0, valid = $$props2.valid);\n      if (\"close\" in $$props2) $$invalidate(7, close4 = $$props2.close);\n      if (\"aside\" in $$props2) $$invalidate(8, aside = $$props2.aside);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      valid,\n      id,\n      open,\n      top,\n      right,\n      bottom,\n      left,\n      close4,\n      aside,\n      X,\n      Y,\n      closeAction,\n      slots,\n      form_valid_binding,\n      submit_handler,\n      reset_handler,\n      input_handler,\n      aside_1_binding,\n      $$scope\n    ];\n  }\n  var file17, get_footer_slot_changes2, get_footer_slot_context2, get_header_slot_changes2, get_header_slot_context2, Aside, Aside_default;\n  var init_Aside = __esm({\n    \"src/client/components/Aside.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Icon();\n      init_Form();\n      init_actions();\n      init_src();\n      init_transition();\n      file17 = \"src/client/components/Aside.svelte\";\n      get_footer_slot_changes2 = (dirty) => ({});\n      get_footer_slot_context2 = (ctx) => ({});\n      get_header_slot_changes2 = (dirty) => ({});\n      get_header_slot_context2 = (ctx) => ({});\n      Aside = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance18, create_fragment18, safe_not_equal, {\n            id: 1,\n            open: 2,\n            top: 3,\n            right: 4,\n            bottom: 5,\n            left: 6,\n            valid: 0,\n            close: 7\n          });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Aside\",\n            options: options2,\n            id: create_fragment18.name\n          });\n        }\n        get id() {\n          throw new Error(\"<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set id(value) {\n          throw new Error(\"<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get open() {\n          throw new Error(\"<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set open(value) {\n          throw new Error(\"<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get top() {\n          throw new Error(\"<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set top(value) {\n          throw new Error(\"<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get right() {\n          throw new Error(\"<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set right(value) {\n          throw new Error(\"<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get bottom() {\n          throw new Error(\"<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set bottom(value) {\n          throw new Error(\"<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get left() {\n          throw new Error(\"<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set left(value) {\n          throw new Error(\"<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get valid() {\n          throw new Error(\"<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set valid(value) {\n          throw new Error(\"<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get close() {\n          throw new Error(\"<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set close(value) {\n          throw new Error(\"<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      Aside_default = Aside;\n    }\n  });\n\n  // src/client/utils/time.ts\n  function date(time) {\n    return new Date(time).toLocaleString(\"ru\");\n  }\n  function locale() {\n    return navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language;\n  }\n  var format;\n  var init_time = __esm({\n    \"src/client/utils/time.ts\"() {\n      \"use strict\";\n      init_reload();\n      format = new Intl.DateTimeFormat(\n        locale(),\n        {\n          year: \"numeric\",\n          month: \"numeric\",\n          day: \"numeric\",\n          hour: \"numeric\",\n          minute: \"numeric\"\n        }\n      );\n      (/* @__PURE__ */ new Date()).toISOString().substring(11, 16);\n      (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);\n    }\n  });\n\n  // src/client/routes/data/record.svelte\n  function get_each_context4(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[15] = list2[i].type;\n    child_ctx[16] = object_without_properties(list2[i], [\"type\"]);\n    return child_ctx;\n  }\n  function get_each_context_13(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[19] = list2[i];\n    return child_ctx;\n  }\n  function create_if_block_8(ctx) {\n    let p;\n    let small0;\n    let span0;\n    let t1;\n    let t2_value = date(Number(\n      /*active*/\n      ctx[0]?.id\n    )) + \"\";\n    let t2;\n    let t3;\n    let small1;\n    let span1;\n    let t5;\n    let t6_value = date(Number(\n      /*active*/\n      ctx[0]?.updated\n    )) + \"\";\n    let t6;\n    const block2 = {\n      c: function create() {\n        p = element(\"p\");\n        small0 = element(\"small\");\n        span0 = element(\"span\");\n        span0.textContent = \"Created:\";\n        t1 = space();\n        t2 = text(t2_value);\n        t3 = space();\n        small1 = element(\"small\");\n        span1 = element(\"span\");\n        span1.textContent = \"Updated:\";\n        t5 = space();\n        t6 = text(t6_value);\n        add_location(span0, file18, 105, 19, 3060);\n        add_location(small0, file18, 105, 12, 3053);\n        add_location(span1, file18, 106, 19, 3136);\n        add_location(small1, file18, 106, 12, 3129);\n        attr_dev(p, \"class\", \"cols col-fit\");\n        set_style(p, \"--cols-gap\", \"var(--gap-sm)\");\n        add_location(p, file18, 104, 8, 2982);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, p, anchor);\n        append_dev(p, small0);\n        append_dev(small0, span0);\n        append_dev(small0, t1);\n        append_dev(small0, t2);\n        append_dev(p, t3);\n        append_dev(p, small1);\n        append_dev(small1, span1);\n        append_dev(small1, t5);\n        append_dev(small1, t6);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*active*/\n        1 && t2_value !== (t2_value = date(Number(\n          /*active*/\n          ctx2[0]?.id\n        )) + \"\")) set_data_dev(t2, t2_value);\n        if (dirty & /*active*/\n        1 && t6_value !== (t6_value = date(Number(\n          /*active*/\n          ctx2[0]?.updated\n        )) + \"\")) set_data_dev(t6, t6_value);\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(p);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_8.name,\n      type: \"if\",\n      source: \"(89:4) {#if active?.id && active?.updated}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block_13(ctx) {\n    let button;\n    let t_value = (\n      /*tab*/\n      ctx[19] + \"\"\n    );\n    let t;\n    let button_id_value;\n    let button_disabled_value;\n    let mounted;\n    let dispose;\n    const block2 = {\n      c: function create() {\n        button = element(\"button\");\n        t = text(t_value);\n        attr_dev(button, \"id\", button_id_value = /*tab*/\n        ctx[19]);\n        attr_dev(button, \"type\", \"button\");\n        button.disabled = button_disabled_value = /*activeTab*/\n        ctx[4] === /*tab*/\n        ctx[19];\n        add_location(button, file18, 114, 16, 3420);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, button, anchor);\n        append_dev(button, t);\n        if (!mounted) {\n          dispose = listen_dev(\n            button,\n            \"click\",\n            /*setTab*/\n            ctx[10],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*activeTab*/\n        16 && button_disabled_value !== (button_disabled_value = /*activeTab*/\n        ctx2[4] === /*tab*/\n        ctx2[19])) {\n          prop_dev(button, \"disabled\", button_disabled_value);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(button);\n        }\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block_13.name,\n      type: \"each\",\n      source: \"(99:12) {#each tabs as tab}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_7(ctx) {\n    let code;\n    let current;\n    code = new Code_default({\n      props: {\n        input: JSON.stringify(\n          /*makeRecord*/\n          ctx[7](),\n          null,\n          2\n        )\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(code.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(code, target, anchor);\n        current = true;\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(code.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(code.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(code, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_7.name,\n      type: \"if\",\n      source: \"(138:39) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block8(ctx) {\n    let label;\n    let small;\n    let icon;\n    let t0;\n    let t1;\n    let input;\n    let input_autofocus_value;\n    let t2;\n    let each_1_anchor;\n    let current;\n    icon = new Icon_default({ props: { icon: \"hash\" }, $$inline: true });\n    let each_value = ensure_array_like_dev(\n      /*makeRecord*/\n      ctx[7]()\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));\n    }\n    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {\n      each_blocks[i] = null;\n    });\n    const block2 = {\n      c: function create() {\n        label = element(\"label\");\n        small = element(\"small\");\n        create_component(icon.$$.fragment);\n        t0 = text(\" ID\");\n        t1 = space();\n        input = element(\"input\");\n        t2 = space();\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        each_1_anchor = empty();\n        add_location(small, file18, 125, 16, 3720);\n        attr_dev(input, \"name\", \"id\");\n        attr_dev(input, \"type\", \"text\");\n        input.value = /*recordID*/\n        ctx[5];\n        input.autofocus = input_autofocus_value = true;\n        attr_dev(input, \"placeholder\", \"Autogenerated\");\n        add_location(input, file18, 127, 16, 3829);\n        add_location(label, file18, 124, 12, 3696);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, label, anchor);\n        append_dev(label, small);\n        mount_component(icon, small, null);\n        append_dev(small, t0);\n        append_dev(label, t1);\n        append_dev(label, input);\n        insert_dev(target, t2, anchor);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(target, anchor);\n          }\n        }\n        insert_dev(target, each_1_anchor, anchor);\n        current = true;\n        if (true) input.focus();\n      },\n      p: function update2(ctx2, dirty) {\n        if (!current || dirty & /*recordID*/\n        32 && input.value !== /*recordID*/\n        ctx2[5]) {\n          prop_dev(\n            input,\n            \"value\",\n            /*recordID*/\n            ctx2[5]\n          );\n        }\n        if (dirty & /*makeRecord*/\n        128) {\n          each_value = ensure_array_like_dev(\n            /*makeRecord*/\n            ctx2[7]()\n          );\n          let i;\n          for (i = 0; i < each_value.length; i += 1) {\n            const child_ctx = get_each_context4(ctx2, each_value, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n              transition_in(each_blocks[i], 1);\n            } else {\n              each_blocks[i] = create_each_block4(child_ctx);\n              each_blocks[i].c();\n              transition_in(each_blocks[i], 1);\n              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n          group_outros();\n          for (i = each_value.length; i < each_blocks.length; i += 1) {\n            out(i);\n          }\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        for (let i = 0; i < each_value.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        each_blocks = each_blocks.filter(Boolean_1);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(label);\n          detach_dev(t2);\n          detach_dev(each_1_anchor);\n        }\n        destroy_component(icon);\n        destroy_each(each_blocks, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block8.name,\n      type: \"if\",\n      source: '(109:8) {#if activeTab === \\\\\"Form\\\\\"}',\n      ctx\n    });\n    return block2;\n  }\n  function create_else_block3(ctx) {\n    let input;\n    let current;\n    const input_spread_levels = [\n      { type: (\n        /*type*/\n        ctx[15]\n      ) },\n      /*props*/\n      ctx[16]\n    ];\n    let input_props = {};\n    for (let i = 0; i < input_spread_levels.length; i += 1) {\n      input_props = assign(input_props, input_spread_levels[i]);\n    }\n    input = new input_default({ props: input_props, $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(input.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(input, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const input_changes = dirty & /*makeRecord*/\n        128 ? get_spread_update(input_spread_levels, [{ type: (\n          /*type*/\n          ctx2[15]\n        ) }, get_spread_object(\n          /*props*/\n          ctx2[16]\n        )]) : {};\n        input.$set(input_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(input.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(input.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(input, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_else_block3.name,\n      type: \"else\",\n      source: \"(134:16) {:else}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_6(ctx) {\n    let inputfile;\n    let current;\n    const inputfile_spread_levels = [\n      /*props*/\n      ctx[16]\n    ];\n    let inputfile_props = {};\n    for (let i = 0; i < inputfile_spread_levels.length; i += 1) {\n      inputfile_props = assign(inputfile_props, inputfile_spread_levels[i]);\n    }\n    inputfile = new file_default({ props: inputfile_props, $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(inputfile.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(inputfile, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const inputfile_changes = dirty & /*makeRecord*/\n        128 ? get_spread_update(inputfile_spread_levels, [get_spread_object(\n          /*props*/\n          ctx2[16]\n        )]) : {};\n        inputfile.$set(inputfile_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(inputfile.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(inputfile.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(inputfile, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_6.name,\n      type: \"if\",\n      source: \"(132:42) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_5(ctx) {\n    let markdown;\n    let current;\n    const markdown_spread_levels = [\n      /*props*/\n      ctx[16]\n    ];\n    let markdown_props = {};\n    for (let i = 0; i < markdown_spread_levels.length; i += 1) {\n      markdown_props = assign(markdown_props, markdown_spread_levels[i]);\n    }\n    markdown = new markdown_default({ props: markdown_props, $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(markdown.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(markdown, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const markdown_changes = dirty & /*makeRecord*/\n        128 ? get_spread_update(markdown_spread_levels, [get_spread_object(\n          /*props*/\n          ctx2[16]\n        )]) : {};\n        markdown.$set(markdown_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(markdown.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(markdown.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(markdown, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_5.name,\n      type: \"if\",\n      source: \"(130:46) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_4(ctx) {\n    let json;\n    let current;\n    const json_spread_levels = [\n      /*props*/\n      ctx[16]\n    ];\n    let json_props = {};\n    for (let i = 0; i < json_spread_levels.length; i += 1) {\n      json_props = assign(json_props, json_spread_levels[i]);\n    }\n    json = new json_default({ props: json_props, $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(json.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(json, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const json_changes = dirty & /*makeRecord*/\n        128 ? get_spread_update(json_spread_levels, [get_spread_object(\n          /*props*/\n          ctx2[16]\n        )]) : {};\n        json.$set(json_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(json.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(json.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(json, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_4.name,\n      type: \"if\",\n      source: \"(128:42) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_32(ctx) {\n    let select;\n    let current;\n    const select_spread_levels = [\n      /*props*/\n      ctx[16]\n    ];\n    let select_props = {};\n    for (let i = 0; i < select_spread_levels.length; i += 1) {\n      select_props = assign(select_props, select_spread_levels[i]);\n    }\n    select = new select_default({ props: select_props, $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(select.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(select, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const select_changes = dirty & /*makeRecord*/\n        128 ? get_spread_update(select_spread_levels, [get_spread_object(\n          /*props*/\n          ctx2[16]\n        )]) : {};\n        select.$set(select_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(select.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(select.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(select, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_32.name,\n      type: \"if\",\n      source: \"(126:44) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_22(ctx) {\n    let textarea;\n    let current;\n    const textarea_spread_levels = [\n      /*props*/\n      ctx[16]\n    ];\n    let textarea_props = {};\n    for (let i = 0; i < textarea_spread_levels.length; i += 1) {\n      textarea_props = assign(textarea_props, textarea_spread_levels[i]);\n    }\n    textarea = new textarea_default({ props: textarea_props, $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(textarea.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(textarea, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const textarea_changes = dirty & /*makeRecord*/\n        128 ? get_spread_update(textarea_spread_levels, [get_spread_object(\n          /*props*/\n          ctx2[16]\n        )]) : {};\n        textarea.$set(textarea_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(textarea.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(textarea.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(textarea, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_22.name,\n      type: \"if\",\n      source: \"(124:46) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_14(ctx) {\n    let checkbox;\n    let current;\n    const checkbox_spread_levels = [\n      /*props*/\n      ctx[16]\n    ];\n    let checkbox_props = {};\n    for (let i = 0; i < checkbox_spread_levels.length; i += 1) {\n      checkbox_props = assign(checkbox_props, checkbox_spread_levels[i]);\n    }\n    checkbox = new checkbox_default({ props: checkbox_props, $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(checkbox.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(checkbox, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const checkbox_changes = dirty & /*makeRecord*/\n        128 ? get_spread_update(checkbox_spread_levels, [get_spread_object(\n          /*props*/\n          ctx2[16]\n        )]) : {};\n        checkbox.$set(checkbox_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(checkbox.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(checkbox.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(checkbox, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_14.name,\n      type: \"if\",\n      source: '(122:16) {#if type === \\\\\"checkbox\\\\\"}',\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block4(ctx) {\n    let current_block_type_index;\n    let if_block;\n    let if_block_anchor;\n    let current;\n    const if_block_creators = [\n      create_if_block_14,\n      create_if_block_22,\n      create_if_block_32,\n      create_if_block_4,\n      create_if_block_5,\n      create_if_block_6,\n      create_else_block3\n    ];\n    const if_blocks = [];\n    function select_block_type_1(ctx2, dirty) {\n      if (\n        /*type*/\n        ctx2[15] === \"checkbox\"\n      ) return 0;\n      if (\n        /*type*/\n        ctx2[15] === \"textarea\"\n      ) return 1;\n      if (\n        /*type*/\n        ctx2[15] === \"select\"\n      ) return 2;\n      if (\n        /*type*/\n        ctx2[15] === \"json\"\n      ) return 3;\n      if (\n        /*type*/\n        ctx2[15] === \"markdown\"\n      ) return 4;\n      if (\n        /*type*/\n        ctx2[15] === \"file\"\n      ) return 5;\n      return 6;\n    }\n    current_block_type_index = select_block_type_1(ctx, -1);\n    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n    const block2 = {\n      c: function create() {\n        if_block.c();\n        if_block_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        if_blocks[current_block_type_index].m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if_block.p(ctx2, dirty);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if_blocks[current_block_type_index].d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block4.name,\n      type: \"each\",\n      source: \"(121:12) {#each makeRecord() as { type, ...props }}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot5(ctx) {\n    let t0;\n    let fieldset;\n    let legend;\n    let t1;\n    let current_block_type_index;\n    let if_block1;\n    let current;\n    let if_block0 = (\n      /*active*/\n      ctx[0]?.id && /*active*/\n      ctx[0]?.updated && create_if_block_8(ctx)\n    );\n    let each_value_1 = ensure_array_like_dev(\n      /*tabs*/\n      ctx[6]\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value_1.length; i += 1) {\n      each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));\n    }\n    const if_block_creators = [create_if_block8, create_if_block_7];\n    const if_blocks = [];\n    function select_block_type(ctx2, dirty) {\n      if (\n        /*activeTab*/\n        ctx2[4] === \"Form\"\n      ) return 0;\n      if (\n        /*activeTab*/\n        ctx2[4] === \"Code\"\n      ) return 1;\n      return -1;\n    }\n    if (~(current_block_type_index = select_block_type(ctx, -1))) {\n      if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n    }\n    const block2 = {\n      c: function create() {\n        if (if_block0) if_block0.c();\n        t0 = space();\n        fieldset = element(\"fieldset\");\n        legend = element(\"legend\");\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        t1 = space();\n        if (if_block1) if_block1.c();\n        attr_dev(legend, \"role\", \"group\");\n        add_location(legend, file18, 112, 8, 3350);\n        add_location(fieldset, file18, 111, 4, 3331);\n      },\n      m: function mount(target, anchor) {\n        if (if_block0) if_block0.m(target, anchor);\n        insert_dev(target, t0, anchor);\n        insert_dev(target, fieldset, anchor);\n        append_dev(fieldset, legend);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(legend, null);\n          }\n        }\n        append_dev(fieldset, t1);\n        if (~current_block_type_index) {\n          if_blocks[current_block_type_index].m(fieldset, null);\n        }\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*active*/\n          ctx2[0]?.id && /*active*/\n          ctx2[0]?.updated\n        ) {\n          if (if_block0) {\n            if_block0.p(ctx2, dirty);\n          } else {\n            if_block0 = create_if_block_8(ctx2);\n            if_block0.c();\n            if_block0.m(t0.parentNode, t0);\n          }\n        } else if (if_block0) {\n          if_block0.d(1);\n          if_block0 = null;\n        }\n        if (dirty & /*tabs, activeTab, setTab*/\n        1104) {\n          each_value_1 = ensure_array_like_dev(\n            /*tabs*/\n            ctx2[6]\n          );\n          let i;\n          for (i = 0; i < each_value_1.length; i += 1) {\n            const child_ctx = get_each_context_13(ctx2, each_value_1, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n            } else {\n              each_blocks[i] = create_each_block_13(child_ctx);\n              each_blocks[i].c();\n              each_blocks[i].m(legend, null);\n            }\n          }\n          for (; i < each_blocks.length; i += 1) {\n            each_blocks[i].d(1);\n          }\n          each_blocks.length = each_value_1.length;\n        }\n        let previous_block_index = current_block_type_index;\n        current_block_type_index = select_block_type(ctx2, dirty);\n        if (current_block_type_index === previous_block_index) {\n          if (~current_block_type_index) {\n            if_blocks[current_block_type_index].p(ctx2, dirty);\n          }\n        } else {\n          if (if_block1) {\n            group_outros();\n            transition_out(if_blocks[previous_block_index], 1, 1, () => {\n              if_blocks[previous_block_index] = null;\n            });\n            check_outros();\n          }\n          if (~current_block_type_index) {\n            if_block1 = if_blocks[current_block_type_index];\n            if (!if_block1) {\n              if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);\n              if_block1.c();\n            } else {\n              if_block1.p(ctx2, dirty);\n            }\n            transition_in(if_block1, 1);\n            if_block1.m(fieldset, null);\n          } else {\n            if_block1 = null;\n          }\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(t0);\n          detach_dev(fieldset);\n        }\n        if (if_block0) if_block0.d(detaching);\n        destroy_each(each_blocks, detaching);\n        if (~current_block_type_index) {\n          if_blocks[current_block_type_index].d();\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot5.name,\n      type: \"slot\",\n      source: \"(87:0) <Aside {open} {close} right on:submit={submitRecord} on:reset={resetRecord}>\",\n      ctx\n    });\n    return block2;\n  }\n  function create_header_slot(ctx) {\n    let h3;\n    let t0;\n    let t1;\n    let t2_value = (\n      /*active*/\n      (ctx[0]?.id || \"\") + \"\"\n    );\n    let t2;\n    const block2 = {\n      c: function create() {\n        h3 = element(\"h3\");\n        t0 = text(\n          /*header*/\n          ctx[3]\n        );\n        t1 = space();\n        t2 = text(t2_value);\n        attr_dev(h3, \"slot\", \"header\");\n        add_location(h3, file18, 102, 4, 2883);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, h3, anchor);\n        append_dev(h3, t0);\n        append_dev(h3, t1);\n        append_dev(h3, t2);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*header*/\n        8) set_data_dev(\n          t0,\n          /*header*/\n          ctx2[3]\n        );\n        if (dirty & /*active*/\n        1 && t2_value !== (t2_value = /*active*/\n        (ctx2[0]?.id || \"\") + \"\")) set_data_dev(t2, t2_value);\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(h3);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_header_slot.name,\n      type: \"slot\",\n      source: \"(88:4) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment19(ctx) {\n    let aside;\n    let current;\n    aside = new Aside_default({\n      props: {\n        open: (\n          /*open*/\n          ctx[1]\n        ),\n        close: (\n          /*close*/\n          ctx[2]\n        ),\n        right: true,\n        $$slots: {\n          header: [create_header_slot],\n          default: [create_default_slot5]\n        },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    aside.$on(\n      \"submit\",\n      /*submitRecord*/\n      ctx[9]\n    );\n    aside.$on(\n      \"reset\",\n      /*resetRecord*/\n      ctx[8]\n    );\n    const block2 = {\n      c: function create() {\n        create_component(aside.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(aside, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const aside_changes = {};\n        if (dirty & /*open*/\n        2) aside_changes.open = /*open*/\n        ctx2[1];\n        if (dirty & /*close*/\n        4) aside_changes.close = /*close*/\n        ctx2[2];\n        if (dirty & /*$$scope, active, header, recordID, activeTab*/\n        4194361) {\n          aside_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        aside.$set(aside_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(aside.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(aside.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(aside, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment19.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance19($$self, $$props, $$invalidate) {\n    let $query;\n    let $schemas;\n    validate_store(query2, \"query\");\n    component_subscribe($$self, query2, ($$value) => $$invalidate(12, $query = $$value));\n    validate_store(schemas, \"schemas\");\n    component_subscribe($$self, schemas, ($$value) => $$invalidate(13, $schemas = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Record\", slots, []);\n    let { collection = \"\" } = $$props;\n    let { active: active2 = void 0 } = $$props;\n    let { open = false } = $$props;\n    let { close: close4 = () => query2.set(\"\") } = $$props;\n    let { header = \"Add record\" } = $$props;\n    const tabs = [\"Form\", \"Code\"];\n    let activeTab = \"Form\";\n    let recordID;\n    function getRecord() {\n      $$invalidate(0, active2 = records.id(Number($query.record)));\n      $$invalidate(5, recordID = active2?.id || Date.now());\n    }\n    function makeRecord() {\n      getRecord();\n      return $schemas.map((s2) => ({\n        ...s2,\n        value: active2?.[s2.name],\n        collection,\n        recordID\n      }));\n    }\n    async function resetRecord(e) {\n      if (!active2) {\n        const data = new FormData(e.currentTarget);\n        const entries = Object.fromEntries(data);\n        let fileNames = [];\n        for (const name2 in entries) {\n          const type = schemas.type(name2);\n          if (type === \"file\") {\n            const files2 = JSON.parse(String(entries[name2]));\n            fileNames.push(...files2.map(({ name: name3 }) => name3));\n          }\n        }\n        await files.delete(collection, fileNames);\n      }\n    }\n    function submitRecord(e) {\n      const data = new FormData(e.currentTarget);\n      const entries = Object.fromEntries(data);\n      const record = {};\n      for (const name2 in entries) {\n        const value = name2 === \"id\" ? Number(entries[name2]) : entries[name2];\n        const type = schemas.type(name2);\n        switch (type) {\n          case \"checkbox\":\n            record[name2] = Boolean(value);\n            break;\n          case \"number\":\n            record[name2] = Number(value);\n            break;\n          case \"file\":\n            record[name2] = JSON.parse(String(value));\n            break;\n          default:\n            record[name2] = value;\n            break;\n        }\n      }\n      $query.record === active2?.id ? records.update(collection, record) : records.set(collection, record);\n    }\n    function setTab(e) {\n      const { id, innerText } = e.currentTarget;\n      $$invalidate(4, activeTab = innerText);\n    }\n    const writable_props = [\"collection\", \"active\", \"open\", \"close\", \"header\"];\n    Object_13.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Record> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"collection\" in $$props2) $$invalidate(11, collection = $$props2.collection);\n      if (\"active\" in $$props2) $$invalidate(0, active2 = $$props2.active);\n      if (\"open\" in $$props2) $$invalidate(1, open = $$props2.open);\n      if (\"close\" in $$props2) $$invalidate(2, close4 = $$props2.close);\n      if (\"header\" in $$props2) $$invalidate(3, header = $$props2.header);\n    };\n    $$self.$capture_state = () => ({\n      fragment: fragment2,\n      query: query2,\n      schemas,\n      records,\n      files,\n      date,\n      Await: Await_default,\n      Aside: Aside_default,\n      Icon: Icon_default,\n      Code: Code_default,\n      Input: input_default,\n      Checkbox: checkbox_default,\n      Textarea: textarea_default,\n      Select: select_default,\n      InputFile: file_default,\n      Json: json_default,\n      Markdown: markdown_default,\n      collection,\n      active: active2,\n      open,\n      close: close4,\n      header,\n      tabs,\n      activeTab,\n      recordID,\n      getRecord,\n      makeRecord,\n      resetRecord,\n      submitRecord,\n      setTab,\n      $query,\n      $schemas\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"collection\" in $$props2) $$invalidate(11, collection = $$props2.collection);\n      if (\"active\" in $$props2) $$invalidate(0, active2 = $$props2.active);\n      if (\"open\" in $$props2) $$invalidate(1, open = $$props2.open);\n      if (\"close\" in $$props2) $$invalidate(2, close4 = $$props2.close);\n      if (\"header\" in $$props2) $$invalidate(3, header = $$props2.header);\n      if (\"activeTab\" in $$props2) $$invalidate(4, activeTab = $$props2.activeTab);\n      if (\"recordID\" in $$props2) $$invalidate(5, recordID = $$props2.recordID);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      active2,\n      open,\n      close4,\n      header,\n      activeTab,\n      recordID,\n      tabs,\n      makeRecord,\n      resetRecord,\n      submitRecord,\n      setTab,\n      collection\n    ];\n  }\n  var Boolean_1, Object_13, file18, Record, record_default;\n  var init_record = __esm({\n    \"src/client/routes/data/record.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_markdown();\n      init_json();\n      init_file2();\n      init_select();\n      init_textarea();\n      init_checkbox();\n      init_input();\n      init_Code();\n      init_Icon();\n      init_Aside();\n      init_Await();\n      init_time();\n      init_files();\n      init_data();\n      init_src();\n      ({ Boolean: Boolean_1, Object: Object_13 } = globals);\n      file18 = \"src/client/routes/data/record.svelte\";\n      Record = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance19, create_fragment19, safe_not_equal, {\n            collection: 11,\n            active: 0,\n            open: 1,\n            close: 2,\n            header: 3\n          });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Record\",\n            options: options2,\n            id: create_fragment19.name\n          });\n        }\n        get collection() {\n          throw new Error(\"<Record>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set collection(value) {\n          throw new Error(\"<Record>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get active() {\n          throw new Error(\"<Record>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set active(value) {\n          throw new Error(\"<Record>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get open() {\n          throw new Error(\"<Record>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set open(value) {\n          throw new Error(\"<Record>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get close() {\n          throw new Error(\"<Record>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set close(value) {\n          throw new Error(\"<Record>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get header() {\n          throw new Error(\"<Record>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set header(value) {\n          throw new Error(\"<Record>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      record_default = Record;\n    }\n  });\n\n  // src/client/stores/schemas.ts\n  var SCHEMAS;\n  var init_schemas = __esm({\n    \"src/client/stores/schemas.ts\"() {\n      \"use strict\";\n      init_reload();\n      SCHEMAS = [\n        {\n          type: \"text\",\n          icon: \"type\",\n          opts: {\n            minlength: 0,\n            maxlength: 0,\n            pattern: \"e.g. ^\\\\w+$\"\n          }\n        },\n        {\n          type: \"textarea\",\n          icon: \"edit\",\n          opts: {\n            minlength: 0,\n            maxlength: 0\n          }\n        },\n        {\n          type: \"number\",\n          icon: \"hash\",\n          opts: {\n            min: 0,\n            max: 0\n          }\n        },\n        {\n          type: \"checkbox\",\n          icon: \"check-square\",\n          opts: {}\n        },\n        {\n          type: \"email\",\n          icon: \"at-sign\",\n          opts: {\n            pattern: \"e.g. ^.*\\\\.com$\",\n            placeholder: \"e@mail.com\"\n          }\n        },\n        {\n          type: \"url\",\n          icon: \"link\",\n          opts: {\n            pattern: \"e.g. ^https.*\\\\.com$\",\n            placeholder: \"https://domain.zone\"\n          }\n        },\n        {\n          type: \"tel\",\n          icon: \"phone\",\n          opts: {\n            pattern: \"e.g. ^\\\\d.*$\",\n            placeholder: \"+0-000-000-00-00\"\n          }\n        },\n        {\n          type: \"select\",\n          icon: \"list\",\n          opts: {\n            options: \"opt0, opt1, opt2...\",\n            size: 1\n          }\n        },\n        {\n          type: \"date\",\n          icon: \"calendar\",\n          opts: {\n            min: 0,\n            max: 0\n          }\n        },\n        {\n          type: \"time\",\n          icon: \"clock\",\n          opts: {\n            min: 0,\n            max: 0\n          }\n        },\n        {\n          type: \"file\",\n          icon: \"image\",\n          opts: {\n            maxFiles: 0,\n            maxSize: 0,\n            accept: \"e.g. .pdf, image/*, text/plain\"\n          }\n        },\n        {\n          type: \"json\",\n          icon: \"code\",\n          opts: {}\n        },\n        {\n          type: \"markdown\",\n          icon: \"file-text\",\n          opts: {}\n        }\n      ];\n    }\n  });\n\n  // fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/data/schema/schemas.esbuild-svelte-fake-css\n  var init_schemas2 = __esm({\n    \"fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/data/schema/schemas.esbuild-svelte-fake-css\"() {\n    }\n  });\n\n  // src/client/routes/data/schema/schemas.svelte\n  function get_each_context5(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[2] = list2[i].type;\n    child_ctx[3] = list2[i].icon;\n    child_ctx[5] = i;\n    return child_ctx;\n  }\n  function create_each_block5(ctx) {\n    let li;\n    let button;\n    let icon_1;\n    let t0;\n    let t1;\n    let button_id_value;\n    let t2;\n    let current;\n    let mounted;\n    let dispose;\n    icon_1 = new Icon_default({\n      props: { icon: (\n        /*icon*/\n        ctx[3]\n      ), color: \"gray\" },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        li = element(\"li\");\n        button = element(\"button\");\n        create_component(icon_1.$$.fragment);\n        t0 = space();\n        t1 = text(\n          /*type*/\n          ctx[2]\n        );\n        t2 = space();\n        attr_dev(button, \"id\", button_id_value = String(\n          /*i*/\n          ctx[5]\n        ));\n        attr_dev(button, \"type\", \"button\");\n        attr_dev(button, \"class\", \"block link outline\");\n        add_location(button, file19, 21, 12, 516);\n        add_location(li, file19, 20, 8, 499);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, li, anchor);\n        append_dev(li, button);\n        mount_component(icon_1, button, null);\n        append_dev(button, t0);\n        append_dev(button, t1);\n        append_dev(li, t2);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            button,\n            \"click\",\n            /*addField*/\n            ctx[0],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(li);\n        }\n        destroy_component(icon_1);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block5.name,\n      type: \"each\",\n      source: \"(16:4) {#each SCHEMAS as { type, icon }\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment20(ctx) {\n    let ul;\n    let current;\n    let each_value = ensure_array_like_dev(SCHEMAS);\n    let each_blocks = [];\n    for (let i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));\n    }\n    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {\n      each_blocks[i] = null;\n    });\n    const block2 = {\n      c: function create() {\n        ul = element(\"ul\");\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        attr_dev(ul, \"role\", \"listbox\");\n        attr_dev(ul, \"class\", \"cols svelte-14r8xoc\");\n        add_location(ul, file19, 18, 0, 417);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, ul, anchor);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(ul, null);\n          }\n        }\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (dirty & /*String, addField*/\n        1) {\n          each_value = ensure_array_like_dev(SCHEMAS);\n          let i;\n          for (i = 0; i < each_value.length; i += 1) {\n            const child_ctx = get_each_context5(ctx2, each_value, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n              transition_in(each_blocks[i], 1);\n            } else {\n              each_blocks[i] = create_each_block5(child_ctx);\n              each_blocks[i].c();\n              transition_in(each_blocks[i], 1);\n              each_blocks[i].m(ul, null);\n            }\n          }\n          group_outros();\n          for (i = each_value.length; i < each_blocks.length; i += 1) {\n            out(i);\n          }\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        for (let i = 0; i < each_value.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        current = true;\n      },\n      o: function outro(local) {\n        each_blocks = each_blocks.filter(Boolean);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(ul);\n        }\n        destroy_each(each_blocks, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment20.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance20($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Schemas\", slots, []);\n    let { open = false } = $$props;\n    function addField(e) {\n      const { id } = e.currentTarget;\n      const schema = SCHEMAS[Number(id)];\n      schemas.add([{ id: Date.now(), ...schema }]);\n      $$invalidate(1, open = false);\n    }\n    const writable_props = [\"open\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Schemas> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"open\" in $$props2) $$invalidate(1, open = $$props2.open);\n    };\n    $$self.$capture_state = () => ({ Icon: Icon_default, schemas, SCHEMAS, open, addField });\n    $$self.$inject_state = ($$props2) => {\n      if (\"open\" in $$props2) $$invalidate(1, open = $$props2.open);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [addField, open];\n  }\n  var file19, Schemas, schemas_default;\n  var init_schemas3 = __esm({\n    \"src/client/routes/data/schema/schemas.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_schemas();\n      init_data();\n      init_Icon();\n      init_schemas2();\n      file19 = \"src/client/routes/data/schema/schemas.svelte\";\n      Schemas = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance20, create_fragment20, safe_not_equal, { open: 1 });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Schemas\",\n            options: options2,\n            id: create_fragment20.name\n          });\n        }\n        get open() {\n          throw new Error(\"<Schemas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set open(value) {\n          throw new Error(\"<Schemas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      schemas_default = Schemas;\n    }\n  });\n\n  // src/client/components/Details.svelte\n  function create_fragment21(ctx) {\n    let details;\n    let summary;\n    let summary_aria_haspopup_value;\n    let summary_role_value;\n    let t;\n    let action_action;\n    let current;\n    let mounted;\n    let dispose;\n    const summary_slot_template = (\n      /*#slots*/\n      ctx[12].summary\n    );\n    const summary_slot = create_slot(\n      summary_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[11],\n      get_summary_slot_context\n    );\n    let summary_levels = [\n      { tabindex: \"0\" },\n      {\n        \"aria-haspopup\": summary_aria_haspopup_value = /*role*/\n        ctx[2] === \"list\" ? \"listbox\" : null\n      },\n      {\n        role: summary_role_value = /*button*/\n        ctx[4] ? \"button\" : null\n      },\n      { \"aria-disabled\": (\n        /*disabled*/\n        ctx[5]\n      ) },\n      /*$$restProps*/\n      ctx[10]\n    ];\n    let summary_data = {};\n    for (let i = 0; i < summary_levels.length; i += 1) {\n      summary_data = assign(summary_data, summary_levels[i]);\n    }\n    const default_slot_template = (\n      /*#slots*/\n      ctx[12].default\n    );\n    const default_slot = create_slot(\n      default_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[11],\n      null\n    );\n    const block2 = {\n      c: function create() {\n        details = element(\"details\");\n        summary = element(\"summary\");\n        if (summary_slot) summary_slot.c();\n        t = space();\n        if (default_slot) default_slot.c();\n        set_attributes(summary, summary_data);\n        toggle_class(\n          summary,\n          \"invalid\",\n          /*invalid*/\n          ctx[7]\n        );\n        add_location(summary, file20, 39, 4, 558);\n        attr_dev(\n          details,\n          \"id\",\n          /*id*/\n          ctx[1]\n        );\n        attr_dev(\n          details,\n          \"role\",\n          /*role*/\n          ctx[2]\n        );\n        attr_dev(details, \"tabindex\", \"0\");\n        attr_dev(\n          details,\n          \"draggable\",\n          /*draggable*/\n          ctx[6]\n        );\n        toggle_class(\n          details,\n          \"top\",\n          /*top*/\n          ctx[3]\n        );\n        toggle_class(\n          details,\n          \"bg-back\",\n          /*back*/\n          ctx[8]\n        );\n        add_location(details, file20, 28, 0, 409);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, details, anchor);\n        append_dev(details, summary);\n        if (summary_slot) {\n          summary_slot.m(summary, null);\n        }\n        append_dev(details, t);\n        if (default_slot) {\n          default_slot.m(details, null);\n        }\n        details.open = /*open*/\n        ctx[0];\n        current = true;\n        if (!mounted) {\n          dispose = [\n            listen_dev(\n              details,\n              \"toggle\",\n              /*details_toggle_handler*/\n              ctx[14]\n            ),\n            listen_dev(\n              details,\n              \"input\",\n              /*input_handler*/\n              ctx[13],\n              false,\n              false,\n              false,\n              false\n            ),\n            action_destroyer(action_action = /*action*/\n            ctx[9].call(null, details))\n          ];\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (summary_slot) {\n          if (summary_slot.p && (!current || dirty & /*$$scope*/\n          2048)) {\n            update_slot_base(\n              summary_slot,\n              summary_slot_template,\n              ctx2,\n              /*$$scope*/\n              ctx2[11],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx2[11]\n              ) : get_slot_changes(\n                summary_slot_template,\n                /*$$scope*/\n                ctx2[11],\n                dirty,\n                get_summary_slot_changes\n              ),\n              get_summary_slot_context\n            );\n          }\n        }\n        set_attributes(summary, summary_data = get_spread_update(summary_levels, [\n          { tabindex: \"0\" },\n          (!current || dirty & /*role*/\n          4 && summary_aria_haspopup_value !== (summary_aria_haspopup_value = /*role*/\n          ctx2[2] === \"list\" ? \"listbox\" : null)) && {\n            \"aria-haspopup\": summary_aria_haspopup_value\n          },\n          (!current || dirty & /*button*/\n          16 && summary_role_value !== (summary_role_value = /*button*/\n          ctx2[4] ? \"button\" : null)) && { role: summary_role_value },\n          (!current || dirty & /*disabled*/\n          32) && { \"aria-disabled\": (\n            /*disabled*/\n            ctx2[5]\n          ) },\n          dirty & /*$$restProps*/\n          1024 && /*$$restProps*/\n          ctx2[10]\n        ]));\n        toggle_class(\n          summary,\n          \"invalid\",\n          /*invalid*/\n          ctx2[7]\n        );\n        if (default_slot) {\n          if (default_slot.p && (!current || dirty & /*$$scope*/\n          2048)) {\n            update_slot_base(\n              default_slot,\n              default_slot_template,\n              ctx2,\n              /*$$scope*/\n              ctx2[11],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx2[11]\n              ) : get_slot_changes(\n                default_slot_template,\n                /*$$scope*/\n                ctx2[11],\n                dirty,\n                null\n              ),\n              null\n            );\n          }\n        }\n        if (!current || dirty & /*id*/\n        2) {\n          attr_dev(\n            details,\n            \"id\",\n            /*id*/\n            ctx2[1]\n          );\n        }\n        if (!current || dirty & /*role*/\n        4) {\n          attr_dev(\n            details,\n            \"role\",\n            /*role*/\n            ctx2[2]\n          );\n        }\n        if (!current || dirty & /*draggable*/\n        64) {\n          attr_dev(\n            details,\n            \"draggable\",\n            /*draggable*/\n            ctx2[6]\n          );\n        }\n        if (dirty & /*open*/\n        1) {\n          details.open = /*open*/\n          ctx2[0];\n        }\n        if (!current || dirty & /*top*/\n        8) {\n          toggle_class(\n            details,\n            \"top\",\n            /*top*/\n            ctx2[3]\n          );\n        }\n        if (!current || dirty & /*back*/\n        256) {\n          toggle_class(\n            details,\n            \"bg-back\",\n            /*back*/\n            ctx2[8]\n          );\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(summary_slot, local);\n        transition_in(default_slot, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(summary_slot, local);\n        transition_out(default_slot, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(details);\n        }\n        if (summary_slot) summary_slot.d(detaching);\n        if (default_slot) default_slot.d(detaching);\n        mounted = false;\n        run_all(dispose);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment21.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance21($$self, $$props, $$invalidate) {\n    const omit_props_names = [\n      \"id\",\n      \"role\",\n      \"top\",\n      \"open\",\n      \"button\",\n      \"disabled\",\n      \"draggable\",\n      \"invalid\",\n      \"back\",\n      \"action\"\n    ];\n    let $$restProps = compute_rest_props($$props, omit_props_names);\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Details\", slots, [\"summary\", \"default\"]);\n    let { id = \"\" } = $$props;\n    let { role = \"\" } = $$props;\n    let { top = false } = $$props;\n    let { open = false } = $$props;\n    let { button = false } = $$props;\n    let { disabled = false } = $$props;\n    let { draggable = false } = $$props;\n    let { invalid = false } = $$props;\n    let { back = false } = $$props;\n    let { action = (node) => {\n    } } = $$props;\n    function input_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    function details_toggle_handler() {\n      open = this.open;\n      $$invalidate(0, open);\n    }\n    $$self.$$set = ($$new_props) => {\n      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));\n      $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));\n      if (\"id\" in $$new_props) $$invalidate(1, id = $$new_props.id);\n      if (\"role\" in $$new_props) $$invalidate(2, role = $$new_props.role);\n      if (\"top\" in $$new_props) $$invalidate(3, top = $$new_props.top);\n      if (\"open\" in $$new_props) $$invalidate(0, open = $$new_props.open);\n      if (\"button\" in $$new_props) $$invalidate(4, button = $$new_props.button);\n      if (\"disabled\" in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);\n      if (\"draggable\" in $$new_props) $$invalidate(6, draggable = $$new_props.draggable);\n      if (\"invalid\" in $$new_props) $$invalidate(7, invalid = $$new_props.invalid);\n      if (\"back\" in $$new_props) $$invalidate(8, back = $$new_props.back);\n      if (\"action\" in $$new_props) $$invalidate(9, action = $$new_props.action);\n      if (\"$$scope\" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);\n    };\n    $$self.$capture_state = () => ({\n      id,\n      role,\n      top,\n      open,\n      button,\n      disabled,\n      draggable,\n      invalid,\n      back,\n      action\n    });\n    $$self.$inject_state = ($$new_props) => {\n      if (\"id\" in $$props) $$invalidate(1, id = $$new_props.id);\n      if (\"role\" in $$props) $$invalidate(2, role = $$new_props.role);\n      if (\"top\" in $$props) $$invalidate(3, top = $$new_props.top);\n      if (\"open\" in $$props) $$invalidate(0, open = $$new_props.open);\n      if (\"button\" in $$props) $$invalidate(4, button = $$new_props.button);\n      if (\"disabled\" in $$props) $$invalidate(5, disabled = $$new_props.disabled);\n      if (\"draggable\" in $$props) $$invalidate(6, draggable = $$new_props.draggable);\n      if (\"invalid\" in $$props) $$invalidate(7, invalid = $$new_props.invalid);\n      if (\"back\" in $$props) $$invalidate(8, back = $$new_props.back);\n      if (\"action\" in $$props) $$invalidate(9, action = $$new_props.action);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      open,\n      id,\n      role,\n      top,\n      button,\n      disabled,\n      draggable,\n      invalid,\n      back,\n      action,\n      $$restProps,\n      $$scope,\n      slots,\n      input_handler,\n      details_toggle_handler\n    ];\n  }\n  var file20, get_summary_slot_changes, get_summary_slot_context, Details, Details_default;\n  var init_Details = __esm({\n    \"src/client/components/Details.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      file20 = \"src/client/components/Details.svelte\";\n      get_summary_slot_changes = (dirty) => ({});\n      get_summary_slot_context = (ctx) => ({});\n      Details = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance21, create_fragment21, safe_not_equal, {\n            id: 1,\n            role: 2,\n            top: 3,\n            open: 0,\n            button: 4,\n            disabled: 5,\n            draggable: 6,\n            invalid: 7,\n            back: 8,\n            action: 9\n          });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Details\",\n            options: options2,\n            id: create_fragment21.name\n          });\n        }\n        get id() {\n          throw new Error(\"<Details>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set id(value) {\n          throw new Error(\"<Details>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get role() {\n          throw new Error(\"<Details>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set role(value) {\n          throw new Error(\"<Details>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get top() {\n          throw new Error(\"<Details>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set top(value) {\n          throw new Error(\"<Details>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get open() {\n          throw new Error(\"<Details>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set open(value) {\n          throw new Error(\"<Details>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get button() {\n          throw new Error(\"<Details>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set button(value) {\n          throw new Error(\"<Details>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get disabled() {\n          throw new Error(\"<Details>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set disabled(value) {\n          throw new Error(\"<Details>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get draggable() {\n          throw new Error(\"<Details>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set draggable(value) {\n          throw new Error(\"<Details>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get invalid() {\n          throw new Error(\"<Details>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set invalid(value) {\n          throw new Error(\"<Details>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get back() {\n          throw new Error(\"<Details>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set back(value) {\n          throw new Error(\"<Details>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get action() {\n          throw new Error(\"<Details>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set action(value) {\n          throw new Error(\"<Details>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      Details_default = Details;\n    }\n  });\n\n  // src/client/routes/data/schema/field.svelte\n  function get_each_context6(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[13] = list2[i][0];\n    child_ctx[14] = list2[i][1];\n    return child_ctx;\n  }\n  function create_if_block9(ctx) {\n    let each_1_anchor;\n    let each_value = ensure_array_like_dev(Object.entries(\n      /*field*/\n      ctx[1].opts\n    ));\n    let each_blocks = [];\n    for (let i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));\n    }\n    const block2 = {\n      c: function create() {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        each_1_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(target, anchor);\n          }\n        }\n        insert_dev(target, each_1_anchor, anchor);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*field, Object*/\n        2) {\n          each_value = ensure_array_like_dev(Object.entries(\n            /*field*/\n            ctx2[1].opts\n          ));\n          let i;\n          for (i = 0; i < each_value.length; i += 1) {\n            const child_ctx = get_each_context6(ctx2, each_value, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n            } else {\n              each_blocks[i] = create_each_block6(child_ctx);\n              each_blocks[i].c();\n              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n          for (; i < each_blocks.length; i += 1) {\n            each_blocks[i].d(1);\n          }\n          each_blocks.length = each_value.length;\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(each_1_anchor);\n        }\n        destroy_each(each_blocks, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block9.name,\n      type: \"if\",\n      source: \"(108:12) {#if field.opts}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block6(ctx) {\n    let label;\n    let small;\n    let t0_value = (\n      /*name*/\n      ctx[13] + \"\"\n    );\n    let t0;\n    let t1;\n    let input;\n    let attributes_action;\n    let t2;\n    let mounted;\n    let dispose;\n    const block2 = {\n      c: function create() {\n        label = element(\"label\");\n        small = element(\"small\");\n        t0 = text(t0_value);\n        t1 = space();\n        input = element(\"input\");\n        t2 = space();\n        add_location(small, file21, 127, 24, 3299);\n        add_location(input, file21, 128, 24, 3345);\n        add_location(label, file21, 126, 20, 3267);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, label, anchor);\n        append_dev(label, small);\n        append_dev(small, t0);\n        append_dev(label, t1);\n        append_dev(label, input);\n        append_dev(label, t2);\n        if (!mounted) {\n          dispose = action_destroyer(attributes_action = attributes.call(null, input, {\n            type: (\n              /*field*/\n              ctx[1].type\n            ),\n            name: (\n              /*name*/\n              ctx[13]\n            ),\n            value: (\n              /*value*/\n              ctx[14]\n            )\n          }));\n          mounted = true;\n        }\n      },\n      p: function update2(new_ctx, dirty) {\n        ctx = new_ctx;\n        if (dirty & /*field*/\n        2 && t0_value !== (t0_value = /*name*/\n        ctx[13] + \"\")) set_data_dev(t0, t0_value);\n        if (attributes_action && is_function(attributes_action.update) && dirty & /*field*/\n        2) attributes_action.update.call(null, {\n          type: (\n            /*field*/\n            ctx[1].type\n          ),\n          name: (\n            /*name*/\n            ctx[13]\n          ),\n          value: (\n            /*value*/\n            ctx[14]\n          )\n        });\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(label);\n        }\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block6.name,\n      type: \"each\",\n      source: \"(109:16) {#each Object.entries(field.opts) as [name, value]}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot_1(ctx) {\n    let fieldset0;\n    let label0;\n    let input0;\n    let input0_value_value;\n    let t0;\n    let label1;\n    let input1;\n    let input1_value_value;\n    let t1;\n    let fieldset1;\n    let t2;\n    let fieldset2;\n    let nav0;\n    let label2;\n    let input2;\n    let input2_checked_value;\n    let t3;\n    let t4;\n    let nav1;\n    let button0;\n    let icon0;\n    let t5;\n    let button1;\n    let icon1;\n    let button1_disabled_value;\n    let current;\n    let if_block = (\n      /*field*/\n      ctx[1].opts && create_if_block9(ctx)\n    );\n    icon0 = new Icon_default({ props: { icon: \"trash\" }, $$inline: true });\n    icon1 = new Icon_default({ props: { icon: \"save\" }, $$inline: true });\n    const block2 = {\n      c: function create() {\n        fieldset0 = element(\"fieldset\");\n        label0 = element(\"label\");\n        input0 = element(\"input\");\n        t0 = space();\n        label1 = element(\"label\");\n        input1 = element(\"input\");\n        t1 = space();\n        fieldset1 = element(\"fieldset\");\n        if (if_block) if_block.c();\n        t2 = space();\n        fieldset2 = element(\"fieldset\");\n        nav0 = element(\"nav\");\n        label2 = element(\"label\");\n        input2 = element(\"input\");\n        t3 = text(\" Required\");\n        t4 = space();\n        nav1 = element(\"nav\");\n        button0 = element(\"button\");\n        create_component(icon0.$$.fragment);\n        t5 = space();\n        button1 = element(\"button\");\n        create_component(icon1.$$.fragment);\n        attr_dev(input0, \"type\", \"hidden\");\n        attr_dev(input0, \"name\", \"type\");\n        input0.value = input0_value_value = /*field*/\n        ctx[1].type;\n        add_location(input0, file21, 116, 16, 2887);\n        add_location(label0, file21, 115, 12, 2863);\n        attr_dev(input1, \"type\", \"hidden\");\n        attr_dev(input1, \"name\", \"name\");\n        input1.value = input1_value_value = /*field*/\n        ctx[1].name;\n        add_location(input1, file21, 119, 16, 2999);\n        add_location(label1, file21, 118, 12, 2975);\n        attr_dev(fieldset0, \"class\", \"hidden\");\n        add_location(fieldset0, file21, 114, 8, 2825);\n        attr_dev(fieldset1, \"class\", \"cols\");\n        attr_dev(fieldset1, \"name\", \"opts\");\n        attr_dev(fieldset1, \"id\", \"opts\");\n        add_location(fieldset1, file21, 123, 8, 3104);\n        attr_dev(input2, \"name\", \"required\");\n        attr_dev(input2, \"type\", \"checkbox\");\n        attr_dev(input2, \"role\", \"switch\");\n        input2.checked = input2_checked_value = /*field*/\n        ctx[1].required;\n        add_location(input2, file21, 143, 20, 3829);\n        add_location(label2, file21, 142, 16, 3801);\n        attr_dev(nav0, \"class\", \"cols\");\n        add_location(nav0, file21, 141, 12, 3766);\n        attr_dev(button0, \"type\", \"reset\");\n        attr_dev(button0, \"class\", \"link box text-error\");\n        add_location(button0, file21, 153, 16, 4135);\n        attr_dev(button1, \"type\", \"submit\");\n        attr_dev(button1, \"class\", \"link box text-success\");\n        button1.disabled = button1_disabled_value = !/*valid*/\n        ctx[2] || /*field*/\n        ctx[1].valid;\n        add_location(button1, file21, 156, 16, 4269);\n        attr_dev(nav1, \"class\", \"cols col-fit\");\n        add_location(nav1, file21, 152, 12, 4092);\n        attr_dev(fieldset2, \"class\", \"cols col-fit align-center\");\n        attr_dev(fieldset2, \"name\", \"custom\");\n        attr_dev(fieldset2, \"id\", \"custom\");\n        add_location(fieldset2, file21, 140, 8, 3683);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, fieldset0, anchor);\n        append_dev(fieldset0, label0);\n        append_dev(label0, input0);\n        append_dev(fieldset0, t0);\n        append_dev(fieldset0, label1);\n        append_dev(label1, input1);\n        insert_dev(target, t1, anchor);\n        insert_dev(target, fieldset1, anchor);\n        if (if_block) if_block.m(fieldset1, null);\n        insert_dev(target, t2, anchor);\n        insert_dev(target, fieldset2, anchor);\n        append_dev(fieldset2, nav0);\n        append_dev(nav0, label2);\n        append_dev(label2, input2);\n        append_dev(label2, t3);\n        append_dev(fieldset2, t4);\n        append_dev(fieldset2, nav1);\n        append_dev(nav1, button0);\n        mount_component(icon0, button0, null);\n        append_dev(nav1, t5);\n        append_dev(nav1, button1);\n        mount_component(icon1, button1, null);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (!current || dirty & /*field*/\n        2 && input0_value_value !== (input0_value_value = /*field*/\n        ctx2[1].type)) {\n          prop_dev(input0, \"value\", input0_value_value);\n        }\n        if (!current || dirty & /*field*/\n        2 && input1_value_value !== (input1_value_value = /*field*/\n        ctx2[1].name)) {\n          prop_dev(input1, \"value\", input1_value_value);\n        }\n        if (\n          /*field*/\n          ctx2[1].opts\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n          } else {\n            if_block = create_if_block9(ctx2);\n            if_block.c();\n            if_block.m(fieldset1, null);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n        if (!current || dirty & /*field*/\n        2 && input2_checked_value !== (input2_checked_value = /*field*/\n        ctx2[1].required)) {\n          prop_dev(input2, \"checked\", input2_checked_value);\n        }\n        if (!current || dirty & /*valid, field*/\n        6 && button1_disabled_value !== (button1_disabled_value = !/*valid*/\n        ctx2[2] || /*field*/\n        ctx2[1].valid)) {\n          prop_dev(button1, \"disabled\", button1_disabled_value);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon0.$$.fragment, local);\n        transition_in(icon1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon0.$$.fragment, local);\n        transition_out(icon1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(fieldset0);\n          detach_dev(t1);\n          detach_dev(fieldset1);\n          detach_dev(t2);\n          detach_dev(fieldset2);\n        }\n        if (if_block) if_block.d();\n        destroy_component(icon0);\n        destroy_component(icon1);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot_1.name,\n      type: \"slot\",\n      source: '(91:4) <Form         id={String(field.id)}         method=\\\\\"POST\\\\\"         on:submit={save}         on:reset={del}         bind:valid     >',\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot6(ctx) {\n    let form;\n    let updating_valid;\n    let current;\n    function form_valid_binding(value) {\n      ctx[10](value);\n    }\n    let form_props = {\n      id: String(\n        /*field*/\n        ctx[1].id\n      ),\n      method: \"POST\",\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    };\n    if (\n      /*valid*/\n      ctx[2] !== void 0\n    ) {\n      form_props.valid = /*valid*/\n      ctx[2];\n    }\n    form = new Form_default({ props: form_props, $$inline: true });\n    binding_callbacks.push(() => bind(form, \"valid\", form_valid_binding));\n    form.$on(\n      \"submit\",\n      /*save*/\n      ctx[6]\n    );\n    form.$on(\n      \"reset\",\n      /*del*/\n      ctx[7]\n    );\n    const block2 = {\n      c: function create() {\n        create_component(form.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(form, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const form_changes = {};\n        if (dirty & /*field*/\n        2) form_changes.id = String(\n          /*field*/\n          ctx2[1].id\n        );\n        if (dirty & /*$$scope, valid, field*/\n        131078) {\n          form_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        if (!updating_valid && dirty & /*valid*/\n        4) {\n          updating_valid = true;\n          form_changes.valid = /*valid*/\n          ctx2[2];\n          add_flush_callback(() => updating_valid = false);\n        }\n        form.$set(form_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(form.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(form.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(form, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot6.name,\n      type: \"slot\",\n      source: '(65:0) <Details     {id}     bind:open     draggable={!open}     on:input={invalidate}     invalid={!valid || !field.valid}     class=\\\\\"block\\\\\"     button={!open}     action={dnd}     back >',\n      ctx\n    });\n    return block2;\n  }\n  function create_summary_slot(ctx) {\n    let icon;\n    let t;\n    let input;\n    let input_pattern_value;\n    let input_placeholder_value;\n    let input_form_value;\n    let current;\n    let mounted;\n    let dispose;\n    icon = new Icon_default({\n      props: {\n        icon: (\n          /*field*/\n          ctx[1].icon\n        ),\n        color: \"gray\"\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(icon.$$.fragment);\n        t = space();\n        input = element(\"input\");\n        input.required = true;\n        attr_dev(input, \"type\", \"text\");\n        input.autofocus = /*open*/\n        ctx[0];\n        attr_dev(input, \"pattern\", input_pattern_value = !/*field*/\n        ctx[1].name ? `(?!^${/*$schemaNames*/\n        ctx[4].join(\"$|^\")}$)[\\\\w|\\\\-]+` : `^[\\\\w|\\\\-]+$`);\n        attr_dev(input, \"placeholder\", input_placeholder_value = /*field*/\n        ctx[1].type);\n        attr_dev(input, \"form\", input_form_value = String(\n          /*field*/\n          ctx[1].id\n        ));\n        add_location(input, file21, 94, 8, 2326);\n      },\n      m: function mount(target, anchor) {\n        mount_component(icon, target, anchor);\n        insert_dev(target, t, anchor);\n        insert_dev(target, input, anchor);\n        set_input_value(\n          input,\n          /*field*/\n          ctx[1].name\n        );\n        current = true;\n        if (\n          /*open*/\n          ctx[0]\n        ) input.focus();\n        if (!mounted) {\n          dispose = listen_dev(\n            input,\n            \"input\",\n            /*input_input_handler*/\n            ctx[9]\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        const icon_changes = {};\n        if (dirty & /*field*/\n        2) icon_changes.icon = /*field*/\n        ctx2[1].icon;\n        icon.$set(icon_changes);\n        if (!current || dirty & /*open*/\n        1) {\n          prop_dev(\n            input,\n            \"autofocus\",\n            /*open*/\n            ctx2[0]\n          );\n        }\n        if (!current || dirty & /*field, $schemaNames*/\n        18 && input_pattern_value !== (input_pattern_value = !/*field*/\n        ctx2[1].name ? `(?!^${/*$schemaNames*/\n        ctx2[4].join(\"$|^\")}$)[\\\\w|\\\\-]+` : `^[\\\\w|\\\\-]+$`)) {\n          attr_dev(input, \"pattern\", input_pattern_value);\n        }\n        if (!current || dirty & /*field*/\n        2 && input_placeholder_value !== (input_placeholder_value = /*field*/\n        ctx2[1].type)) {\n          attr_dev(input, \"placeholder\", input_placeholder_value);\n        }\n        if (!current || dirty & /*field*/\n        2 && input_form_value !== (input_form_value = String(\n          /*field*/\n          ctx2[1].id\n        ))) {\n          attr_dev(input, \"form\", input_form_value);\n        }\n        if (dirty & /*field*/\n        2 && input.value !== /*field*/\n        ctx2[1].name) {\n          set_input_value(\n            input,\n            /*field*/\n            ctx2[1].name\n          );\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(t);\n          detach_dev(input);\n        }\n        destroy_component(icon, detaching);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_summary_slot.name,\n      type: \"slot\",\n      source: '(76:4) <svelte:fragment slot=\\\\\"summary\\\\\">',\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment22(ctx) {\n    let details;\n    let updating_open;\n    let current;\n    function details_open_binding(value) {\n      ctx[11](value);\n    }\n    let details_props = {\n      id: (\n        /*id*/\n        ctx[3]\n      ),\n      draggable: !/*open*/\n      ctx[0],\n      invalid: !/*valid*/\n      ctx[2] || !/*field*/\n      ctx[1].valid,\n      class: \"block\",\n      button: !/*open*/\n      ctx[0],\n      action: (\n        /*dnd*/\n        ctx[8]\n      ),\n      back: true,\n      $$slots: {\n        summary: [create_summary_slot],\n        default: [create_default_slot6]\n      },\n      $$scope: { ctx }\n    };\n    if (\n      /*open*/\n      ctx[0] !== void 0\n    ) {\n      details_props.open = /*open*/\n      ctx[0];\n    }\n    details = new Details_default({ props: details_props, $$inline: true });\n    binding_callbacks.push(() => bind(details, \"open\", details_open_binding));\n    details.$on(\n      \"input\",\n      /*invalidate*/\n      ctx[5]\n    );\n    const block2 = {\n      c: function create() {\n        create_component(details.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(details, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const details_changes = {};\n        if (dirty & /*id*/\n        8) details_changes.id = /*id*/\n        ctx2[3];\n        if (dirty & /*open*/\n        1) details_changes.draggable = !/*open*/\n        ctx2[0];\n        if (dirty & /*valid, field*/\n        6) details_changes.invalid = !/*valid*/\n        ctx2[2] || !/*field*/\n        ctx2[1].valid;\n        if (dirty & /*open*/\n        1) details_changes.button = !/*open*/\n        ctx2[0];\n        if (dirty & /*$$scope, open, field, $schemaNames, valid*/\n        131095) {\n          details_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        if (!updating_open && dirty & /*open*/\n        1) {\n          updating_open = true;\n          details_changes.open = /*open*/\n          ctx2[0];\n          add_flush_callback(() => updating_open = false);\n        }\n        details.$set(details_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(details.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(details.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(details, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment22.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function attributes(input, opt) {\n    const { type, name: name2, value } = opt;\n    const schema = SCHEMAS.find((s2) => s2.type === opt.type);\n    const def2 = schema?.opts?.[name2];\n    const typeDate = \"date, time, datetime-local\".includes(type);\n    const inputType = (value2) => value2 && !isNaN(Number(value2)) ? \"number\" : \"text\";\n    input.name = name2;\n    input.type = typeDate ? type : inputType(String(def2));\n    input.placeholder = String(def2);\n    input.value = value === def2 ? \"\" : value;\n  }\n  function instance22($$self, $$props, $$invalidate) {\n    let $schemaNames;\n    validate_store(schemaNames, \"schemaNames\");\n    component_subscribe($$self, schemaNames, ($$value) => $$invalidate(4, $schemaNames = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Field\", slots, []);\n    let { id = \"\" } = $$props;\n    let { open } = $$props;\n    let { field } = $$props;\n    let { valid = false } = $$props;\n    let prevName = field.name;\n    function invalidate() {\n      schemas.invalidate(field.id);\n    }\n    function save(e) {\n      const data = new FormData(e.currentTarget);\n      const entries = Object.fromEntries(data);\n      const { type, name: name2, required, ...opts } = entries;\n      for (const key in opts) {\n        const value = opts[key];\n        opts[key] = value && Number(value) || value;\n      }\n      Object.assign(field, { prevName, required, opts });\n      prevName = field.name;\n      schemas.save(field);\n    }\n    function del4() {\n      schemas.delete(field.id);\n    }\n    function dnd(de) {\n      de.ondragstart = (e) => {\n        e.dataTransfer?.clearData();\n        e.dataTransfer?.setData(\"fieldID\", id);\n      };\n      de.ondragover = (e) => {\n        e.preventDefault();\n        de.focus();\n      };\n      de.ondragleave = (e) => de.blur();\n      de.ondrop = async (e) => {\n        const { dataTransfer, currentTarget } = e;\n        const { id: to } = currentTarget;\n        const from = dataTransfer?.getData(\"fieldID\");\n        if (from !== to) {\n          schemas.move(Number(from), Number(to));\n        }\n        de.blur();\n      };\n    }\n    $$self.$$.on_mount.push(function() {\n      if (open === void 0 && !(\"open\" in $$props || $$self.$$.bound[$$self.$$.props[\"open\"]])) {\n        console.warn(\"<Field> was created without expected prop 'open'\");\n      }\n      if (field === void 0 && !(\"field\" in $$props || $$self.$$.bound[$$self.$$.props[\"field\"]])) {\n        console.warn(\"<Field> was created without expected prop 'field'\");\n      }\n    });\n    const writable_props = [\"id\", \"open\", \"field\", \"valid\"];\n    Object_14.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Field> was created with unknown prop '${key}'`);\n    });\n    function input_input_handler() {\n      field.name = this.value;\n      $$invalidate(1, field);\n    }\n    function form_valid_binding(value) {\n      valid = value;\n      $$invalidate(2, valid);\n    }\n    function details_open_binding(value) {\n      open = value;\n      $$invalidate(0, open);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"id\" in $$props2) $$invalidate(3, id = $$props2.id);\n      if (\"open\" in $$props2) $$invalidate(0, open = $$props2.open);\n      if (\"field\" in $$props2) $$invalidate(1, field = $$props2.field);\n      if (\"valid\" in $$props2) $$invalidate(2, valid = $$props2.valid);\n    };\n    $$self.$capture_state = () => ({\n      schemas,\n      schemaNames,\n      SCHEMAS,\n      Form: Form_default,\n      Icon: Icon_default,\n      Details: Details_default,\n      id,\n      open,\n      field,\n      valid,\n      prevName,\n      attributes,\n      invalidate,\n      save,\n      del: del4,\n      dnd,\n      $schemaNames\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"id\" in $$props2) $$invalidate(3, id = $$props2.id);\n      if (\"open\" in $$props2) $$invalidate(0, open = $$props2.open);\n      if (\"field\" in $$props2) $$invalidate(1, field = $$props2.field);\n      if (\"valid\" in $$props2) $$invalidate(2, valid = $$props2.valid);\n      if (\"prevName\" in $$props2) prevName = $$props2.prevName;\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      open,\n      field,\n      valid,\n      id,\n      $schemaNames,\n      invalidate,\n      save,\n      del4,\n      dnd,\n      input_input_handler,\n      form_valid_binding,\n      details_open_binding\n    ];\n  }\n  var Object_14, file21, Field, field_default;\n  var init_field = __esm({\n    \"src/client/routes/data/schema/field.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Details();\n      init_Icon();\n      init_Form();\n      init_schemas();\n      init_data();\n      ({ Object: Object_14 } = globals);\n      file21 = \"src/client/routes/data/schema/field.svelte\";\n      Field = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance22, create_fragment22, safe_not_equal, { id: 3, open: 0, field: 1, valid: 2 });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Field\",\n            options: options2,\n            id: create_fragment22.name\n          });\n        }\n        get id() {\n          throw new Error(\"<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set id(value) {\n          throw new Error(\"<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get open() {\n          throw new Error(\"<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set open(value) {\n          throw new Error(\"<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get field() {\n          throw new Error(\"<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set field(value) {\n          throw new Error(\"<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get valid() {\n          throw new Error(\"<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set valid(value) {\n          throw new Error(\"<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      field_default = Field;\n    }\n  });\n\n  // fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/data/schema/fields.esbuild-svelte-fake-css\n  var init_fields = __esm({\n    \"fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/data/schema/fields.esbuild-svelte-fake-css\"() {\n    }\n  });\n\n  // src/client/routes/data/schema/fields.svelte\n  function get_each_context7(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[12] = list2[i];\n    child_ctx[14] = i;\n    return child_ctx;\n  }\n  function get_each_context_14(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[15] = list2[i];\n    return child_ctx;\n  }\n  function create_each_block_14(ctx) {\n    let button;\n    let t0_value = (\n      /*tab*/\n      ctx[15] + \"\"\n    );\n    let t0;\n    let t1;\n    let button_id_value;\n    let button_disabled_value;\n    let mounted;\n    let dispose;\n    const block2 = {\n      c: function create() {\n        button = element(\"button\");\n        t0 = text(t0_value);\n        t1 = space();\n        attr_dev(button, \"id\", button_id_value = /*tab*/\n        ctx[15]);\n        attr_dev(button, \"type\", \"button\");\n        button.disabled = button_disabled_value = /*activeTab*/\n        ctx[4] === /*tab*/\n        ctx[15];\n        add_location(button, file22, 52, 12, 1277);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, button, anchor);\n        append_dev(button, t0);\n        append_dev(button, t1);\n        if (!mounted) {\n          dispose = listen_dev(\n            button,\n            \"click\",\n            /*setTab*/\n            ctx[8],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*activeTab*/\n        16 && button_disabled_value !== (button_disabled_value = /*activeTab*/\n        ctx2[4] === /*tab*/\n        ctx2[15])) {\n          prop_dev(button, \"disabled\", button_disabled_value);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(button);\n        }\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block_14.name,\n      type: \"each\",\n      source: \"(47:8) {#each tabs as tab}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_15(ctx) {\n    let fieldset;\n    let label0;\n    let small0;\n    let t1;\n    let input0;\n    let t2;\n    let label1;\n    let small1;\n    let t4;\n    let input1;\n    let t5;\n    let label2;\n    let small2;\n    let t7;\n    let input2;\n    let t8;\n    let label3;\n    let small3;\n    let t10;\n    let input3;\n    let t11;\n    let label4;\n    let small4;\n    let t13;\n    let input4;\n    const block2 = {\n      c: function create() {\n        fieldset = element(\"fieldset\");\n        label0 = element(\"label\");\n        small0 = element(\"small\");\n        small0.textContent = \"List/Search\";\n        t1 = space();\n        input0 = element(\"input\");\n        t2 = space();\n        label1 = element(\"label\");\n        small1 = element(\"small\");\n        small1.textContent = \"View\";\n        t4 = space();\n        input1 = element(\"input\");\n        t5 = space();\n        label2 = element(\"label\");\n        small2 = element(\"small\");\n        small2.textContent = \"Create\";\n        t7 = space();\n        input2 = element(\"input\");\n        t8 = space();\n        label3 = element(\"label\");\n        small3 = element(\"small\");\n        small3.textContent = \"Update\";\n        t10 = space();\n        input3 = element(\"input\");\n        t11 = space();\n        label4 = element(\"label\");\n        small4 = element(\"small\");\n        small4.textContent = \"Delete\";\n        t13 = space();\n        input4 = element(\"input\");\n        add_location(small0, file22, 90, 16, 2347);\n        attr_dev(input0, \"placeholder\", \"List/Search\");\n        add_location(input0, file22, 91, 16, 2390);\n        add_location(label0, file22, 89, 12, 2323);\n        add_location(small1, file22, 94, 16, 2483);\n        attr_dev(input1, \"placeholder\", \"View\");\n        add_location(input1, file22, 95, 16, 2519);\n        add_location(label1, file22, 93, 12, 2459);\n        add_location(small2, file22, 98, 16, 2605);\n        attr_dev(input2, \"placeholder\", \"Create\");\n        add_location(input2, file22, 99, 16, 2643);\n        add_location(label2, file22, 97, 12, 2581);\n        add_location(small3, file22, 102, 16, 2731);\n        attr_dev(input3, \"placeholder\", \"Update\");\n        add_location(input3, file22, 103, 16, 2769);\n        add_location(label3, file22, 101, 12, 2707);\n        add_location(small4, file22, 106, 16, 2857);\n        attr_dev(input4, \"placeholder\", \"Delete\");\n        add_location(input4, file22, 107, 16, 2895);\n        add_location(label4, file22, 105, 12, 2833);\n        attr_dev(fieldset, \"class\", \"cols column svelte-1digiow\");\n        add_location(fieldset, file22, 88, 8, 2280);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, fieldset, anchor);\n        append_dev(fieldset, label0);\n        append_dev(label0, small0);\n        append_dev(label0, t1);\n        append_dev(label0, input0);\n        append_dev(fieldset, t2);\n        append_dev(fieldset, label1);\n        append_dev(label1, small1);\n        append_dev(label1, t4);\n        append_dev(label1, input1);\n        append_dev(fieldset, t5);\n        append_dev(fieldset, label2);\n        append_dev(label2, small2);\n        append_dev(label2, t7);\n        append_dev(label2, input2);\n        append_dev(fieldset, t8);\n        append_dev(fieldset, label3);\n        append_dev(label3, small3);\n        append_dev(label3, t10);\n        append_dev(label3, input3);\n        append_dev(fieldset, t11);\n        append_dev(fieldset, label4);\n        append_dev(label4, small4);\n        append_dev(label4, t13);\n        append_dev(label4, input4);\n      },\n      p: noop,\n      i: noop,\n      o: noop,\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(fieldset);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_15.name,\n      type: \"if\",\n      source: \"(83:36) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block10(ctx) {\n    let each_blocks = [];\n    let each_1_lookup = /* @__PURE__ */ new Map();\n    let t;\n    let nav;\n    let details;\n    let updating_open;\n    let current;\n    let each_value = ensure_array_like_dev(\n      /*$schemas*/\n      ctx[5]\n    );\n    const get_key = (ctx2) => (\n      /*field*/\n      ctx2[12].id\n    );\n    validate_each_keys(ctx, each_value, get_each_context7, get_key);\n    for (let i = 0; i < each_value.length; i += 1) {\n      let child_ctx = get_each_context7(ctx, each_value, i);\n      let key = get_key(child_ctx);\n      each_1_lookup.set(key, each_blocks[i] = create_each_block7(key, child_ctx));\n    }\n    function details_open_binding(value) {\n      ctx[11](value);\n    }\n    let details_props = {\n      disabled: !/*valid*/\n      ctx[0] || !isNaN(Number(\n        /*$schemaInvalID*/\n        ctx[6]\n      )),\n      class: \"block clear\",\n      back: (\n        /*open*/\n        ctx[3]\n      ),\n      button: true,\n      $$slots: {\n        summary: [create_summary_slot2],\n        default: [create_default_slot7]\n      },\n      $$scope: { ctx }\n    };\n    if (\n      /*open*/\n      ctx[3] !== void 0\n    ) {\n      details_props.open = /*open*/\n      ctx[3];\n    }\n    details = new Details_default({ props: details_props, $$inline: true });\n    binding_callbacks.push(() => bind(details, \"open\", details_open_binding));\n    const block2 = {\n      c: function create() {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        t = space();\n        nav = element(\"nav\");\n        create_component(details.$$.fragment);\n        add_location(nav, file22, 72, 8, 1782);\n      },\n      m: function mount(target, anchor) {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(target, anchor);\n          }\n        }\n        insert_dev(target, t, anchor);\n        insert_dev(target, nav, anchor);\n        mount_component(details, nav, null);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*$schemas, String, $schemaInvalID, valid*/\n        97) {\n          each_value = ensure_array_like_dev(\n            /*$schemas*/\n            ctx2[5]\n          );\n          group_outros();\n          validate_each_keys(ctx2, each_value, get_each_context7, get_key);\n          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t.parentNode, outro_and_destroy_block, create_each_block7, t, get_each_context7);\n          check_outros();\n        }\n        const details_changes = {};\n        if (dirty & /*valid, $schemaInvalID*/\n        65) details_changes.disabled = !/*valid*/\n        ctx2[0] || !isNaN(Number(\n          /*$schemaInvalID*/\n          ctx2[6]\n        ));\n        if (dirty & /*open*/\n        8) details_changes.back = /*open*/\n        ctx2[3];\n        if (dirty & /*$$scope, open*/\n        262152) {\n          details_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        if (!updating_open && dirty & /*open*/\n        8) {\n          updating_open = true;\n          details_changes.open = /*open*/\n          ctx2[3];\n          add_flush_callback(() => updating_open = false);\n        }\n        details.$set(details_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        for (let i = 0; i < each_value.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        transition_in(details.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        transition_out(details.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(t);\n          detach_dev(nav);\n        }\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].d(detaching);\n        }\n        destroy_component(details);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block10.name,\n      type: \"if\",\n      source: '(59:4) {#if activeTab === \\\\\"Fields\\\\\"}',\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block7(key_1, ctx) {\n    let first;\n    let field_1;\n    let updating_valid;\n    let current;\n    function field_1_valid_binding(value) {\n      ctx[9](value);\n    }\n    let field_1_props = {\n      field: (\n        /*field*/\n        ctx[12]\n      ),\n      id: String(\n        /*id*/\n        ctx[14]\n      ),\n      open: (\n        /*field*/\n        ctx[12].id === /*$schemaInvalID*/\n        ctx[6]\n      )\n    };\n    if (\n      /*valid*/\n      ctx[0] !== void 0\n    ) {\n      field_1_props.valid = /*valid*/\n      ctx[0];\n    }\n    field_1 = new field_default({ props: field_1_props, $$inline: true });\n    binding_callbacks.push(() => bind(field_1, \"valid\", field_1_valid_binding));\n    const block2 = {\n      key: key_1,\n      first: null,\n      c: function create() {\n        first = empty();\n        create_component(field_1.$$.fragment);\n        this.first = first;\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, first, anchor);\n        mount_component(field_1, target, anchor);\n        current = true;\n      },\n      p: function update2(new_ctx, dirty) {\n        ctx = new_ctx;\n        const field_1_changes = {};\n        if (dirty & /*$schemas*/\n        32) field_1_changes.field = /*field*/\n        ctx[12];\n        if (dirty & /*$schemas*/\n        32) field_1_changes.id = String(\n          /*id*/\n          ctx[14]\n        );\n        if (dirty & /*$schemas, $schemaInvalID*/\n        96) field_1_changes.open = /*field*/\n        ctx[12].id === /*$schemaInvalID*/\n        ctx[6];\n        if (!updating_valid && dirty & /*valid*/\n        1) {\n          updating_valid = true;\n          field_1_changes.valid = /*valid*/\n          ctx[0];\n          add_flush_callback(() => updating_valid = false);\n        }\n        field_1.$set(field_1_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(field_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(field_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(first);\n        }\n        destroy_component(field_1, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block7.name,\n      type: \"each\",\n      source: \"(60:8) {#each $schemas as field, id (field.id)}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot7(ctx) {\n    let schemas_1;\n    let updating_open;\n    let current;\n    function schemas_1_open_binding(value) {\n      ctx[10](value);\n    }\n    let schemas_1_props = {};\n    if (\n      /*open*/\n      ctx[3] !== void 0\n    ) {\n      schemas_1_props.open = /*open*/\n      ctx[3];\n    }\n    schemas_1 = new schemas_default({ props: schemas_1_props, $$inline: true });\n    binding_callbacks.push(() => bind(schemas_1, \"open\", schemas_1_open_binding));\n    const block2 = {\n      c: function create() {\n        create_component(schemas_1.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(schemas_1, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const schemas_1_changes = {};\n        if (!updating_open && dirty & /*open*/\n        8) {\n          updating_open = true;\n          schemas_1_changes.open = /*open*/\n          ctx2[3];\n          add_flush_callback(() => updating_open = false);\n        }\n        schemas_1.$set(schemas_1_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(schemas_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(schemas_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(schemas_1, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot7.name,\n      type: \"slot\",\n      source: '(69:12) <Details                 bind:open                 disabled={!valid || !isNaN(Number($schemaInvalID))}                 class=\\\\\"block clear\\\\\"                 back={open}                 button             >',\n      ctx\n    });\n    return block2;\n  }\n  function create_summary_slot2(ctx) {\n    let icon;\n    let t;\n    let current;\n    icon = new Icon_default({ props: { icon: \"plus\" }, $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(icon.$$.fragment);\n        t = text(\"\\n                    New field\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(icon, target, anchor);\n        insert_dev(target, t, anchor);\n        current = true;\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(t);\n        }\n        destroy_component(icon, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_summary_slot2.name,\n      type: \"slot\",\n      source: '(76:16) <svelte:fragment slot=\\\\\"summary\\\\\">',\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment23(ctx) {\n    let fieldset0;\n    let label0;\n    let small0;\n    let t1;\n    let input;\n    let input_autofocus_value;\n    let t2;\n    let label1;\n    let small1;\n    let t4;\n    let select;\n    let option0;\n    let option1;\n    let option2;\n    let t8;\n    let fieldset1;\n    let legend;\n    let t9;\n    let current_block_type_index;\n    let if_block;\n    let current;\n    let each_value_1 = ensure_array_like_dev(\n      /*tabs*/\n      ctx[7]\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value_1.length; i += 1) {\n      each_blocks[i] = create_each_block_14(get_each_context_14(ctx, each_value_1, i));\n    }\n    const if_block_creators = [create_if_block10, create_if_block_15];\n    const if_blocks = [];\n    function select_block_type(ctx2, dirty) {\n      if (\n        /*activeTab*/\n        ctx2[4] === \"Fields\"\n      ) return 0;\n      if (\n        /*activeTab*/\n        ctx2[4] === \"Rules\"\n      ) return 1;\n      return -1;\n    }\n    if (~(current_block_type_index = select_block_type(ctx, -1))) {\n      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n    }\n    const block2 = {\n      c: function create() {\n        fieldset0 = element(\"fieldset\");\n        label0 = element(\"label\");\n        small0 = element(\"small\");\n        small0.textContent = \"Name\";\n        t1 = space();\n        input = element(\"input\");\n        t2 = space();\n        label1 = element(\"label\");\n        small1 = element(\"small\");\n        small1.textContent = \"Type\";\n        t4 = space();\n        select = element(\"select\");\n        option0 = element(\"option\");\n        option0.textContent = \"Base\";\n        option1 = element(\"option\");\n        option1.textContent = \"View\";\n        option2 = element(\"option\");\n        option2.textContent = \"Auth\";\n        t8 = space();\n        fieldset1 = element(\"fieldset\");\n        legend = element(\"legend\");\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        t9 = space();\n        if (if_block) if_block.c();\n        add_location(small0, file22, 27, 8, 647);\n        attr_dev(input, \"type\", \"text\");\n        attr_dev(input, \"name\", \"collectionName\");\n        attr_dev(input, \"placeholder\", \"collection name\");\n        input.autofocus = input_autofocus_value = true;\n        attr_dev(\n          input,\n          \"pattern\",\n          /*pattern*/\n          ctx[2]\n        );\n        input.value = /*collection*/\n        ctx[1];\n        input.required = true;\n        add_location(input, file22, 29, 8, 721);\n        add_location(label0, file22, 26, 4, 631);\n        add_location(small1, file22, 40, 8, 975);\n        option0.__value = \"Base\";\n        set_input_value(option0, option0.__value);\n        add_location(option0, file22, 42, 12, 1046);\n        option1.__value = \"View\";\n        set_input_value(option1, option1.__value);\n        add_location(option1, file22, 43, 12, 1080);\n        option2.__value = \"Auth\";\n        set_input_value(option2, option2.__value);\n        add_location(option2, file22, 44, 12, 1114);\n        attr_dev(select, \"name\", \"collectionType\");\n        add_location(select, file22, 41, 8, 1003);\n        add_location(label1, file22, 39, 4, 959);\n        attr_dev(fieldset0, \"class\", \"cols svelte-1digiow\");\n        add_location(fieldset0, file22, 25, 0, 603);\n        attr_dev(legend, \"role\", \"group\");\n        add_location(legend, file22, 50, 4, 1215);\n        attr_dev(fieldset1, \"class\", \"cols column svelte-1digiow\");\n        add_location(fieldset1, file22, 49, 0, 1180);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, fieldset0, anchor);\n        append_dev(fieldset0, label0);\n        append_dev(label0, small0);\n        append_dev(label0, t1);\n        append_dev(label0, input);\n        append_dev(fieldset0, t2);\n        append_dev(fieldset0, label1);\n        append_dev(label1, small1);\n        append_dev(label1, t4);\n        append_dev(label1, select);\n        append_dev(select, option0);\n        append_dev(select, option1);\n        append_dev(select, option2);\n        insert_dev(target, t8, anchor);\n        insert_dev(target, fieldset1, anchor);\n        append_dev(fieldset1, legend);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(legend, null);\n          }\n        }\n        append_dev(fieldset1, t9);\n        if (~current_block_type_index) {\n          if_blocks[current_block_type_index].m(fieldset1, null);\n        }\n        current = true;\n        if (true) input.focus();\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (!current || dirty & /*pattern*/\n        4) {\n          attr_dev(\n            input,\n            \"pattern\",\n            /*pattern*/\n            ctx2[2]\n          );\n        }\n        if (!current || dirty & /*collection*/\n        2 && input.value !== /*collection*/\n        ctx2[1]) {\n          prop_dev(\n            input,\n            \"value\",\n            /*collection*/\n            ctx2[1]\n          );\n        }\n        if (dirty & /*tabs, activeTab, setTab*/\n        400) {\n          each_value_1 = ensure_array_like_dev(\n            /*tabs*/\n            ctx2[7]\n          );\n          let i;\n          for (i = 0; i < each_value_1.length; i += 1) {\n            const child_ctx = get_each_context_14(ctx2, each_value_1, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n            } else {\n              each_blocks[i] = create_each_block_14(child_ctx);\n              each_blocks[i].c();\n              each_blocks[i].m(legend, null);\n            }\n          }\n          for (; i < each_blocks.length; i += 1) {\n            each_blocks[i].d(1);\n          }\n          each_blocks.length = each_value_1.length;\n        }\n        let previous_block_index = current_block_type_index;\n        current_block_type_index = select_block_type(ctx2, dirty);\n        if (current_block_type_index === previous_block_index) {\n          if (~current_block_type_index) {\n            if_blocks[current_block_type_index].p(ctx2, dirty);\n          }\n        } else {\n          if (if_block) {\n            group_outros();\n            transition_out(if_blocks[previous_block_index], 1, 1, () => {\n              if_blocks[previous_block_index] = null;\n            });\n            check_outros();\n          }\n          if (~current_block_type_index) {\n            if_block = if_blocks[current_block_type_index];\n            if (!if_block) {\n              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);\n              if_block.c();\n            } else {\n              if_block.p(ctx2, dirty);\n            }\n            transition_in(if_block, 1);\n            if_block.m(fieldset1, null);\n          } else {\n            if_block = null;\n          }\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(fieldset0);\n          detach_dev(t8);\n          detach_dev(fieldset1);\n        }\n        destroy_each(each_blocks, detaching);\n        if (~current_block_type_index) {\n          if_blocks[current_block_type_index].d();\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment23.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance23($$self, $$props, $$invalidate) {\n    let $schemas;\n    let $schemaInvalID;\n    validate_store(schemas, \"schemas\");\n    component_subscribe($$self, schemas, ($$value) => $$invalidate(5, $schemas = $$value));\n    validate_store(schemaInvalID, \"schemaInvalID\");\n    component_subscribe($$self, schemaInvalID, ($$value) => $$invalidate(6, $schemaInvalID = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Fields\", slots, []);\n    let { collection = \"\" } = $$props;\n    let { valid = true } = $$props;\n    let { pattern: pattern2 } = $$props;\n    const tabs = [\"Fields\", \"Rules\"];\n    let open = false;\n    let activeTab = tabs[0];\n    function setTab(e) {\n      const { id } = e.currentTarget;\n      $$invalidate(4, activeTab = id);\n    }\n    $$self.$$.on_mount.push(function() {\n      if (pattern2 === void 0 && !(\"pattern\" in $$props || $$self.$$.bound[$$self.$$.props[\"pattern\"]])) {\n        console.warn(\"<Fields> was created without expected prop 'pattern'\");\n      }\n    });\n    const writable_props = [\"collection\", \"valid\", \"pattern\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Fields> was created with unknown prop '${key}'`);\n    });\n    function field_1_valid_binding(value) {\n      valid = value;\n      $$invalidate(0, valid);\n    }\n    function schemas_1_open_binding(value) {\n      open = value;\n      $$invalidate(3, open);\n    }\n    function details_open_binding(value) {\n      open = value;\n      $$invalidate(3, open);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"collection\" in $$props2) $$invalidate(1, collection = $$props2.collection);\n      if (\"valid\" in $$props2) $$invalidate(0, valid = $$props2.valid);\n      if (\"pattern\" in $$props2) $$invalidate(2, pattern2 = $$props2.pattern);\n    };\n    $$self.$capture_state = () => ({\n      schemas,\n      schemaInvalID,\n      Await: Await_default,\n      Details: Details_default,\n      Icon: Icon_default,\n      Field: field_default,\n      Schemas: schemas_default,\n      collection,\n      valid,\n      pattern: pattern2,\n      tabs,\n      open,\n      activeTab,\n      setTab,\n      $schemas,\n      $schemaInvalID\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"collection\" in $$props2) $$invalidate(1, collection = $$props2.collection);\n      if (\"valid\" in $$props2) $$invalidate(0, valid = $$props2.valid);\n      if (\"pattern\" in $$props2) $$invalidate(2, pattern2 = $$props2.pattern);\n      if (\"open\" in $$props2) $$invalidate(3, open = $$props2.open);\n      if (\"activeTab\" in $$props2) $$invalidate(4, activeTab = $$props2.activeTab);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      valid,\n      collection,\n      pattern2,\n      open,\n      activeTab,\n      $schemas,\n      $schemaInvalID,\n      tabs,\n      setTab,\n      field_1_valid_binding,\n      schemas_1_open_binding,\n      details_open_binding\n    ];\n  }\n  var file22, Fields, fields_default;\n  var init_fields2 = __esm({\n    \"src/client/routes/data/schema/fields.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_schemas3();\n      init_field();\n      init_Icon();\n      init_Details();\n      init_Await();\n      init_data();\n      init_fields();\n      file22 = \"src/client/routes/data/schema/fields.svelte\";\n      Fields = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance23, create_fragment23, safe_not_equal, { collection: 1, valid: 0, pattern: 2 });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Fields\",\n            options: options2,\n            id: create_fragment23.name\n          });\n        }\n        get collection() {\n          throw new Error(\"<Fields>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set collection(value) {\n          throw new Error(\"<Fields>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get valid() {\n          throw new Error(\"<Fields>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set valid(value) {\n          throw new Error(\"<Fields>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get pattern() {\n          throw new Error(\"<Fields>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set pattern(value) {\n          throw new Error(\"<Fields>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      fields_default = Fields;\n    }\n  });\n\n  // src/client/routes/data/schema/edit.svelte\n  function create_default_slot8(ctx) {\n    let fields;\n    let updating_valid;\n    let current;\n    function fields_valid_binding(value) {\n      ctx[5](value);\n    }\n    let fields_props = {\n      collection: (\n        /*collection*/\n        ctx[1]\n      ),\n      pattern: \"^[\\\\w|\\\\-]+$\"\n    };\n    if (\n      /*valid*/\n      ctx[2] !== void 0\n    ) {\n      fields_props.valid = /*valid*/\n      ctx[2];\n    }\n    fields = new fields_default({ props: fields_props, $$inline: true });\n    binding_callbacks.push(() => bind(fields, \"valid\", fields_valid_binding));\n    const block2 = {\n      c: function create() {\n        create_component(fields.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(fields, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const fields_changes = {};\n        if (dirty & /*collection*/\n        2) fields_changes.collection = /*collection*/\n        ctx2[1];\n        if (!updating_valid && dirty & /*valid*/\n        4) {\n          updating_valid = true;\n          fields_changes.valid = /*valid*/\n          ctx2[2];\n          add_flush_callback(() => updating_valid = false);\n        }\n        fields.$set(fields_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(fields.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(fields.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(fields, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot8.name,\n      type: \"slot\",\n      source: \"(26:0) <Dialog {open} on:submit={updateSchema} on:close bind:valid>\",\n      ctx\n    });\n    return block2;\n  }\n  function create_header_slot2(ctx) {\n    let h3;\n    const block2 = {\n      c: function create() {\n        h3 = element(\"h3\");\n        h3.textContent = \"Edit collection\";\n        attr_dev(h3, \"slot\", \"header\");\n        add_location(h3, file23, 36, 4, 912);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, h3, anchor);\n      },\n      p: noop,\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(h3);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_header_slot2.name,\n      type: \"slot\",\n      source: \"(27:4) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_footer_slot2(ctx) {\n    let nav;\n    let button0;\n    let t1;\n    let button1;\n    let t2;\n    let button1_disabled_value;\n    const block2 = {\n      c: function create() {\n        nav = element(\"nav\");\n        button0 = element(\"button\");\n        button0.textContent = \"Cancel\";\n        t1 = space();\n        button1 = element(\"button\");\n        t2 = text(\"Confirm\");\n        attr_dev(button0, \"type\", \"reset\");\n        attr_dev(button0, \"class\", \"link\");\n        add_location(button0, file23, 39, 8, 1043);\n        attr_dev(button1, \"type\", \"submit\");\n        attr_dev(button1, \"class\", \"success\");\n        button1.disabled = button1_disabled_value = !/*valid*/\n        ctx[2] || !isNaN(Number(\n          /*$schemaInvalID*/\n          ctx[3]\n        ));\n        add_location(button1, file23, 40, 8, 1101);\n        attr_dev(nav, \"slot\", \"footer\");\n        add_location(nav, file23, 38, 4, 1015);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, nav, anchor);\n        append_dev(nav, button0);\n        append_dev(nav, t1);\n        append_dev(nav, button1);\n        append_dev(button1, t2);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*valid, $schemaInvalID*/\n        12 && button1_disabled_value !== (button1_disabled_value = !/*valid*/\n        ctx2[2] || !isNaN(Number(\n          /*$schemaInvalID*/\n          ctx2[3]\n        )))) {\n          prop_dev(button1, \"disabled\", button1_disabled_value);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(nav);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_footer_slot2.name,\n      type: \"slot\",\n      source: \"(29:4) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment24(ctx) {\n    let dialog;\n    let updating_valid;\n    let current;\n    function dialog_valid_binding(value) {\n      ctx[6](value);\n    }\n    let dialog_props = {\n      open: (\n        /*open*/\n        ctx[0]\n      ),\n      $$slots: {\n        footer: [create_footer_slot2],\n        header: [create_header_slot2],\n        default: [create_default_slot8]\n      },\n      $$scope: { ctx }\n    };\n    if (\n      /*valid*/\n      ctx[2] !== void 0\n    ) {\n      dialog_props.valid = /*valid*/\n      ctx[2];\n    }\n    dialog = new Dialog_default({ props: dialog_props, $$inline: true });\n    binding_callbacks.push(() => bind(dialog, \"valid\", dialog_valid_binding));\n    dialog.$on(\n      \"submit\",\n      /*updateSchema*/\n      ctx[4]\n    );\n    dialog.$on(\n      \"close\",\n      /*close_handler*/\n      ctx[7]\n    );\n    const block2 = {\n      c: function create() {\n        create_component(dialog.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(dialog, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const dialog_changes = {};\n        if (dirty & /*open*/\n        1) dialog_changes.open = /*open*/\n        ctx2[0];\n        if (dirty & /*$$scope, valid, $schemaInvalID, collection*/\n        1038) {\n          dialog_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        if (!updating_valid && dirty & /*valid*/\n        4) {\n          updating_valid = true;\n          dialog_changes.valid = /*valid*/\n          ctx2[2];\n          add_flush_callback(() => updating_valid = false);\n        }\n        dialog.$set(dialog_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(dialog.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(dialog.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(dialog, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment24.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance24($$self, $$props, $$invalidate) {\n    let $schemas;\n    let $schemasKeys;\n    let $schemaInvalID;\n    validate_store(schemas, \"schemas\");\n    component_subscribe($$self, schemas, ($$value) => $$invalidate(8, $schemas = $$value));\n    validate_store(schemasKeys, \"schemasKeys\");\n    component_subscribe($$self, schemasKeys, ($$value) => $$invalidate(9, $schemasKeys = $$value));\n    validate_store(schemaInvalID, \"schemaInvalID\");\n    component_subscribe($$self, schemaInvalID, ($$value) => $$invalidate(3, $schemaInvalID = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Edit\", slots, []);\n    let { open = false } = $$props;\n    let { collection = \"\" } = $$props;\n    let valid = true;\n    async function updateSchema(e) {\n      const data = new FormData(e.currentTarget);\n      const newName = String(data.get(\"collectionName\"));\n      if (collection && collection !== newName) {\n        await collections.rename(collection, newName);\n      }\n      await records.upkeys(newName, $schemasKeys);\n      schemas.cleanup();\n      if (collection) schemas.update(newName, $schemas);\n      else await schemas.set(newName, $schemas);\n      goto(`/data/${newName}`);\n    }\n    const writable_props = [\"open\", \"collection\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Edit> was created with unknown prop '${key}'`);\n    });\n    function fields_valid_binding(value) {\n      valid = value;\n      $$invalidate(2, valid);\n    }\n    function dialog_valid_binding(value) {\n      valid = value;\n      $$invalidate(2, valid);\n    }\n    function close_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"open\" in $$props2) $$invalidate(0, open = $$props2.open);\n      if (\"collection\" in $$props2) $$invalidate(1, collection = $$props2.collection);\n    };\n    $$self.$capture_state = () => ({\n      goto,\n      collections,\n      schemas,\n      records,\n      schemasKeys,\n      schemaInvalID,\n      Dialog: Dialog_default,\n      Fields: fields_default,\n      open,\n      collection,\n      valid,\n      updateSchema,\n      $schemas,\n      $schemasKeys,\n      $schemaInvalID\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"open\" in $$props2) $$invalidate(0, open = $$props2.open);\n      if (\"collection\" in $$props2) $$invalidate(1, collection = $$props2.collection);\n      if (\"valid\" in $$props2) $$invalidate(2, valid = $$props2.valid);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      open,\n      collection,\n      valid,\n      $schemaInvalID,\n      updateSchema,\n      fields_valid_binding,\n      dialog_valid_binding,\n      close_handler\n    ];\n  }\n  var file23, Edit, edit_default;\n  var init_edit = __esm({\n    \"src/client/routes/data/schema/edit.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_fields2();\n      init_Dialog();\n      init_data();\n      init_src();\n      file23 = \"src/client/routes/data/schema/edit.svelte\";\n      Edit = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance24, create_fragment24, safe_not_equal, { open: 0, collection: 1 });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Edit\",\n            options: options2,\n            id: create_fragment24.name\n          });\n        }\n        get open() {\n          throw new Error(\"<Edit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set open(value) {\n          throw new Error(\"<Edit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get collection() {\n          throw new Error(\"<Edit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set collection(value) {\n          throw new Error(\"<Edit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      edit_default = Edit;\n    }\n  });\n\n  // src/client/routes/data/schema/add.svelte\n  function create_default_slot9(ctx) {\n    let h1;\n    let t1;\n    let fields;\n    let updating_valid;\n    let t2;\n    let nav;\n    let button;\n    let t3;\n    let button_disabled_value;\n    let current;\n    function fields_valid_binding(value) {\n      ctx[5](value);\n    }\n    let fields_props = {\n      collection: (\n        /*collection*/\n        ctx[0]\n      ),\n      pattern: \"(?!^\" + /*$collections*/\n      ctx[2].join(\"$|^\") + \"$)[\\\\w|\\\\-]+\"\n    };\n    if (\n      /*valid*/\n      ctx[1] !== void 0\n    ) {\n      fields_props.valid = /*valid*/\n      ctx[1];\n    }\n    fields = new fields_default({ props: fields_props, $$inline: true });\n    binding_callbacks.push(() => bind(fields, \"valid\", fields_valid_binding));\n    const block2 = {\n      c: function create() {\n        h1 = element(\"h1\");\n        h1.textContent = \"Add collection\";\n        t1 = space();\n        create_component(fields.$$.fragment);\n        t2 = space();\n        nav = element(\"nav\");\n        button = element(\"button\");\n        t3 = text(\"Confirm\");\n        attr_dev(h1, \"class\", \"text-center\");\n        add_location(h1, file24, 29, 4, 853);\n        attr_dev(button, \"type\", \"submit\");\n        attr_dev(button, \"class\", \"success\");\n        button.disabled = button_disabled_value = !/*valid*/\n        ctx[1] || !isNaN(Number(\n          /*$schemaInvalID*/\n          ctx[3]\n        ));\n        add_location(button, file24, 37, 8, 1113);\n        attr_dev(nav, \"class\", \"cols\");\n        add_location(nav, file24, 35, 4, 1019);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, h1, anchor);\n        insert_dev(target, t1, anchor);\n        mount_component(fields, target, anchor);\n        insert_dev(target, t2, anchor);\n        insert_dev(target, nav, anchor);\n        append_dev(nav, button);\n        append_dev(button, t3);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const fields_changes = {};\n        if (dirty & /*collection*/\n        1) fields_changes.collection = /*collection*/\n        ctx2[0];\n        if (dirty & /*$collections*/\n        4) fields_changes.pattern = \"(?!^\" + /*$collections*/\n        ctx2[2].join(\"$|^\") + \"$)[\\\\w|\\\\-]+\";\n        if (!updating_valid && dirty & /*valid*/\n        2) {\n          updating_valid = true;\n          fields_changes.valid = /*valid*/\n          ctx2[1];\n          add_flush_callback(() => updating_valid = false);\n        }\n        fields.$set(fields_changes);\n        if (!current || dirty & /*valid, $schemaInvalID*/\n        10 && button_disabled_value !== (button_disabled_value = !/*valid*/\n        ctx2[1] || !isNaN(Number(\n          /*$schemaInvalID*/\n          ctx2[3]\n        )))) {\n          prop_dev(button, \"disabled\", button_disabled_value);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(fields.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(fields.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(h1);\n          detach_dev(t1);\n          detach_dev(t2);\n          detach_dev(nav);\n        }\n        destroy_component(fields, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot9.name,\n      type: \"slot\",\n      source: \"(25:0) <Form on:submit={addSchema} on:reset={clearSchemas} bind:valid center>\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment25(ctx) {\n    let form;\n    let updating_valid;\n    let current;\n    function form_valid_binding(value) {\n      ctx[6](value);\n    }\n    let form_props = {\n      center: true,\n      $$slots: { default: [create_default_slot9] },\n      $$scope: { ctx }\n    };\n    if (\n      /*valid*/\n      ctx[1] !== void 0\n    ) {\n      form_props.valid = /*valid*/\n      ctx[1];\n    }\n    form = new Form_default({ props: form_props, $$inline: true });\n    binding_callbacks.push(() => bind(form, \"valid\", form_valid_binding));\n    form.$on(\n      \"submit\",\n      /*addSchema*/\n      ctx[4]\n    );\n    form.$on(\"reset\", clearSchemas);\n    const block2 = {\n      c: function create() {\n        create_component(form.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(form, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const form_changes = {};\n        if (dirty & /*$$scope, valid, $schemaInvalID, collection, $collections*/\n        271) {\n          form_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        if (!updating_valid && dirty & /*valid*/\n        2) {\n          updating_valid = true;\n          form_changes.valid = /*valid*/\n          ctx2[1];\n          add_flush_callback(() => updating_valid = false);\n        }\n        form.$set(form_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(form.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(form.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(form, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment25.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function clearSchemas() {\n    schemas.clear();\n  }\n  function instance25($$self, $$props, $$invalidate) {\n    let $schemas;\n    let $collections;\n    let $schemaInvalID;\n    validate_store(schemas, \"schemas\");\n    component_subscribe($$self, schemas, ($$value) => $$invalidate(7, $schemas = $$value));\n    validate_store(collections, \"collections\");\n    component_subscribe($$self, collections, ($$value) => $$invalidate(2, $collections = $$value));\n    validate_store(schemaInvalID, \"schemaInvalID\");\n    component_subscribe($$self, schemaInvalID, ($$value) => $$invalidate(3, $schemaInvalID = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Add\", slots, []);\n    let { collection = \"\" } = $$props;\n    let valid = true;\n    async function addSchema(e) {\n      const data = new FormData(e.currentTarget);\n      const collectionName = String(data.get(\"collectionName\"));\n      schemas.cleanup();\n      await schemas.set(collectionName, $schemas);\n      const fragment3 = !$schemas.length ? \"#edit-collection\" : \"\";\n      if (collectionName === collection) history.go();\n      else goto(`/data/${collectionName}${fragment3}`);\n    }\n    const writable_props = [\"collection\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Add> was created with unknown prop '${key}'`);\n    });\n    function fields_valid_binding(value) {\n      valid = value;\n      $$invalidate(1, valid);\n    }\n    function form_valid_binding(value) {\n      valid = value;\n      $$invalidate(1, valid);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"collection\" in $$props2) $$invalidate(0, collection = $$props2.collection);\n    };\n    $$self.$capture_state = () => ({\n      goto,\n      collections,\n      schemas,\n      schemaInvalID,\n      Form: Form_default,\n      Fields: fields_default,\n      collection,\n      valid,\n      addSchema,\n      clearSchemas,\n      $schemas,\n      $collections,\n      $schemaInvalID\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"collection\" in $$props2) $$invalidate(0, collection = $$props2.collection);\n      if (\"valid\" in $$props2) $$invalidate(1, valid = $$props2.valid);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      collection,\n      valid,\n      $collections,\n      $schemaInvalID,\n      addSchema,\n      fields_valid_binding,\n      form_valid_binding\n    ];\n  }\n  var file24, Add, add_default;\n  var init_add = __esm({\n    \"src/client/routes/data/schema/add.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_fields2();\n      init_Form();\n      init_data();\n      init_src();\n      file24 = \"src/client/routes/data/schema/add.svelte\";\n      Add = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance25, create_fragment25, safe_not_equal, { collection: 0 });\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Add\",\n            options: options2,\n            id: create_fragment25.name\n          });\n        }\n        get collection() {\n          throw new Error(\"<Add>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set collection(value) {\n          throw new Error(\"<Add>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      add_default = Add;\n    }\n  });\n\n  // src/client/components/Table.svelte\n  function get_each_context8(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[15] = list2[i];\n    return child_ctx;\n  }\n  function get_each_context_15(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[18] = list2[i];\n    return child_ctx;\n  }\n  function get_each_context_2(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[15] = list2[i];\n    const constants_0 = (\n      /*tr*/\n      child_ctx[15].id\n    );\n    child_ctx[21] = constants_0;\n    const constants_1 = (\n      /*tr*/\n      child_ctx[15].updated\n    );\n    child_ctx[22] = constants_1;\n    return child_ctx;\n  }\n  function get_each_context_3(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[18] = list2[i];\n    return child_ctx;\n  }\n  function get_each_context_4(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[27] = list2[i];\n    return child_ctx;\n  }\n  function get_each_context_5(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[30] = list2[i];\n    return child_ctx;\n  }\n  function create_if_block_82(ctx) {\n    let tr_1;\n    let t0;\n    let t1;\n    let t2;\n    let current;\n    let if_block0 = (\n      /*selectable*/\n      ctx[2] && create_if_block_152(ctx)\n    );\n    let if_block1 = (\n      /*timeable*/\n      ctx[3] && create_if_block_132(ctx)\n    );\n    let each_value_5 = ensure_array_like_dev(\n      /*data*/\n      ctx[0].thead\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value_5.length; i += 1) {\n      each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));\n    }\n    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {\n      each_blocks[i] = null;\n    });\n    let if_block2 = (\n      /*updated*/\n      ctx[4] && create_if_block_9(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        tr_1 = element(\"tr\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        if (if_block1) if_block1.c();\n        t1 = space();\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        t2 = space();\n        if (if_block2) if_block2.c();\n        add_location(tr_1, file_12, 56, 16, 1271);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, tr_1, anchor);\n        if (if_block0) if_block0.m(tr_1, null);\n        append_dev(tr_1, t0);\n        if (if_block1) if_block1.m(tr_1, null);\n        append_dev(tr_1, t1);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(tr_1, null);\n          }\n        }\n        append_dev(tr_1, t2);\n        if (if_block2) if_block2.m(tr_1, null);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*selectable*/\n          ctx2[2]\n        ) {\n          if (if_block0) {\n            if_block0.p(ctx2, dirty);\n          } else {\n            if_block0 = create_if_block_152(ctx2);\n            if_block0.c();\n            if_block0.m(tr_1, t0);\n          }\n        } else if (if_block0) {\n          if_block0.d(1);\n          if_block0 = null;\n        }\n        if (\n          /*timeable*/\n          ctx2[3]\n        ) {\n          if (if_block1) {\n            if_block1.p(ctx2, dirty);\n            if (dirty[0] & /*timeable*/\n            8) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_132(ctx2);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(tr_1, t1);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, () => {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n        if (dirty[0] & /*data, sort, sorted*/\n        97) {\n          each_value_5 = ensure_array_like_dev(\n            /*data*/\n            ctx2[0].thead\n          );\n          let i;\n          for (i = 0; i < each_value_5.length; i += 1) {\n            const child_ctx = get_each_context_5(ctx2, each_value_5, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n              transition_in(each_blocks[i], 1);\n            } else {\n              each_blocks[i] = create_each_block_5(child_ctx);\n              each_blocks[i].c();\n              transition_in(each_blocks[i], 1);\n              each_blocks[i].m(tr_1, t2);\n            }\n          }\n          group_outros();\n          for (i = each_value_5.length; i < each_blocks.length; i += 1) {\n            out(i);\n          }\n          check_outros();\n        }\n        if (\n          /*updated*/\n          ctx2[4]\n        ) {\n          if (if_block2) {\n            if_block2.p(ctx2, dirty);\n            if (dirty[0] & /*updated*/\n            16) {\n              transition_in(if_block2, 1);\n            }\n          } else {\n            if_block2 = create_if_block_9(ctx2);\n            if_block2.c();\n            transition_in(if_block2, 1);\n            if_block2.m(tr_1, null);\n          }\n        } else if (if_block2) {\n          group_outros();\n          transition_out(if_block2, 1, 1, () => {\n            if_block2 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block1);\n        for (let i = 0; i < each_value_5.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        transition_in(if_block2);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block1);\n        each_blocks = each_blocks.filter(Boolean);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        transition_out(if_block2);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(tr_1);\n        }\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        destroy_each(each_blocks, detaching);\n        if (if_block2) if_block2.d();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_82.name,\n      type: \"if\",\n      source: \"(39:12) {#if data?.thead?.length}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_152(ctx) {\n    let th_1;\n    let input;\n    let input_checked_value;\n    let mounted;\n    let dispose;\n    const block2 = {\n      c: function create() {\n        th_1 = element(\"th\");\n        input = element(\"input\");\n        attr_dev(input, \"type\", \"checkbox\");\n        input.checked = input_checked_value = /*selected*/\n        ctx[1]?.length > 0 && /*selected*/\n        ctx[1]?.length === /*data*/\n        ctx[0].tbody?.length;\n        add_location(input, file_12, 59, 28, 1370);\n        add_location(th_1, file_12, 58, 24, 1337);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, th_1, anchor);\n        append_dev(th_1, input);\n        if (!mounted) {\n          dispose = listen_dev(\n            input,\n            \"change\",\n            /*selectAll*/\n            ctx[8],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty[0] & /*selected, data*/\n        3 && input_checked_value !== (input_checked_value = /*selected*/\n        ctx2[1]?.length > 0 && /*selected*/\n        ctx2[1]?.length === /*data*/\n        ctx2[0].tbody?.length)) {\n          prop_dev(input, \"checked\", input_checked_value);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(th_1);\n        }\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_152.name,\n      type: \"if\",\n      source: \"(41:20) {#if selectable}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_132(ctx) {\n    let th_1;\n    let span;\n    let icon;\n    let t;\n    let current;\n    let mounted;\n    let dispose;\n    icon = new Icon_default({\n      props: { icon: \"calendar\" },\n      $$inline: true\n    });\n    let if_block = \"id\" in /*sorted*/\n    ctx[5] && create_if_block_142(ctx);\n    const block2 = {\n      c: function create() {\n        th_1 = element(\"th\");\n        span = element(\"span\");\n        create_component(icon.$$.fragment);\n        t = text(\" created\\n                                \");\n        if (if_block) if_block.c();\n        add_location(span, file_12, 69, 28, 1851);\n        attr_dev(th_1, \"role\", \"button\");\n        attr_dev(th_1, \"id\", \"id\");\n        attr_dev(th_1, \"class\", \"link\");\n        add_location(th_1, file_12, 68, 24, 1767);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, th_1, anchor);\n        append_dev(th_1, span);\n        mount_component(icon, span, null);\n        append_dev(span, t);\n        if (if_block) if_block.m(span, null);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            th_1,\n            \"click\",\n            /*sort*/\n            ctx[6],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (\"id\" in /*sorted*/\n        ctx2[5]) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty[0] & /*sorted*/\n            32) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block_142(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(span, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(th_1);\n        }\n        destroy_component(icon);\n        if (if_block) if_block.d();\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_132.name,\n      type: \"if\",\n      source: \"(51:20) {#if timeable}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_142(ctx) {\n    let icon;\n    let current;\n    icon = new Icon_default({\n      props: { icon: \"arrow-\" + /*sorted*/\n      ctx[5].id },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(icon.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(icon, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const icon_changes = {};\n        if (dirty[0] & /*sorted*/\n        32) icon_changes.icon = \"arrow-\" + /*sorted*/\n        ctx2[5].id;\n        icon.$set(icon_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(icon, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_142.name,\n      type: \"if\",\n      source: '(55:32) {#if \\\\\"id\\\\\" in sorted}',\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_122(ctx) {\n    let icon;\n    let current;\n    icon = new Icon_default({\n      props: { icon: (\n        /*th*/\n        ctx[30].icon\n      ) },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(icon.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(icon, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const icon_changes = {};\n        if (dirty[0] & /*data*/\n        1) icon_changes.icon = /*th*/\n        ctx2[30].icon;\n        icon.$set(icon_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(icon, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_122.name,\n      type: \"if\",\n      source: \"(69:32) {#if th.type && th.name}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_11(ctx) {\n    let icon;\n    let current;\n    icon = new Icon_default({\n      props: {\n        icon: \"arrow-\" + /*sorted*/\n        ctx[5][String(\n          /*th*/\n          ctx[30].name || /*th*/\n          ctx[30]\n        )]\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(icon.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(icon, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const icon_changes = {};\n        if (dirty[0] & /*sorted, data*/\n        33) icon_changes.icon = \"arrow-\" + /*sorted*/\n        ctx2[5][String(\n          /*th*/\n          ctx2[30].name || /*th*/\n          ctx2[30]\n        )];\n        icon.$set(icon_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(icon, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_11.name,\n      type: \"if\",\n      source: \"(73:32) {#if String(th.name || th) in sorted}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block_5(ctx) {\n    let th_1;\n    let span;\n    let t0;\n    let t1_value = (\n      /*th*/\n      (ctx[30].name || /*th*/\n      ctx[30]) + \"\"\n    );\n    let t1;\n    let t2;\n    let show_if = String(\n      /*th*/\n      ctx[30].name || /*th*/\n      ctx[30]\n    ) in /*sorted*/\n    ctx[5];\n    let th_1_id_value;\n    let current;\n    let mounted;\n    let dispose;\n    let if_block0 = (\n      /*th*/\n      ctx[30].type && /*th*/\n      ctx[30].name && create_if_block_122(ctx)\n    );\n    let if_block1 = show_if && create_if_block_11(ctx);\n    const block2 = {\n      c: function create() {\n        th_1 = element(\"th\");\n        span = element(\"span\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        t1 = text(t1_value);\n        t2 = space();\n        if (if_block1) if_block1.c();\n        add_location(span, file_12, 84, 28, 2485);\n        attr_dev(th_1, \"role\", \"button\");\n        attr_dev(th_1, \"class\", \"link\");\n        attr_dev(th_1, \"id\", th_1_id_value = String(\n          /*th*/\n          ctx[30].name || /*th*/\n          ctx[30]\n        ));\n        add_location(th_1, file_12, 78, 24, 2245);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, th_1, anchor);\n        append_dev(th_1, span);\n        if (if_block0) if_block0.m(span, null);\n        append_dev(span, t0);\n        append_dev(span, t1);\n        append_dev(span, t2);\n        if (if_block1) if_block1.m(span, null);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            th_1,\n            \"click\",\n            /*sort*/\n            ctx[6],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*th*/\n          ctx2[30].type && /*th*/\n          ctx2[30].name\n        ) {\n          if (if_block0) {\n            if_block0.p(ctx2, dirty);\n            if (dirty[0] & /*data*/\n            1) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_122(ctx2);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(span, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, () => {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if ((!current || dirty[0] & /*data*/\n        1) && t1_value !== (t1_value = /*th*/\n        (ctx2[30].name || /*th*/\n        ctx2[30]) + \"\")) set_data_dev(t1, t1_value);\n        if (dirty[0] & /*data, sorted*/\n        33) show_if = String(\n          /*th*/\n          ctx2[30].name || /*th*/\n          ctx2[30]\n        ) in /*sorted*/\n        ctx2[5];\n        if (show_if) {\n          if (if_block1) {\n            if_block1.p(ctx2, dirty);\n            if (dirty[0] & /*data, sorted*/\n            33) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_11(ctx2);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(span, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, () => {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n        if (!current || dirty[0] & /*data*/\n        1 && th_1_id_value !== (th_1_id_value = String(\n          /*th*/\n          ctx2[30].name || /*th*/\n          ctx2[30]\n        ))) {\n          attr_dev(th_1, \"id\", th_1_id_value);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(th_1);\n        }\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block_5.name,\n      type: \"each\",\n      source: \"(61:20) {#each data.thead as th}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_9(ctx) {\n    let th_1;\n    let span;\n    let icon;\n    let t;\n    let current;\n    let mounted;\n    let dispose;\n    icon = new Icon_default({\n      props: { icon: \"calendar\" },\n      $$inline: true\n    });\n    let if_block = \"updated\" in /*sorted*/\n    ctx[5] && create_if_block_10(ctx);\n    const block2 = {\n      c: function create() {\n        th_1 = element(\"th\");\n        span = element(\"span\");\n        create_component(icon.$$.fragment);\n        t = text(\" updated\\n                                \");\n        if (if_block) if_block.c();\n        add_location(span, file_12, 106, 28, 3433);\n        attr_dev(th_1, \"role\", \"button\");\n        attr_dev(th_1, \"id\", \"updated\");\n        attr_dev(th_1, \"class\", \"link\");\n        add_location(th_1, file_12, 100, 24, 3207);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, th_1, anchor);\n        append_dev(th_1, span);\n        mount_component(icon, span, null);\n        append_dev(span, t);\n        if (if_block) if_block.m(span, null);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            th_1,\n            \"click\",\n            /*sort*/\n            ctx[6],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (\"updated\" in /*sorted*/\n        ctx2[5]) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty[0] & /*sorted*/\n            32) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block_10(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(span, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(th_1);\n        }\n        destroy_component(icon);\n        if (if_block) if_block.d();\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_9.name,\n      type: \"if\",\n      source: \"(83:20) {#if updated}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_10(ctx) {\n    let icon;\n    let current;\n    icon = new Icon_default({\n      props: {\n        icon: \"arrow-\" + /*sorted*/\n        ctx[5].updated\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(icon.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(icon, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const icon_changes = {};\n        if (dirty[0] & /*sorted*/\n        32) icon_changes.icon = \"arrow-\" + /*sorted*/\n        ctx2[5].updated;\n        icon.$set(icon_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(icon, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_10.name,\n      type: \"if\",\n      source: '(92:32) {#if \\\\\"updated\\\\\" in sorted}',\n      ctx\n    });\n    return block2;\n  }\n  function fallback_block_12(ctx) {\n    let if_block_anchor;\n    let current;\n    let if_block = (\n      /*data*/\n      ctx[0]?.thead?.length && create_if_block_82(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        if (if_block) if_block.c();\n        if_block_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        if (if_block) if_block.m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*data*/\n          ctx2[0]?.thead?.length\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty[0] & /*data*/\n            1) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block_82(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(if_block_anchor.parentNode, if_block_anchor);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if (if_block) if_block.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: fallback_block_12.name,\n      type: \"fallback\",\n      source: \"(38:27)              \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_72(ctx) {\n    let td_1;\n    let input;\n    let input_value_value;\n    let value_has_changed = false;\n    let binding_group;\n    let mounted;\n    let dispose;\n    binding_group = init_binding_group(\n      /*$$binding_groups*/\n      ctx[13][0]\n    );\n    const block2 = {\n      c: function create() {\n        td_1 = element(\"td\");\n        input = element(\"input\");\n        attr_dev(input, \"type\", \"checkbox\");\n        input.__value = input_value_value = /*id*/\n        ctx[21];\n        set_input_value(input, input.__value);\n        add_location(input, file_12, 125, 24, 4073);\n        add_location(td_1, file_12, 124, 20, 4044);\n        binding_group.p(input);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, td_1, anchor);\n        append_dev(td_1, input);\n        input.checked = ~/*selected*/\n        (ctx[1] || []).indexOf(input.__value);\n        if (!mounted) {\n          dispose = listen_dev(\n            input,\n            \"change\",\n            /*input_change_handler*/\n            ctx[12]\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty[0] & /*data*/\n        1 && input_value_value !== (input_value_value = /*id*/\n        ctx2[21])) {\n          prop_dev(input, \"__value\", input_value_value);\n          set_input_value(input, input.__value);\n          value_has_changed = true;\n        }\n        if (value_has_changed || dirty[0] & /*selected, data*/\n        3) {\n          input.checked = ~/*selected*/\n          (ctx2[1] || []).indexOf(input.__value);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(td_1);\n        }\n        binding_group.r();\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_72.name,\n      type: \"if\",\n      source: \"(107:16) {#if selectable}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_62(ctx) {\n    let td_1;\n    let t_value = date(\n      /*id*/\n      ctx[21]\n    ) + \"\";\n    let t;\n    const block2 = {\n      c: function create() {\n        td_1 = element(\"td\");\n        t = text(t_value);\n        add_location(td_1, file_12, 133, 20, 4339);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, td_1, anchor);\n        append_dev(td_1, t);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty[0] & /*data*/\n        1 && t_value !== (t_value = date(\n          /*id*/\n          ctx2[21]\n        ) + \"\")) set_data_dev(t, t_value);\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(td_1);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_62.name,\n      type: \"if\",\n      source: \"(116:16) {#if timeable}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_23(ctx) {\n    let each_1_anchor;\n    let current;\n    let each_value_3 = ensure_array_like_dev(\n      /*data*/\n      ctx[0].thead\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value_3.length; i += 1) {\n      each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));\n    }\n    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {\n      each_blocks[i] = null;\n    });\n    const block2 = {\n      c: function create() {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        each_1_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(target, anchor);\n          }\n        }\n        insert_dev(target, each_1_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty[0] & /*data*/\n        1) {\n          each_value_3 = ensure_array_like_dev(\n            /*data*/\n            ctx2[0].thead\n          );\n          let i;\n          for (i = 0; i < each_value_3.length; i += 1) {\n            const child_ctx = get_each_context_3(ctx2, each_value_3, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n              transition_in(each_blocks[i], 1);\n            } else {\n              each_blocks[i] = create_each_block_3(child_ctx);\n              each_blocks[i].c();\n              transition_in(each_blocks[i], 1);\n              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n          group_outros();\n          for (i = each_value_3.length; i < each_blocks.length; i += 1) {\n            out(i);\n          }\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        for (let i = 0; i < each_value_3.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        current = true;\n      },\n      o: function outro(local) {\n        each_blocks = each_blocks.filter(Boolean);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(each_1_anchor);\n        }\n        destroy_each(each_blocks, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_23.name,\n      type: \"if\",\n      source: \"(119:16) {#if data.thead?.length}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_33(ctx) {\n    let td_1;\n    let current_block_type_index;\n    let if_block;\n    let t;\n    let current;\n    const if_block_creators = [create_if_block_42, create_else_block4];\n    const if_blocks = [];\n    function select_block_type(ctx2, dirty) {\n      if (\n        /*td*/\n        ctx2[18].type === \"file\"\n      ) return 0;\n      return 1;\n    }\n    current_block_type_index = select_block_type(ctx, [-1, -1]);\n    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n    const block2 = {\n      c: function create() {\n        td_1 = element(\"td\");\n        if_block.c();\n        t = space();\n        add_location(td_1, file_12, 138, 28, 4533);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, td_1, anchor);\n        if_blocks[current_block_type_index].m(td_1, null);\n        append_dev(td_1, t);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        let previous_block_index = current_block_type_index;\n        current_block_type_index = select_block_type(ctx2, dirty);\n        if (current_block_type_index === previous_block_index) {\n          if_blocks[current_block_type_index].p(ctx2, dirty);\n        } else {\n          group_outros();\n          transition_out(if_blocks[previous_block_index], 1, 1, () => {\n            if_blocks[previous_block_index] = null;\n          });\n          check_outros();\n          if_block = if_blocks[current_block_type_index];\n          if (!if_block) {\n            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);\n            if_block.c();\n          } else {\n            if_block.p(ctx2, dirty);\n          }\n          transition_in(if_block, 1);\n          if_block.m(td_1, t);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(td_1);\n        }\n        if_blocks[current_block_type_index].d();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_33.name,\n      type: \"if\",\n      source: \"(121:24) {#if td.name}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_else_block4(ctx) {\n    let p;\n    let t_value = (\n      /*tr*/\n      ctx[15][\n        /*td*/\n        ctx[18].name\n      ] + \"\"\n    );\n    let t;\n    const block2 = {\n      c: function create() {\n        p = element(\"p\");\n        t = text(t_value);\n        add_location(p, file_12, 158, 36, 5645);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, p, anchor);\n        append_dev(p, t);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty[0] & /*data*/\n        1 && t_value !== (t_value = /*tr*/\n        ctx2[15][\n          /*td*/\n          ctx2[18].name\n        ] + \"\")) set_data_dev(t, t_value);\n      },\n      i: noop,\n      o: noop,\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(p);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_else_block4.name,\n      type: \"else\",\n      source: \"(141:32) {:else}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_42(ctx) {\n    let ul;\n    let current;\n    let if_block = (\n      /*tr*/\n      ctx[15][\n        /*td*/\n        ctx[18].name\n      ]?.length && create_if_block_52(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        ul = element(\"ul\");\n        if (if_block) if_block.c();\n        attr_dev(ul, \"role\", \"listbox\");\n        attr_dev(ul, \"class\", \"cols col-fit align-center justify-start nowrap\");\n        add_location(ul, file_12, 143, 36, 4792);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, ul, anchor);\n        if (if_block) if_block.m(ul, null);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*tr*/\n          ctx2[15][\n            /*td*/\n            ctx2[18].name\n          ]?.length\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty[0] & /*data*/\n            1) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block_52(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(ul, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(ul);\n        }\n        if (if_block) if_block.d();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_42.name,\n      type: \"if\",\n      source: '(126:32) {#if td.type === \\\\\"file\\\\\"}',\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_52(ctx) {\n    let each_blocks = [];\n    let each_1_lookup = /* @__PURE__ */ new Map();\n    let each_1_anchor;\n    let current;\n    let each_value_4 = ensure_array_like_dev(\n      /*tr*/\n      ctx[15][\n        /*td*/\n        ctx[18].name\n      ]\n    );\n    const get_key = (ctx2) => (\n      /*file*/\n      ctx2[27]\n    );\n    validate_each_keys(ctx, each_value_4, get_each_context_4, get_key);\n    for (let i = 0; i < each_value_4.length; i += 1) {\n      let child_ctx = get_each_context_4(ctx, each_value_4, i);\n      let key = get_key(child_ctx);\n      each_1_lookup.set(key, each_blocks[i] = create_each_block_4(key, child_ctx));\n    }\n    const block2 = {\n      c: function create() {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        each_1_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(target, anchor);\n          }\n        }\n        insert_dev(target, each_1_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty[0] & /*data*/\n        1) {\n          each_value_4 = ensure_array_like_dev(\n            /*tr*/\n            ctx2[15][\n              /*td*/\n              ctx2[18].name\n            ]\n          );\n          group_outros();\n          validate_each_keys(ctx2, each_value_4, get_each_context_4, get_key);\n          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_4, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_4, each_1_anchor, get_each_context_4);\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        for (let i = 0; i < each_value_4.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        current = true;\n      },\n      o: function outro(local) {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(each_1_anchor);\n        }\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].d(detaching);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_52.name,\n      type: \"if\",\n      source: \"(131:40) {#if tr[td.name]?.length}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block_4(key_1, ctx) {\n    let li;\n    let lbthumb;\n    let t;\n    let current;\n    lbthumb = new Thumb_default({\n      props: { filename: (\n        /*file*/\n        ctx[27].name\n      ) },\n      $$inline: true\n    });\n    const block2 = {\n      key: key_1,\n      first: null,\n      c: function create() {\n        li = element(\"li\");\n        create_component(lbthumb.$$.fragment);\n        t = space();\n        add_location(li, file_12, 149, 48, 5177);\n        this.first = li;\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, li, anchor);\n        mount_component(lbthumb, li, null);\n        append_dev(li, t);\n        current = true;\n      },\n      p: function update2(new_ctx, dirty) {\n        ctx = new_ctx;\n        const lbthumb_changes = {};\n        if (dirty[0] & /*data*/\n        1) lbthumb_changes.filename = /*file*/\n        ctx[27].name;\n        lbthumb.$set(lbthumb_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(lbthumb.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(lbthumb.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(li);\n        }\n        destroy_component(lbthumb);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block_4.name,\n      type: \"each\",\n      source: \"(132:44) {#each tr[td.name] as file (file)}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block_3(ctx) {\n    let if_block_anchor;\n    let current;\n    let if_block = (\n      /*td*/\n      ctx[18].name && create_if_block_33(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        if (if_block) if_block.c();\n        if_block_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        if (if_block) if_block.m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*td*/\n          ctx2[18].name\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty[0] & /*data*/\n            1) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block_33(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(if_block_anchor.parentNode, if_block_anchor);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if (if_block) if_block.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block_3.name,\n      type: \"each\",\n      source: \"(120:20) {#each data.thead as td}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_16(ctx) {\n    let td_1;\n    let t_value = date(\n      /*up*/\n      ctx[22] || /*id*/\n      ctx[21]\n    ) + \"\";\n    let t;\n    const block2 = {\n      c: function create() {\n        td_1 = element(\"td\");\n        t = text(t_value);\n        add_location(td_1, file_12, 165, 20, 5868);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, td_1, anchor);\n        append_dev(td_1, t);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty[0] & /*data*/\n        1 && t_value !== (t_value = date(\n          /*up*/\n          ctx2[22] || /*id*/\n          ctx2[21]\n        ) + \"\")) set_data_dev(t, t_value);\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(td_1);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_16.name,\n      type: \"if\",\n      source: \"(148:16) {#if updated}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block_2(ctx) {\n    let tr_1;\n    let t0;\n    let t1;\n    let t2;\n    let t3;\n    let tr_1_id_value;\n    let current;\n    let mounted;\n    let dispose;\n    let if_block0 = (\n      /*selectable*/\n      ctx[2] && create_if_block_72(ctx)\n    );\n    let if_block1 = (\n      /*timeable*/\n      ctx[3] && create_if_block_62(ctx)\n    );\n    let if_block2 = (\n      /*data*/\n      ctx[0].thead?.length && create_if_block_23(ctx)\n    );\n    let if_block3 = (\n      /*updated*/\n      ctx[4] && create_if_block_16(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        tr_1 = element(\"tr\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        if (if_block1) if_block1.c();\n        t1 = space();\n        if (if_block2) if_block2.c();\n        t2 = space();\n        if (if_block3) if_block3.c();\n        t3 = space();\n        attr_dev(tr_1, \"id\", tr_1_id_value = /*id*/\n        ctx[21]);\n        add_location(tr_1, file_12, 122, 12, 3963);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, tr_1, anchor);\n        if (if_block0) if_block0.m(tr_1, null);\n        append_dev(tr_1, t0);\n        if (if_block1) if_block1.m(tr_1, null);\n        append_dev(tr_1, t1);\n        if (if_block2) if_block2.m(tr_1, null);\n        append_dev(tr_1, t2);\n        if (if_block3) if_block3.m(tr_1, null);\n        append_dev(tr_1, t3);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            tr_1,\n            \"click\",\n            /*select*/\n            ctx[7],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*selectable*/\n          ctx2[2]\n        ) {\n          if (if_block0) {\n            if_block0.p(ctx2, dirty);\n          } else {\n            if_block0 = create_if_block_72(ctx2);\n            if_block0.c();\n            if_block0.m(tr_1, t0);\n          }\n        } else if (if_block0) {\n          if_block0.d(1);\n          if_block0 = null;\n        }\n        if (\n          /*timeable*/\n          ctx2[3]\n        ) {\n          if (if_block1) {\n            if_block1.p(ctx2, dirty);\n          } else {\n            if_block1 = create_if_block_62(ctx2);\n            if_block1.c();\n            if_block1.m(tr_1, t1);\n          }\n        } else if (if_block1) {\n          if_block1.d(1);\n          if_block1 = null;\n        }\n        if (\n          /*data*/\n          ctx2[0].thead?.length\n        ) {\n          if (if_block2) {\n            if_block2.p(ctx2, dirty);\n            if (dirty[0] & /*data*/\n            1) {\n              transition_in(if_block2, 1);\n            }\n          } else {\n            if_block2 = create_if_block_23(ctx2);\n            if_block2.c();\n            transition_in(if_block2, 1);\n            if_block2.m(tr_1, t2);\n          }\n        } else if (if_block2) {\n          group_outros();\n          transition_out(if_block2, 1, 1, () => {\n            if_block2 = null;\n          });\n          check_outros();\n        }\n        if (\n          /*updated*/\n          ctx2[4]\n        ) {\n          if (if_block3) {\n            if_block3.p(ctx2, dirty);\n          } else {\n            if_block3 = create_if_block_16(ctx2);\n            if_block3.c();\n            if_block3.m(tr_1, t3);\n          }\n        } else if (if_block3) {\n          if_block3.d(1);\n          if_block3 = null;\n        }\n        if (!current || dirty[0] & /*data*/\n        1 && tr_1_id_value !== (tr_1_id_value = /*id*/\n        ctx2[21])) {\n          attr_dev(tr_1, \"id\", tr_1_id_value);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block2);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block2);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(tr_1);\n        }\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        if (if_block2) if_block2.d();\n        if (if_block3) if_block3.d();\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block_2.name,\n      type: \"each\",\n      source: \"(103:8) {#each data.tbody as tr}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block11(ctx) {\n    let each_1_anchor;\n    let each_value = ensure_array_like_dev(\n      /*data*/\n      ctx[0].tfoot\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block8(get_each_context8(ctx, each_value, i));\n    }\n    const block2 = {\n      c: function create() {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        each_1_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(target, anchor);\n          }\n        }\n        insert_dev(target, each_1_anchor, anchor);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty[0] & /*data*/\n        1) {\n          each_value = ensure_array_like_dev(\n            /*data*/\n            ctx2[0].tfoot\n          );\n          let i;\n          for (i = 0; i < each_value.length; i += 1) {\n            const child_ctx = get_each_context8(ctx2, each_value, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n            } else {\n              each_blocks[i] = create_each_block8(child_ctx);\n              each_blocks[i].c();\n              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n          for (; i < each_blocks.length; i += 1) {\n            each_blocks[i].d(1);\n          }\n          each_blocks.length = each_value.length;\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(each_1_anchor);\n        }\n        destroy_each(each_blocks, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block11.name,\n      type: \"if\",\n      source: \"(156:12) {#if data?.tfoot?.length}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block_15(ctx) {\n    let td_1;\n    let t_value = (\n      /*td*/\n      ctx[18] + \"\"\n    );\n    let t;\n    const block2 = {\n      c: function create() {\n        td_1 = element(\"td\");\n        t = text(t_value);\n        add_location(td_1, file_12, 176, 28, 6176);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, td_1, anchor);\n        append_dev(td_1, t);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty[0] & /*data*/\n        1 && t_value !== (t_value = /*td*/\n        ctx2[18] + \"\")) set_data_dev(t, t_value);\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(td_1);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block_15.name,\n      type: \"each\",\n      source: \"(159:24) {#each tr as td}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block8(ctx) {\n    let tr_1;\n    let t;\n    let each_value_1 = ensure_array_like_dev(\n      /*tr*/\n      ctx[15]\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value_1.length; i += 1) {\n      each_blocks[i] = create_each_block_15(get_each_context_15(ctx, each_value_1, i));\n    }\n    const block2 = {\n      c: function create() {\n        tr_1 = element(\"tr\");\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        t = space();\n        add_location(tr_1, file_12, 174, 20, 6102);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, tr_1, anchor);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(tr_1, null);\n          }\n        }\n        append_dev(tr_1, t);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty[0] & /*data*/\n        1) {\n          each_value_1 = ensure_array_like_dev(\n            /*tr*/\n            ctx2[15]\n          );\n          let i;\n          for (i = 0; i < each_value_1.length; i += 1) {\n            const child_ctx = get_each_context_15(ctx2, each_value_1, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n            } else {\n              each_blocks[i] = create_each_block_15(child_ctx);\n              each_blocks[i].c();\n              each_blocks[i].m(tr_1, t);\n            }\n          }\n          for (; i < each_blocks.length; i += 1) {\n            each_blocks[i].d(1);\n          }\n          each_blocks.length = each_value_1.length;\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(tr_1);\n        }\n        destroy_each(each_blocks, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block8.name,\n      type: \"each\",\n      source: \"(157:16) {#each data.tfoot as tr}\",\n      ctx\n    });\n    return block2;\n  }\n  function fallback_block5(ctx) {\n    let if_block_anchor;\n    let if_block = (\n      /*data*/\n      ctx[0]?.tfoot?.length && create_if_block11(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        if (if_block) if_block.c();\n        if_block_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        if (if_block) if_block.m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*data*/\n          ctx2[0]?.tfoot?.length\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n          } else {\n            if_block = create_if_block11(ctx2);\n            if_block.c();\n            if_block.m(if_block_anchor.parentNode, if_block_anchor);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if (if_block) if_block.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: fallback_block5.name,\n      type: \"fallback\",\n      source: \"(155:27)              \",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment26(ctx) {\n    let table;\n    let thead;\n    let t0;\n    let tbody;\n    let t1;\n    let tfoot;\n    let current;\n    const thead_slot_template = (\n      /*#slots*/\n      ctx[11].thead\n    );\n    const thead_slot = create_slot(\n      thead_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[10],\n      get_thead_slot_context\n    );\n    const thead_slot_or_fallback = thead_slot || fallback_block_12(ctx);\n    let each_value_2 = ensure_array_like_dev(\n      /*data*/\n      ctx[0].tbody\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value_2.length; i += 1) {\n      each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));\n    }\n    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {\n      each_blocks[i] = null;\n    });\n    const tfoot_slot_template = (\n      /*#slots*/\n      ctx[11].tfoot\n    );\n    const tfoot_slot = create_slot(\n      tfoot_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[10],\n      get_tfoot_slot_context\n    );\n    const tfoot_slot_or_fallback = tfoot_slot || fallback_block5(ctx);\n    const block2 = {\n      c: function create() {\n        table = element(\"table\");\n        thead = element(\"thead\");\n        if (thead_slot_or_fallback) thead_slot_or_fallback.c();\n        t0 = space();\n        tbody = element(\"tbody\");\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        t1 = space();\n        tfoot = element(\"tfoot\");\n        if (tfoot_slot_or_fallback) tfoot_slot_or_fallback.c();\n        add_location(thead, file_12, 53, 4, 1181);\n        add_location(tbody, file_12, 118, 4, 3841);\n        add_location(tfoot, file_12, 170, 4, 5967);\n        toggle_class(\n          table,\n          \"selectable\",\n          /*selectable*/\n          ctx[2]\n        );\n        toggle_class(\n          table,\n          \"updated\",\n          /*updated*/\n          ctx[4]\n        );\n        add_location(table, file_12, 52, 0, 1138);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, table, anchor);\n        append_dev(table, thead);\n        if (thead_slot_or_fallback) {\n          thead_slot_or_fallback.m(thead, null);\n        }\n        append_dev(table, t0);\n        append_dev(table, tbody);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(tbody, null);\n          }\n        }\n        append_dev(table, t1);\n        append_dev(table, tfoot);\n        if (tfoot_slot_or_fallback) {\n          tfoot_slot_or_fallback.m(tfoot, null);\n        }\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (thead_slot) {\n          if (thead_slot.p && (!current || dirty[0] & /*$$scope*/\n          1024)) {\n            update_slot_base(\n              thead_slot,\n              thead_slot_template,\n              ctx2,\n              /*$$scope*/\n              ctx2[10],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx2[10]\n              ) : get_slot_changes(\n                thead_slot_template,\n                /*$$scope*/\n                ctx2[10],\n                dirty,\n                get_thead_slot_changes\n              ),\n              get_thead_slot_context\n            );\n          }\n        } else {\n          if (thead_slot_or_fallback && thead_slot_or_fallback.p && (!current || dirty[0] & /*sorted, updated, data, timeable, selected, selectable*/\n          63)) {\n            thead_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);\n          }\n        }\n        if (dirty[0] & /*data, select, updated, timeable, selected, selectable*/\n        159) {\n          each_value_2 = ensure_array_like_dev(\n            /*data*/\n            ctx2[0].tbody\n          );\n          let i;\n          for (i = 0; i < each_value_2.length; i += 1) {\n            const child_ctx = get_each_context_2(ctx2, each_value_2, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n              transition_in(each_blocks[i], 1);\n            } else {\n              each_blocks[i] = create_each_block_2(child_ctx);\n              each_blocks[i].c();\n              transition_in(each_blocks[i], 1);\n              each_blocks[i].m(tbody, null);\n            }\n          }\n          group_outros();\n          for (i = each_value_2.length; i < each_blocks.length; i += 1) {\n            out(i);\n          }\n          check_outros();\n        }\n        if (tfoot_slot) {\n          if (tfoot_slot.p && (!current || dirty[0] & /*$$scope*/\n          1024)) {\n            update_slot_base(\n              tfoot_slot,\n              tfoot_slot_template,\n              ctx2,\n              /*$$scope*/\n              ctx2[10],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx2[10]\n              ) : get_slot_changes(\n                tfoot_slot_template,\n                /*$$scope*/\n                ctx2[10],\n                dirty,\n                get_tfoot_slot_changes\n              ),\n              get_tfoot_slot_context\n            );\n          }\n        } else {\n          if (tfoot_slot_or_fallback && tfoot_slot_or_fallback.p && (!current || dirty[0] & /*data*/\n          1)) {\n            tfoot_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);\n          }\n        }\n        if (!current || dirty[0] & /*selectable*/\n        4) {\n          toggle_class(\n            table,\n            \"selectable\",\n            /*selectable*/\n            ctx2[2]\n          );\n        }\n        if (!current || dirty[0] & /*updated*/\n        16) {\n          toggle_class(\n            table,\n            \"updated\",\n            /*updated*/\n            ctx2[4]\n          );\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(thead_slot_or_fallback, local);\n        for (let i = 0; i < each_value_2.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        transition_in(tfoot_slot_or_fallback, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(thead_slot_or_fallback, local);\n        each_blocks = each_blocks.filter(Boolean);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        transition_out(tfoot_slot_or_fallback, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(table);\n        }\n        if (thead_slot_or_fallback) thead_slot_or_fallback.d(detaching);\n        destroy_each(each_blocks, detaching);\n        if (tfoot_slot_or_fallback) tfoot_slot_or_fallback.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment26.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance26($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Table\", slots, [\"thead\", \"tfoot\"]);\n    let { data } = $$props;\n    let { current = void 0 } = $$props;\n    let { selected = [] } = $$props;\n    let { selectable = true } = $$props;\n    let { timeable = true } = $$props;\n    let { updated = false } = $$props;\n    let sorted = { id: \"down\" };\n    function sort(e) {\n      const { id } = e.currentTarget;\n      const compare = (a, b) => !isNaN(a[id]) ? Math.sign(a[id] - b[id]) : String(a[id]).localeCompare(String(b[id]));\n      const fn = (a, b) => sorted[id] === \"up\" ? compare(a, b) : compare(b, a);\n      $$invalidate(5, sorted = {\n        [id]: sorted[id] === \"up\" ? \"down\" : \"up\"\n      });\n      $$invalidate(0, data.tbody = data.tbody.sort(fn), data);\n    }\n    function select(e) {\n      const { id } = e.currentTarget;\n      const { nodeName } = e.target;\n      const input = [\"INPUT\", \"A\"].includes(nodeName);\n      if (!input) current?.(Number(id));\n    }\n    function selectAll(e) {\n      const { checked } = e.currentTarget;\n      $$invalidate(1, selected = checked ? data.tbody.map((tb) => tb.id) : []);\n    }\n    const html2 = (value) => /<|>/g.test(value);\n    $$self.$$.on_mount.push(function() {\n      if (data === void 0 && !(\"data\" in $$props || $$self.$$.bound[$$self.$$.props[\"data\"]])) {\n        console.warn(\"<Table> was created without expected prop 'data'\");\n      }\n    });\n    const writable_props = [\"data\", \"current\", \"selected\", \"selectable\", \"timeable\", \"updated\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Table> was created with unknown prop '${key}'`);\n    });\n    const $$binding_groups = [[]];\n    function input_change_handler() {\n      selected = get_binding_group_value($$binding_groups[0], this.__value, this.checked);\n      $$invalidate(1, selected);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"data\" in $$props2) $$invalidate(0, data = $$props2.data);\n      if (\"current\" in $$props2) $$invalidate(9, current = $$props2.current);\n      if (\"selected\" in $$props2) $$invalidate(1, selected = $$props2.selected);\n      if (\"selectable\" in $$props2) $$invalidate(2, selectable = $$props2.selectable);\n      if (\"timeable\" in $$props2) $$invalidate(3, timeable = $$props2.timeable);\n      if (\"updated\" in $$props2) $$invalidate(4, updated = $$props2.updated);\n      if (\"$$scope\" in $$props2) $$invalidate(10, $$scope = $$props2.$$scope);\n    };\n    $$self.$capture_state = () => ({\n      Icon: Icon_default,\n      date,\n      LBThumb: Thumb_default,\n      data,\n      current,\n      selected,\n      selectable,\n      timeable,\n      updated,\n      sorted,\n      sort,\n      select,\n      selectAll,\n      html: html2\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"data\" in $$props2) $$invalidate(0, data = $$props2.data);\n      if (\"current\" in $$props2) $$invalidate(9, current = $$props2.current);\n      if (\"selected\" in $$props2) $$invalidate(1, selected = $$props2.selected);\n      if (\"selectable\" in $$props2) $$invalidate(2, selectable = $$props2.selectable);\n      if (\"timeable\" in $$props2) $$invalidate(3, timeable = $$props2.timeable);\n      if (\"updated\" in $$props2) $$invalidate(4, updated = $$props2.updated);\n      if (\"sorted\" in $$props2) $$invalidate(5, sorted = $$props2.sorted);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      data,\n      selected,\n      selectable,\n      timeable,\n      updated,\n      sorted,\n      sort,\n      select,\n      selectAll,\n      current,\n      $$scope,\n      slots,\n      input_change_handler,\n      $$binding_groups\n    ];\n  }\n  var file_12, get_tfoot_slot_changes, get_tfoot_slot_context, get_thead_slot_changes, get_thead_slot_context, Table, Table_default;\n  var init_Table = __esm({\n    \"src/client/components/Table.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Thumb2();\n      init_time();\n      init_Icon();\n      file_12 = \"src/client/components/Table.svelte\";\n      get_tfoot_slot_changes = (dirty) => ({});\n      get_tfoot_slot_context = (ctx) => ({});\n      get_thead_slot_changes = (dirty) => ({});\n      get_thead_slot_context = (ctx) => ({});\n      Table = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(\n            this,\n            options2,\n            instance26,\n            create_fragment26,\n            safe_not_equal,\n            {\n              data: 0,\n              current: 9,\n              selected: 1,\n              selectable: 2,\n              timeable: 3,\n              updated: 4\n            },\n            null,\n            [-1, -1]\n          );\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Table\",\n            options: options2,\n            id: create_fragment26.name\n          });\n        }\n        get data() {\n          throw new Error(\"<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set data(value) {\n          throw new Error(\"<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get current() {\n          throw new Error(\"<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set current(value) {\n          throw new Error(\"<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get selected() {\n          throw new Error(\"<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set selected(value) {\n          throw new Error(\"<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get selectable() {\n          throw new Error(\"<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set selectable(value) {\n          throw new Error(\"<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get timeable() {\n          throw new Error(\"<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set timeable(value) {\n          throw new Error(\"<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        get updated() {\n          throw new Error(\"<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n        set updated(value) {\n          throw new Error(\"<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n        }\n      };\n      Table_default = Table;\n    }\n  });\n\n  // fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/data/page.esbuild-svelte-fake-css\n  var init_page2 = __esm({\n    \"fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/data/page.esbuild-svelte-fake-css\"() {\n    }\n  });\n\n  // src/client/routes/data/page.svelte\n  var page_exports2 = {};\n  __export(page_exports2, {\n    default: () => page_default2\n  });\n  function create_if_block_34(ctx) {\n    let toast2;\n    let current;\n    toast2 = new Toast_default({\n      props: {\n        type: \"pos-sticky\",\n        $$slots: { default: [create_default_slot_12] },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    toast2.$on(\n      \"close\",\n      /*close_handler*/\n      ctx[11]\n    );\n    toast2.$on(\n      \"dragstart\",\n      /*dragstart_handler*/\n      ctx[12]\n    );\n    toast2.$on(\n      \"dragend\",\n      /*dragend_handler*/\n      ctx[13]\n    );\n    const block2 = {\n      c: function create() {\n        create_component(toast2.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(toast2, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const toast_changes = {};\n        if (dirty & /*$$scope, selected*/\n        65538) {\n          toast_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        toast2.$set(toast_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(toast2.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(toast2.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(toast2, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_34.name,\n      type: \"if\",\n      source: \"(43:0) {#if selected.length}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot_12(ctx) {\n    let span;\n    let b;\n    let t0_value = (\n      /*selected*/\n      ctx[1].length + \"\"\n    );\n    let t0;\n    let t1;\n    let t2_value = s(\n      /*selected*/\n      ctx[1].length\n    ) + \"\";\n    let t2;\n    let t3;\n    let t4;\n    let button;\n    let icon;\n    let current;\n    let mounted;\n    let dispose;\n    icon = new Icon_default({ props: { icon: \"trash\" }, $$inline: true });\n    const block2 = {\n      c: function create() {\n        span = element(\"span\");\n        b = element(\"b\");\n        t0 = text(t0_value);\n        t1 = text(\" record\");\n        t2 = text(t2_value);\n        t3 = text(\" selected\");\n        t4 = space();\n        button = element(\"button\");\n        create_component(icon.$$.fragment);\n        add_location(b, file25, 56, 12, 1820);\n        add_location(span, file25, 55, 8, 1801);\n        attr_dev(button, \"class\", \"box link text-error\");\n        add_location(button, file25, 58, 8, 1905);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, span, anchor);\n        append_dev(span, b);\n        append_dev(b, t0);\n        append_dev(span, t1);\n        append_dev(span, t2);\n        append_dev(span, t3);\n        insert_dev(target, t4, anchor);\n        insert_dev(target, button, anchor);\n        mount_component(icon, button, null);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            button,\n            \"click\",\n            /*deleteRecords*/\n            ctx[10],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if ((!current || dirty & /*selected*/\n        2) && t0_value !== (t0_value = /*selected*/\n        ctx2[1].length + \"\")) set_data_dev(t0, t0_value);\n        if ((!current || dirty & /*selected*/\n        2) && t2_value !== (t2_value = s(\n          /*selected*/\n          ctx2[1].length\n        ) + \"\")) set_data_dev(t2, t2_value);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(span);\n          detach_dev(t4);\n          detach_dev(button);\n        }\n        destroy_component(icon);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot_12.name,\n      type: \"slot\",\n      source: '(44:4) <Toast         type=\\\\\"pos-sticky\\\\\"         on:close={() => (selected.length = 0)}         on:dragstart={(e) => e.dataTransfer?.setData(\\\\\"files\\\\\", String(selected))}         on:dragend={(e) => (selected.length = 0)}     >',\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_24(ctx) {\n    let p;\n    let a;\n    let icon;\n    let t;\n    let current;\n    icon = new Icon_default({ props: { icon: \"plus\" }, $$inline: true });\n    const block2 = {\n      c: function create() {\n        p = element(\"p\");\n        a = element(\"a\");\n        create_component(icon.$$.fragment);\n        t = text(\" Add fields\");\n        attr_dev(a, \"href\", \"#edit-collection\");\n        attr_dev(a, \"role\", \"button\");\n        add_location(a, file25, 75, 16, 2392);\n        attr_dev(p, \"class\", \"text-center\");\n        add_location(p, file25, 74, 12, 2352);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, p, anchor);\n        append_dev(p, a);\n        mount_component(icon, a, null);\n        append_dev(a, t);\n        current = true;\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(p);\n        }\n        destroy_component(icon);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_24.name,\n      type: \"if\",\n      source: \"(68:36) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_17(ctx) {\n    let table;\n    let updating_selected;\n    let current;\n    function table_selected_binding(value) {\n      ctx[14](value);\n    }\n    let table_props = {\n      data: {\n        thead: (\n          /*$schemas*/\n          ctx[4]\n        ),\n        tbody: (\n          /*$records*/\n          ctx[3]\n        )\n      },\n      current: (\n        /*getRecord*/\n        ctx[9]\n      ),\n      updated: true\n    };\n    if (\n      /*selected*/\n      ctx[1] !== void 0\n    ) {\n      table_props.selected = /*selected*/\n      ctx[1];\n    }\n    table = new Table_default({ props: table_props, $$inline: true });\n    binding_callbacks.push(() => bind(table, \"selected\", table_selected_binding));\n    const block2 = {\n      c: function create() {\n        create_component(table.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(table, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const table_changes = {};\n        if (dirty & /*$schemas, $records*/\n        24) table_changes.data = {\n          thead: (\n            /*$schemas*/\n            ctx2[4]\n          ),\n          tbody: (\n            /*$records*/\n            ctx2[3]\n          )\n        };\n        if (!updating_selected && dirty & /*selected*/\n        2) {\n          updating_selected = true;\n          table_changes.selected = /*selected*/\n          ctx2[1];\n          add_flush_callback(() => updating_selected = false);\n        }\n        table.$set(table_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(table.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(table.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(table, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_17.name,\n      type: \"if\",\n      source: \"(61:8) {#if $records?.length}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block12(ctx) {\n    let nav;\n    let a;\n    let icon;\n    let t;\n    let current;\n    icon = new Icon_default({ props: { icon: \"plus\" }, $$inline: true });\n    const block2 = {\n      c: function create() {\n        nav = element(\"nav\");\n        a = element(\"a\");\n        create_component(icon.$$.fragment);\n        t = text(\" Add record\");\n        attr_dev(a, \"tabindex\", \"0\");\n        attr_dev(a, \"href\", \"?record=add\");\n        attr_dev(a, \"role\", \"button\");\n        attr_dev(a, \"draggable\", \"false\");\n        add_location(a, file25, 99, 12, 3179);\n        attr_dev(nav, \"id\", \"addRecord\");\n        attr_dev(nav, \"class\", \"text-center pos-sticky svelte-1i10ixq\");\n        add_location(nav, file25, 98, 8, 3115);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, nav, anchor);\n        append_dev(nav, a);\n        mount_component(icon, a, null);\n        append_dev(a, t);\n        current = true;\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(nav);\n        }\n        destroy_component(icon);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block12.name,\n      type: \"if\",\n      source: \"(92:4) {#if $schemas.length}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot10(ctx) {\n    let section;\n    let current_block_type_index;\n    let if_block0;\n    let t0;\n    let code;\n    let t1;\n    let editschema;\n    let t2;\n    let addrecord;\n    let t3;\n    let editrecord;\n    let t4;\n    let if_block1_anchor;\n    let current;\n    const if_block_creators = [create_if_block_17, create_if_block_24];\n    const if_blocks = [];\n    function select_block_type(ctx2, dirty) {\n      if (\n        /*$records*/\n        ctx2[3]?.length\n      ) return 0;\n      if (!/*$schemas*/\n      ctx2[4]?.length) return 1;\n      return -1;\n    }\n    if (~(current_block_type_index = select_block_type(ctx, -1))) {\n      if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n    }\n    code = new Code_default({\n      props: {\n        input: JSON.stringify(\n          {\n            $schemas: (\n              /*$schemas*/\n              ctx[4]\n            ),\n            $records: (\n              /*$records*/\n              ctx[3]\n            )\n          },\n          null,\n          2\n        )\n      },\n      $$inline: true\n    });\n    editschema = new edit_default({\n      props: {\n        open: (\n          /*$fragment*/\n          ctx[5].includes(\"#edit-collection\")\n        ),\n        collection: (\n          /*$route*/\n          ctx[2].collection\n        )\n      },\n      $$inline: true\n    });\n    editschema.$on(\n      \"close\",\n      /*close_handler_1*/\n      ctx[15]\n    );\n    addrecord = new record_default({\n      props: {\n        collection: (\n          /*$route*/\n          ctx[2].collection\n        ),\n        open: (\n          /*$query*/\n          ctx[6].record === \"add\"\n        )\n      },\n      $$inline: true\n    });\n    editrecord = new record_default({\n      props: {\n        header: \"Edit record\",\n        collection: (\n          /*$route*/\n          ctx[2].collection\n        ),\n        open: !isNaN(Number(\n          /*$query*/\n          ctx[6].record\n        )),\n        active: (\n          /*active*/\n          ctx[0]\n        )\n      },\n      $$inline: true\n    });\n    let if_block1 = (\n      /*$schemas*/\n      ctx[4].length && create_if_block12(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        section = element(\"section\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        create_component(code.$$.fragment);\n        t1 = space();\n        create_component(editschema.$$.fragment);\n        t2 = space();\n        create_component(addrecord.$$.fragment);\n        t3 = space();\n        create_component(editrecord.$$.fragment);\n        t4 = space();\n        if (if_block1) if_block1.c();\n        if_block1_anchor = empty();\n        attr_dev(section, \"class\", \"scroll-x\");\n        add_location(section, file25, 65, 4, 2061);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, section, anchor);\n        if (~current_block_type_index) {\n          if_blocks[current_block_type_index].m(section, null);\n        }\n        append_dev(section, t0);\n        mount_component(code, section, null);\n        insert_dev(target, t1, anchor);\n        mount_component(editschema, target, anchor);\n        insert_dev(target, t2, anchor);\n        mount_component(addrecord, target, anchor);\n        insert_dev(target, t3, anchor);\n        mount_component(editrecord, target, anchor);\n        insert_dev(target, t4, anchor);\n        if (if_block1) if_block1.m(target, anchor);\n        insert_dev(target, if_block1_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        let previous_block_index = current_block_type_index;\n        current_block_type_index = select_block_type(ctx2, dirty);\n        if (current_block_type_index === previous_block_index) {\n          if (~current_block_type_index) {\n            if_blocks[current_block_type_index].p(ctx2, dirty);\n          }\n        } else {\n          if (if_block0) {\n            group_outros();\n            transition_out(if_blocks[previous_block_index], 1, 1, () => {\n              if_blocks[previous_block_index] = null;\n            });\n            check_outros();\n          }\n          if (~current_block_type_index) {\n            if_block0 = if_blocks[current_block_type_index];\n            if (!if_block0) {\n              if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);\n              if_block0.c();\n            } else {\n              if_block0.p(ctx2, dirty);\n            }\n            transition_in(if_block0, 1);\n            if_block0.m(section, t0);\n          } else {\n            if_block0 = null;\n          }\n        }\n        const code_changes = {};\n        if (dirty & /*$schemas, $records*/\n        24) code_changes.input = JSON.stringify(\n          {\n            $schemas: (\n              /*$schemas*/\n              ctx2[4]\n            ),\n            $records: (\n              /*$records*/\n              ctx2[3]\n            )\n          },\n          null,\n          2\n        );\n        code.$set(code_changes);\n        const editschema_changes = {};\n        if (dirty & /*$fragment*/\n        32) editschema_changes.open = /*$fragment*/\n        ctx2[5].includes(\"#edit-collection\");\n        if (dirty & /*$route*/\n        4) editschema_changes.collection = /*$route*/\n        ctx2[2].collection;\n        editschema.$set(editschema_changes);\n        const addrecord_changes = {};\n        if (dirty & /*$route*/\n        4) addrecord_changes.collection = /*$route*/\n        ctx2[2].collection;\n        if (dirty & /*$query*/\n        64) addrecord_changes.open = /*$query*/\n        ctx2[6].record === \"add\";\n        addrecord.$set(addrecord_changes);\n        const editrecord_changes = {};\n        if (dirty & /*$route*/\n        4) editrecord_changes.collection = /*$route*/\n        ctx2[2].collection;\n        if (dirty & /*$query*/\n        64) editrecord_changes.open = !isNaN(Number(\n          /*$query*/\n          ctx2[6].record\n        ));\n        if (dirty & /*active*/\n        1) editrecord_changes.active = /*active*/\n        ctx2[0];\n        editrecord.$set(editrecord_changes);\n        if (\n          /*$schemas*/\n          ctx2[4].length\n        ) {\n          if (if_block1) {\n            if (dirty & /*$schemas*/\n            16) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block12(ctx2);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, () => {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(code.$$.fragment, local);\n        transition_in(editschema.$$.fragment, local);\n        transition_in(addrecord.$$.fragment, local);\n        transition_in(editrecord.$$.fragment, local);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block0);\n        transition_out(code.$$.fragment, local);\n        transition_out(editschema.$$.fragment, local);\n        transition_out(addrecord.$$.fragment, local);\n        transition_out(editrecord.$$.fragment, local);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(section);\n          detach_dev(t1);\n          detach_dev(t2);\n          detach_dev(t3);\n          detach_dev(t4);\n          detach_dev(if_block1_anchor);\n        }\n        if (~current_block_type_index) {\n          if_blocks[current_block_type_index].d();\n        }\n        destroy_component(code);\n        destroy_component(editschema, detaching);\n        destroy_component(addrecord, detaching);\n        destroy_component(editrecord, detaching);\n        if (if_block1) if_block1.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot10.name,\n      type: \"slot\",\n      source: \"(59:0) <Await {promise}>\",\n      ctx\n    });\n    return block2;\n  }\n  function create_catch_slot(ctx) {\n    let addschema;\n    let current;\n    addschema = new add_default({\n      props: {\n        slot: \"catch\",\n        collection: (\n          /*$route*/\n          ctx[2].collection\n        )\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(addschema.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(addschema, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const addschema_changes = {};\n        if (dirty & /*$route*/\n        4) addschema_changes.collection = /*$route*/\n        ctx2[2].collection;\n        addschema.$set(addschema_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(addschema.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(addschema.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(addschema, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_catch_slot.name,\n      type: \"slot\",\n      source: \"(78:4) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment27(ctx) {\n    let t;\n    let await_1;\n    let current;\n    let if_block = (\n      /*selected*/\n      ctx[1].length && create_if_block_34(ctx)\n    );\n    await_1 = new Await_default({\n      props: {\n        promise: (\n          /*promise*/\n          ctx[8]\n        ),\n        $$slots: {\n          catch: [create_catch_slot],\n          default: [create_default_slot10]\n        },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        if (if_block) if_block.c();\n        t = space();\n        create_component(await_1.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        if (if_block) if_block.m(target, anchor);\n        insert_dev(target, t, anchor);\n        mount_component(await_1, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (\n          /*selected*/\n          ctx2[1].length\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty & /*selected*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block_34(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(t.parentNode, t);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n        const await_1_changes = {};\n        if (dirty & /*$$scope, $route, $schemas, $query, active, $fragment, $records, selected*/\n        65663) {\n          await_1_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        await_1.$set(await_1_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        transition_in(await_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        transition_out(await_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(t);\n        }\n        if (if_block) if_block.d(detaching);\n        destroy_component(await_1, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment27.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance27($$self, $$props, $$invalidate) {\n    let $route;\n    let $records;\n    let $schemas;\n    let $fragment;\n    let $query;\n    validate_store(records, \"records\");\n    component_subscribe($$self, records, ($$value) => $$invalidate(3, $records = $$value));\n    validate_store(schemas, \"schemas\");\n    component_subscribe($$self, schemas, ($$value) => $$invalidate(4, $schemas = $$value));\n    validate_store(fragment2, \"fragment\");\n    component_subscribe($$self, fragment2, ($$value) => $$invalidate(5, $fragment = $$value));\n    validate_store(query2, \"query\");\n    component_subscribe($$self, query2, ($$value) => $$invalidate(6, $query = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Page\", slots, []);\n    \"use strict\";\n    let active2;\n    let selected = [];\n    const route = paramable(\"/data/:collection?\");\n    validate_store(route, \"route\");\n    component_subscribe($$self, route, (value) => $$invalidate(2, $route = value));\n    const promise2 = schemas.get($route.collection).then(() => records.get($route.collection));\n    function getRecord(id) {\n      query2.set({ record: id });\n      $$invalidate(0, active2 = $records?.find((r) => r.id === id) || {});\n    }\n    async function deleteRecords() {\n      let Files = [];\n      for (const recordID of selected) {\n        const record = records.id(recordID);\n        for (const fieldname in record) {\n          const typeFile = schemas.type(fieldname) === \"file\";\n          Files = Files.concat(typeFile ? record[fieldname] : []);\n        }\n      }\n      const fileNames = Files.map(({ name: name2 }) => name2);\n      await files.delete($route.collection, fileNames);\n      await records.delete($route.collection, selected);\n      $$invalidate(1, selected.length = 0, selected);\n    }\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Page> was created with unknown prop '${key}'`);\n    });\n    const close_handler = () => $$invalidate(1, selected.length = 0, selected);\n    const dragstart_handler = (e) => e.dataTransfer?.setData(\"files\", String(selected));\n    const dragend_handler = (e) => $$invalidate(1, selected.length = 0, selected);\n    function table_selected_binding(value) {\n      selected = value;\n      $$invalidate(1, selected);\n    }\n    const close_handler_1 = () => fragment2.set(\"\");\n    $$self.$capture_state = () => ({\n      fragment: fragment2,\n      query: query2,\n      paramable,\n      schemas,\n      records,\n      files,\n      s,\n      Await: Await_default,\n      Table: Table_default,\n      Toast: Toast_default,\n      Icon: Icon_default,\n      Code: Code_default,\n      AddSchema: add_default,\n      EditSchema: edit_default,\n      AddRecord: record_default,\n      EditRecord: record_default,\n      active: active2,\n      selected,\n      route,\n      promise: promise2,\n      getRecord,\n      deleteRecords,\n      $route,\n      $records,\n      $schemas,\n      $fragment,\n      $query\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"active\" in $$props2) $$invalidate(0, active2 = $$props2.active);\n      if (\"selected\" in $$props2) $$invalidate(1, selected = $$props2.selected);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      active2,\n      selected,\n      $route,\n      $records,\n      $schemas,\n      $fragment,\n      $query,\n      route,\n      promise2,\n      getRecord,\n      deleteRecords,\n      close_handler,\n      dragstart_handler,\n      dragend_handler,\n      table_selected_binding,\n      close_handler_1\n    ];\n  }\n  var file25, Page2, page_default2;\n  var init_page3 = __esm({\n    \"src/client/routes/data/page.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_record();\n      init_record();\n      init_edit();\n      init_add();\n      init_Code();\n      init_Icon();\n      init_Toast();\n      init_Table();\n      init_Await();\n      init_utils2();\n      init_files();\n      init_data();\n      init_src();\n      init_page2();\n      file25 = \"src/client/routes/data/page.svelte\";\n      Page2 = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance27, create_fragment27, safe_not_equal, {});\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Page\",\n            options: options2,\n            id: create_fragment27.name\n          });\n        }\n      };\n      page_default2 = Page2;\n    }\n  });\n\n  // fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/files/upload.esbuild-svelte-fake-css\n  var init_upload = __esm({\n    \"fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/files/upload.esbuild-svelte-fake-css\"() {\n    }\n  });\n\n  // src/client/routes/files/upload.svelte\n  function get_if_ctx(ctx) {\n    const child_ctx = ctx.slice();\n    const constants_0 = Array.from(\n      /*fileList*/\n      child_ctx[0],\n      ({ name: name2, size, type }, i) => ({\n        id: i + 1,\n        name: encodeURI(name2),\n        size,\n        type\n      })\n    );\n    child_ctx[7] = constants_0;\n    const constants_1 = [{ name: \"id\" }, { name: \"name\" }, { name: \"size\" }, { name: \"type\" }];\n    child_ctx[8] = constants_1;\n    return child_ctx;\n  }\n  function create_default_slot_13(ctx) {\n    let fieldset;\n    let label;\n    let icon;\n    let t;\n    let input;\n    let drop_action;\n    let current;\n    let mounted;\n    let dispose;\n    icon = new Icon_default({\n      props: { icon: \"file-plus\", size: 54 },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        fieldset = element(\"fieldset\");\n        label = element(\"label\");\n        create_component(icon.$$.fragment);\n        t = space();\n        input = element(\"input\");\n        attr_dev(input, \"type\", \"file\");\n        attr_dev(input, \"name\", \"files\");\n        input.multiple = true;\n        attr_dev(input, \"accept\", accept);\n        attr_dev(input, \"class\", \"svelte-88yfos\");\n        toggle_class(\n          input,\n          \"box\",\n          /*$files*/\n          ctx[2]?.length\n        );\n        add_location(input, file26, 60, 12, 1655);\n        attr_dev(label, \"role\", \"button\");\n        attr_dev(label, \"class\", \"block outline link dashed svelte-88yfos\");\n        toggle_class(\n          label,\n          \"box\",\n          /*$files*/\n          ctx[2]?.length\n        );\n        add_location(label, file26, 53, 8, 1446);\n        attr_dev(fieldset, \"class\", \"svelte-88yfos\");\n        add_location(fieldset, file26, 51, 4, 1345);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, fieldset, anchor);\n        append_dev(fieldset, label);\n        mount_component(icon, label, null);\n        append_dev(label, t);\n        append_dev(label, input);\n        current = true;\n        if (!mounted) {\n          dispose = [\n            listen_dev(\n              input,\n              \"change\",\n              /*addFiles*/\n              ctx[3],\n              false,\n              false,\n              false,\n              false\n            ),\n            action_destroyer(drop_action = drop.call(null, label))\n          ];\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (!current || dirty & /*$files*/\n        4) {\n          toggle_class(\n            input,\n            \"box\",\n            /*$files*/\n            ctx2[2]?.length\n          );\n        }\n        if (!current || dirty & /*$files*/\n        4) {\n          toggle_class(\n            label,\n            \"box\",\n            /*$files*/\n            ctx2[2]?.length\n          );\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(fieldset);\n        }\n        destroy_component(icon);\n        mounted = false;\n        run_all(dispose);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot_13.name,\n      type: \"slot\",\n      source: '(40:0) <Form method=\\\\\"POST\\\\\" center>',\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block13(ctx) {\n    let table;\n    let current;\n    table = new Table_default({\n      props: {\n        selectable: false,\n        timeable: false,\n        current: console.log,\n        data: {\n          thead: (\n            /*thead*/\n            ctx[8]\n          ),\n          tbody: (\n            /*tbody*/\n            ctx[7]\n          )\n        }\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(table.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(table, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const table_changes = {};\n        if (dirty & /*fileList*/\n        1) table_changes.data = {\n          thead: (\n            /*thead*/\n            ctx2[8]\n          ),\n          tbody: (\n            /*tbody*/\n            ctx2[7]\n          )\n        };\n        table.$set(table_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(table.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(table.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(table, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block13.name,\n      type: \"if\",\n      source: \"(70:4) {#if fileList}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot11(ctx) {\n    let if_block_anchor;\n    let current;\n    let if_block = (\n      /*fileList*/\n      ctx[0] && create_if_block13(get_if_ctx(ctx))\n    );\n    const block2 = {\n      c: function create() {\n        if (if_block) if_block.c();\n        if_block_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        if (if_block) if_block.m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*fileList*/\n          ctx2[0]\n        ) {\n          if (if_block) {\n            if_block.p(get_if_ctx(ctx2), dirty);\n            if (dirty & /*fileList*/\n            1) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block13(get_if_ctx(ctx2));\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(if_block_anchor.parentNode, if_block_anchor);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if (if_block) if_block.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot11.name,\n      type: \"slot\",\n      source: '(62:0) <Dialog     open={$fragment === \\\\\"#upload-files\\\\\" && Number(fileList?.length) > 0}     on:submit={uploadFiles}     on:reset={clearFiles} >',\n      ctx\n    });\n    return block2;\n  }\n  function create_header_slot3(ctx) {\n    let h3;\n    let t0;\n    let t1_value = (\n      /*fileList*/\n      ctx[0]?.length + \"\"\n    );\n    let t1;\n    let t2;\n    let t3_value = s(\n      /*fileList*/\n      ctx[0]?.length\n    ) + \"\";\n    let t3;\n    const block2 = {\n      c: function create() {\n        h3 = element(\"h3\");\n        t0 = text(\"Upload \");\n        t1 = text(t1_value);\n        t2 = text(\" file\");\n        t3 = text(t3_value);\n        attr_dev(h3, \"slot\", \"header\");\n        attr_dev(h3, \"class\", \"scroll-x\");\n        add_location(h3, file26, 77, 4, 2047);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, h3, anchor);\n        append_dev(h3, t0);\n        append_dev(h3, t1);\n        append_dev(h3, t2);\n        append_dev(h3, t3);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*fileList*/\n        1 && t1_value !== (t1_value = /*fileList*/\n        ctx2[0]?.length + \"\")) set_data_dev(t1, t1_value);\n        if (dirty & /*fileList*/\n        1 && t3_value !== (t3_value = s(\n          /*fileList*/\n          ctx2[0]?.length\n        ) + \"\")) set_data_dev(t3, t3_value);\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(h3);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_header_slot3.name,\n      type: \"slot\",\n      source: \"(67:4) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment28(ctx) {\n    let form;\n    let t;\n    let dialog;\n    let current;\n    form = new Form_default({\n      props: {\n        method: \"POST\",\n        center: true,\n        $$slots: { default: [create_default_slot_13] },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    dialog = new Dialog_default({\n      props: {\n        open: (\n          /*$fragment*/\n          ctx[1] === \"#upload-files\" && Number(\n            /*fileList*/\n            ctx[0]?.length\n          ) > 0\n        ),\n        $$slots: {\n          header: [create_header_slot3],\n          default: [create_default_slot11]\n        },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    dialog.$on(\n      \"submit\",\n      /*uploadFiles*/\n      ctx[4]\n    );\n    dialog.$on(\n      \"reset\",\n      /*clearFiles*/\n      ctx[5]\n    );\n    const block2 = {\n      c: function create() {\n        create_component(form.$$.fragment);\n        t = space();\n        create_component(dialog.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(form, target, anchor);\n        insert_dev(target, t, anchor);\n        mount_component(dialog, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const form_changes = {};\n        if (dirty & /*$$scope, $files*/\n        516) {\n          form_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        form.$set(form_changes);\n        const dialog_changes = {};\n        if (dirty & /*$fragment, fileList*/\n        3) dialog_changes.open = /*$fragment*/\n        ctx2[1] === \"#upload-files\" && Number(\n          /*fileList*/\n          ctx2[0]?.length\n        ) > 0;\n        if (dirty & /*$$scope, fileList*/\n        513) {\n          dialog_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        dialog.$set(dialog_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(form.$$.fragment, local);\n        transition_in(dialog.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(form.$$.fragment, local);\n        transition_out(dialog.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(t);\n        }\n        destroy_component(form, detaching);\n        destroy_component(dialog, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment28.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function drop(node) {\n    const { classList } = node;\n    node.ondragover = (e) => classList.remove(\"link\");\n    node.ondragleave = (e) => classList.add(\"link\");\n    node.ondragend = (e) => classList.add(\"link\");\n    node.ondrop = (e) => classList.add(\"link\");\n  }\n  function instance28($$self, $$props, $$invalidate) {\n    let $path;\n    let $fragment;\n    let $files;\n    validate_store(path2, \"path\");\n    component_subscribe($$self, path2, ($$value) => $$invalidate(6, $path = $$value));\n    validate_store(fragment2, \"fragment\");\n    component_subscribe($$self, fragment2, ($$value) => $$invalidate(1, $fragment = $$value));\n    validate_store(files, \"files\");\n    component_subscribe($$self, files, ($$value) => $$invalidate(2, $files = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Upload\", slots, []);\n    \"use strict\";\n    let fileList;\n    function addFiles(e) {\n      $$invalidate(0, fileList = e.currentTarget.files);\n      set_store_value(fragment2, $fragment = \"#upload-files\", $fragment);\n    }\n    async function uploadFiles(e) {\n      const promises = Array.from(fileList || [], (file48) => files.add(`${$path[1] || \"\"}`, file48));\n      await Promise.all(promises);\n      clearFiles();\n    }\n    function clearFiles() {\n      $$invalidate(0, fileList = null);\n    }\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console_1.warn(`<Upload> was created with unknown prop '${key}'`);\n    });\n    $$self.$capture_state = () => ({\n      path: path2,\n      fragment: fragment2,\n      files,\n      s,\n      Form: Form_default,\n      Dialog: Dialog_default,\n      Table: Table_default,\n      Icon: Icon_default,\n      fileList,\n      accept,\n      addFiles,\n      uploadFiles,\n      clearFiles,\n      drop,\n      $path,\n      $fragment,\n      $files\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"fileList\" in $$props2) $$invalidate(0, fileList = $$props2.fileList);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [fileList, $fragment, $files, addFiles, uploadFiles, clearFiles];\n  }\n  var console_1, file26, accept, Upload, upload_default;\n  var init_upload2 = __esm({\n    \"src/client/routes/files/upload.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Icon();\n      init_Table();\n      init_Dialog();\n      init_Form();\n      init_utils2();\n      init_files();\n      init_src();\n      init_upload();\n      ({ console: console_1 } = globals);\n      file26 = \"src/client/routes/files/upload.svelte\";\n      accept = \".svg, .jpg, .jpeg, .png, .gif, .doc, .docx, .pdf, .txt, .md\";\n      Upload = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance28, create_fragment28, safe_not_equal, {});\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Upload\",\n            options: options2,\n            id: create_fragment28.name\n          });\n        }\n      };\n      upload_default = Upload;\n    }\n  });\n\n  // src/client/utils/selection.ts\n  function selection(container, {\n    target,\n    disabled,\n    match,\n    style\n  }) {\n    const rect = document.createElement(\"div\");\n    rect.style.cssText = style || `\n    background: #fff;\n    opacity: 0.25;\n    position: absolute;\n  `;\n    rect.hidden = true;\n    const ctx = {\n      x1: 0,\n      y1: 0,\n      x2: 0,\n      y2: 0\n    };\n    const state2 = {\n      mouseDown: false,\n      moving: false,\n      mounted: false,\n      disabled: false\n    };\n    let selectedElements = [];\n    function onMouseDown(e) {\n      if (state2.disabled || e.buttons === 2) return;\n      if (!e.shiftKey) selectedElements = [];\n      state2.mouseDown = true;\n      ctx.x1 = e.pageX;\n      ctx.x2 = e.pageX;\n      ctx.y1 = e.pageY;\n      ctx.y2 = e.pageY;\n      reCalc();\n    }\n    function onMouseMove(e) {\n      if (state2.disabled || !state2.mouseDown) return;\n      if (rect.hidden && !(ctx.x1 === 0 && ctx.x2 === 0 && ctx.y1 === 0 && ctx.y2 === 0)) {\n        rect.hidden = false;\n      }\n      if (!state2.mounted) {\n        container.append(rect);\n      }\n      ctx.x2 = e.pageX;\n      ctx.y2 = e.pageY;\n      reCalc();\n      if (state2.mouseDown && !state2.moving) {\n        state2.moving = true;\n      } else if (state2.mouseDown && state2.moving) {\n        document.querySelectorAll(target).forEach((ele) => {\n          const alreadySelected = selectedElements.indexOf(ele) !== -1;\n          const eleRect = ele.getBoundingClientRect();\n          const isOverlapped = checkForOverlap(eleRect);\n          if (isOverlapped && !alreadySelected) {\n            selectedElements.push(ele);\n            match(selectedElements);\n          } else if (!isOverlapped && alreadySelected && !e.shiftKey) {\n            selectedElements = selectedElements.filter((v) => v !== ele);\n            match(selectedElements);\n          }\n        });\n      }\n    }\n    function onMouseUp() {\n      if (!rect.hidden) rect.hidden = true;\n      if (state2.moving) match(selectedElements);\n      cleanUp();\n    }\n    if (!disabled) {\n      container.addEventListener(\"mousedown\", onMouseDown);\n      container.addEventListener(\"mousemove\", onMouseMove);\n      window.addEventListener(\"mouseup\", onMouseUp);\n    }\n    function reCalc() {\n      const dim = getDimensions();\n      rect.style.left = `${dim.xleft}px`;\n      rect.style.top = `${dim.ybottom}px`;\n      rect.style.width = `${dim.xright - dim.xleft}px`;\n      rect.style.height = `${dim.ytop - dim.ybottom}px`;\n    }\n    function getDimensions() {\n      return {\n        xleft: Math.min(ctx.x1, ctx.x2),\n        xright: Math.max(ctx.x1, ctx.x2),\n        ybottom: Math.min(ctx.y1, ctx.y2),\n        ytop: Math.max(ctx.y1, ctx.y2)\n      };\n    }\n    function checkForOverlap(boundingRect) {\n      const iRect = {\n        top: boundingRect.top + window.scrollY,\n        right: boundingRect.right + window.scrollX,\n        bottom: boundingRect.bottom + window.scrollY,\n        left: boundingRect.left + window.scrollX\n      };\n      const r = getDimensions();\n      if ((r.xleft >= iRect.left && r.xleft <= iRect.right || r.xright >= iRect.left && r.xright <= iRect.right || iRect.left >= r.xleft && iRect.left <= r.xright || iRect.right >= r.xleft && iRect.right <= r.xright) && (r.ytop >= iRect.bottom && r.ytop <= iRect.top || r.ybottom >= iRect.bottom && r.ybottom <= iRect.top || iRect.bottom >= r.ybottom && iRect.bottom <= r.ytop || iRect.bottom >= r.ybottom && iRect.top <= r.ytop))\n        return true;\n      return false;\n    }\n    function cleanUp() {\n      state2.mouseDown = false;\n      state2.moving = false;\n      ctx.x1 = 0;\n      ctx.y1 = 0;\n      ctx.x2 = 0;\n      ctx.y2 = 0;\n      state2.mounted = false;\n      rect.remove();\n    }\n    function disable() {\n      container?.removeEventListener(\"mousedown\", onMouseDown);\n      container?.removeEventListener(\"mousemove\", onMouseMove);\n      window?.removeEventListener(\"mouseup\", onMouseUp);\n    }\n    function enable() {\n      container?.addEventListener(\"mousedown\", onMouseDown);\n      container?.addEventListener(\"mousemove\", onMouseMove);\n      window?.addEventListener(\"mouseup\", onMouseUp);\n    }\n    function update2({ disabled: disabled2 }) {\n      disabled2 ? disable() : enable();\n    }\n    function destroy() {\n      disable();\n      cleanUp();\n    }\n    return {\n      update: update2,\n      destroy\n    };\n  }\n  var init_selection = __esm({\n    \"src/client/utils/selection.ts\"() {\n      \"use strict\";\n      init_reload();\n    }\n  });\n\n  // fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/files/page.esbuild-svelte-fake-css\n  var init_page4 = __esm({\n    \"fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/files/page.esbuild-svelte-fake-css\"() {\n    }\n  });\n\n  // src/client/routes/files/page.svelte\n  var page_exports3 = {};\n  __export(page_exports3, {\n    default: () => page_default3\n  });\n  function get_each_context9(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[16] = list2[i];\n    return child_ctx;\n  }\n  function create_if_block14(ctx) {\n    let toast2;\n    let current;\n    toast2 = new Toast_default({\n      props: {\n        draggable: true,\n        type: \"pos-sticky\",\n        $$slots: { default: [create_default_slot_14] },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    toast2.$on(\n      \"close\",\n      /*close_handler*/\n      ctx[8]\n    );\n    toast2.$on(\n      \"dragstart\",\n      /*dragstart_handler*/\n      ctx[9]\n    );\n    toast2.$on(\n      \"dragend\",\n      /*dragend_handler*/\n      ctx[10]\n    );\n    const block2 = {\n      c: function create() {\n        create_component(toast2.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(toast2, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const toast_changes = {};\n        if (dirty & /*$$scope, selected*/\n        524289) {\n          toast_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        toast2.$set(toast_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(toast2.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(toast2.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(toast2, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block14.name,\n      type: \"if\",\n      source: \"(32:0) {#if selected.length}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot_14(ctx) {\n    let icon0;\n    let t0;\n    let span;\n    let b;\n    let t1_value = (\n      /*selected*/\n      ctx[0].length + \"\"\n    );\n    let t1;\n    let t2;\n    let t3_value = s(\n      /*selected*/\n      ctx[0].length\n    ) + \"\";\n    let t3;\n    let t4;\n    let t5;\n    let button;\n    let icon1;\n    let current;\n    let mounted;\n    let dispose;\n    icon0 = new Icon_default({ props: { icon: \"move\" }, $$inline: true });\n    icon1 = new Icon_default({ props: { icon: \"trash\" }, $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(icon0.$$.fragment);\n        t0 = space();\n        span = element(\"span\");\n        b = element(\"b\");\n        t1 = text(t1_value);\n        t2 = text(\" file\");\n        t3 = text(t3_value);\n        t4 = text(\" selected\");\n        t5 = space();\n        button = element(\"button\");\n        create_component(icon1.$$.fragment);\n        add_location(b, file27, 44, 14, 1392);\n        add_location(span, file27, 44, 8, 1386);\n        attr_dev(button, \"class\", \"box link text-error\");\n        add_location(button, file27, 45, 8, 1466);\n      },\n      m: function mount(target, anchor) {\n        mount_component(icon0, target, anchor);\n        insert_dev(target, t0, anchor);\n        insert_dev(target, span, anchor);\n        append_dev(span, b);\n        append_dev(b, t1);\n        append_dev(span, t2);\n        append_dev(span, t3);\n        append_dev(span, t4);\n        insert_dev(target, t5, anchor);\n        insert_dev(target, button, anchor);\n        mount_component(icon1, button, null);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            button,\n            \"click\",\n            /*deleteFiles*/\n            ctx[5],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if ((!current || dirty & /*selected*/\n        1) && t1_value !== (t1_value = /*selected*/\n        ctx2[0].length + \"\")) set_data_dev(t1, t1_value);\n        if ((!current || dirty & /*selected*/\n        1) && t3_value !== (t3_value = s(\n          /*selected*/\n          ctx2[0].length\n        ) + \"\")) set_data_dev(t3, t3_value);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon0.$$.fragment, local);\n        transition_in(icon1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon0.$$.fragment, local);\n        transition_out(icon1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(t0);\n          detach_dev(span);\n          detach_dev(t5);\n          detach_dev(button);\n        }\n        destroy_component(icon0, detaching);\n        destroy_component(icon1);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot_14.name,\n      type: \"slot\",\n      source: '(33:4) <Toast         draggable         type=\\\\\"pos-sticky\\\\\"         on:close={() => (selected.length = 0)}         on:dragstart={(e) => e.dataTransfer?.setData(\\\\\"files\\\\\", String(selected))}         on:dragend={(e) => (selected.length = 0)}     >',\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block9(key_1, ctx) {\n    let li;\n    let a;\n    let t0_value = (\n      /*filename*/\n      ctx[16] + \"\"\n    );\n    let t0;\n    let a_href_value;\n    let t1;\n    let label;\n    let input;\n    let input_value_value;\n    let value_has_changed = false;\n    let t2;\n    let small;\n    let t3_value = (\n      /*filename*/\n      ctx[16] + \"\"\n    );\n    let t3;\n    let t4;\n    let li_id_value;\n    let binding_group;\n    let mounted;\n    let dispose;\n    binding_group = init_binding_group(\n      /*$$binding_groups*/\n      ctx[12][0]\n    );\n    const block2 = {\n      key: key_1,\n      first: null,\n      c: function create() {\n        li = element(\"li\");\n        a = element(\"a\");\n        t0 = text(t0_value);\n        t1 = space();\n        label = element(\"label\");\n        input = element(\"input\");\n        t2 = text(\"\\xA0\\n                        \");\n        small = element(\"small\");\n        t3 = text(t3_value);\n        t4 = space();\n        attr_dev(a, \"draggable\", \"false\");\n        attr_dev(a, \"href\", a_href_value = \"#file-\" + encodeURI(\n          /*filename*/\n          ctx[16]\n        ));\n        set_style(\n          a,\n          \"background-image\",\n          /*createURL*/\n          ctx[7](\n            /*filename*/\n            ctx[16]\n          )\n        );\n        attr_dev(a, \"class\", \"svelte-lgpwhs\");\n        add_location(a, file27, 64, 20, 2113);\n        attr_dev(input, \"type\", \"checkbox\");\n        input.__value = input_value_value = /*filename*/\n        ctx[16];\n        set_input_value(input, input.__value);\n        attr_dev(input, \"class\", \"svelte-lgpwhs\");\n        add_location(input, file27, 72, 24, 2423);\n        attr_dev(small, \"class\", \"text-ellepsis svelte-lgpwhs\");\n        add_location(small, file27, 77, 24, 2625);\n        attr_dev(label, \"class\", \"svelte-lgpwhs\");\n        add_location(label, file27, 71, 20, 2391);\n        attr_dev(li, \"role\", \"button\");\n        attr_dev(li, \"class\", \"box svelte-lgpwhs\");\n        attr_dev(li, \"id\", li_id_value = /*filename*/\n        ctx[16]);\n        add_location(li, file27, 63, 16, 2048);\n        binding_group.p(input);\n        this.first = li;\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, li, anchor);\n        append_dev(li, a);\n        append_dev(a, t0);\n        append_dev(li, t1);\n        append_dev(li, label);\n        append_dev(label, input);\n        input.checked = ~/*selected*/\n        (ctx[0] || []).indexOf(input.__value);\n        append_dev(label, t2);\n        append_dev(label, small);\n        append_dev(small, t3);\n        append_dev(li, t4);\n        if (!mounted) {\n          dispose = listen_dev(\n            input,\n            \"change\",\n            /*input_change_handler*/\n            ctx[11]\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(new_ctx, dirty) {\n        ctx = new_ctx;\n        if (dirty & /*$files*/\n        4 && t0_value !== (t0_value = /*filename*/\n        ctx[16] + \"\")) set_data_dev(t0, t0_value);\n        if (dirty & /*$files*/\n        4 && a_href_value !== (a_href_value = \"#file-\" + encodeURI(\n          /*filename*/\n          ctx[16]\n        ))) {\n          attr_dev(a, \"href\", a_href_value);\n        }\n        if (dirty & /*$files*/\n        4) {\n          set_style(\n            a,\n            \"background-image\",\n            /*createURL*/\n            ctx[7](\n              /*filename*/\n              ctx[16]\n            )\n          );\n        }\n        if (dirty & /*$files*/\n        4 && input_value_value !== (input_value_value = /*filename*/\n        ctx[16])) {\n          prop_dev(input, \"__value\", input_value_value);\n          set_input_value(input, input.__value);\n          value_has_changed = true;\n        }\n        if (value_has_changed || dirty & /*selected, $files*/\n        5) {\n          input.checked = ~/*selected*/\n          (ctx[0] || []).indexOf(input.__value);\n        }\n        if (dirty & /*$files*/\n        4 && t3_value !== (t3_value = /*filename*/\n        ctx[16] + \"\")) set_data_dev(t3, t3_value);\n        if (dirty & /*$files*/\n        4 && li_id_value !== (li_id_value = /*filename*/\n        ctx[16])) {\n          attr_dev(li, \"id\", li_id_value);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(li);\n        }\n        binding_group.r();\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block9.name,\n      type: \"each\",\n      source: \"(58:12) {#each $files?.sort( (a, b) => a.localeCompare(b) ) as filename (filename)}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot12(ctx) {\n    let ul;\n    let li;\n    let upload;\n    let t;\n    let each_blocks = [];\n    let each_1_lookup = /* @__PURE__ */ new Map();\n    let current;\n    upload = new upload_default({ $$inline: true });\n    let each_value = ensure_array_like_dev(\n      /*$files*/\n      ctx[2]?.sort(func)\n    );\n    const get_key = (ctx2) => (\n      /*filename*/\n      ctx2[16]\n    );\n    validate_each_keys(ctx, each_value, get_each_context9, get_key);\n    for (let i = 0; i < each_value.length; i += 1) {\n      let child_ctx = get_each_context9(ctx, each_value, i);\n      let key = get_key(child_ctx);\n      each_1_lookup.set(key, each_blocks[i] = create_each_block9(key, child_ctx));\n    }\n    const block2 = {\n      c: function create() {\n        ul = element(\"ul\");\n        li = element(\"li\");\n        create_component(upload.$$.fragment);\n        t = space();\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        attr_dev(li, \"class\", \"svelte-lgpwhs\");\n        add_location(li, file27, 60, 12, 1834);\n        attr_dev(ul, \"role\", \"listbox\");\n        attr_dev(ul, \"class\", \"grid svelte-lgpwhs\");\n        add_location(ul, file27, 59, 8, 1789);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, ul, anchor);\n        append_dev(ul, li);\n        mount_component(upload, li, null);\n        append_dev(ul, t);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(ul, null);\n          }\n        }\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*$files, selected, encodeURI, createURL*/\n        133) {\n          each_value = ensure_array_like_dev(\n            /*$files*/\n            ctx2[2]?.sort(func)\n          );\n          validate_each_keys(ctx2, each_value, get_each_context9, get_key);\n          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, destroy_block, create_each_block9, null, get_each_context9);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(upload.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(upload.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(ul);\n        }\n        destroy_component(upload);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].d();\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot12.name,\n      type: \"slot\",\n      source: '(55:4) <Await {promise} on:error={() => redirect(\\\\\"/files\\\\\")} notify>',\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment29(ctx) {\n    let t;\n    let section;\n    let await_1;\n    let selection_action;\n    let current;\n    let mounted;\n    let dispose;\n    let if_block = (\n      /*selected*/\n      ctx[0].length && create_if_block14(ctx)\n    );\n    await_1 = new Await_default({\n      props: {\n        promise: (\n          /*promise*/\n          ctx[4]\n        ),\n        notify: true,\n        $$slots: { default: [create_default_slot12] },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    await_1.$on(\n      \"error\",\n      /*error_handler*/\n      ctx[13]\n    );\n    const block2 = {\n      c: function create() {\n        if (if_block) if_block.c();\n        t = space();\n        section = element(\"section\");\n        create_component(await_1.$$.fragment);\n        add_location(section, file27, 51, 0, 1598);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        if (if_block) if_block.m(target, anchor);\n        insert_dev(target, t, anchor);\n        insert_dev(target, section, anchor);\n        mount_component(await_1, section, null);\n        current = true;\n        if (!mounted) {\n          dispose = action_destroyer(selection_action = selection.call(null, section, {\n            target: \"li[role=button]\",\n            disabled: (\n              /*$fragment*/\n              ctx[1]\n            ),\n            match: (\n              /*match*/\n              ctx[6]\n            )\n          }));\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (\n          /*selected*/\n          ctx2[0].length\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty & /*selected*/\n            1) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block14(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(t.parentNode, t);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n        const await_1_changes = {};\n        if (dirty & /*$$scope, $files, selected*/\n        524293) {\n          await_1_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        await_1.$set(await_1_changes);\n        if (selection_action && is_function(selection_action.update) && dirty & /*$fragment*/\n        2) selection_action.update.call(null, {\n          target: \"li[role=button]\",\n          disabled: (\n            /*$fragment*/\n            ctx2[1]\n          ),\n          match: (\n            /*match*/\n            ctx2[6]\n          )\n        });\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        transition_in(await_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        transition_out(await_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(t);\n          detach_dev(section);\n        }\n        if (if_block) if_block.d(detaching);\n        destroy_component(await_1);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment29.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance29($$self, $$props, $$invalidate) {\n    let $route;\n    let $collections;\n    let $fragment;\n    let $files;\n    validate_store(collections, \"collections\");\n    component_subscribe($$self, collections, ($$value) => $$invalidate(15, $collections = $$value));\n    validate_store(fragment2, \"fragment\");\n    component_subscribe($$self, fragment2, ($$value) => $$invalidate(1, $fragment = $$value));\n    validate_store(files, \"files\");\n    component_subscribe($$self, files, ($$value) => $$invalidate(2, $files = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Page\", slots, []);\n    \"use strict\";\n    let selected = [];\n    const route = paramable(\"/files/:folder?\");\n    validate_store(route, \"route\");\n    component_subscribe($$self, route, (value) => $$invalidate(14, $route = value));\n    const promise2 = files.get($route.folder);\n    async function deleteFiles() {\n      if ($collections.includes($route.folder)) {\n        await records.deleteFiles($route.folder, selected);\n      }\n      await files.delete($route.folder, selected);\n      $$invalidate(0, selected = []);\n    }\n    function match(els) {\n      $$invalidate(0, selected = Array.from(els, ({ id }) => id));\n    }\n    function createURL(filename) {\n      return `url('/api/files/${$route.folder || \"\"}/${filename}')`;\n    }\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Page> was created with unknown prop '${key}'`);\n    });\n    const $$binding_groups = [[]];\n    const close_handler = () => $$invalidate(0, selected.length = 0, selected);\n    const dragstart_handler = (e) => e.dataTransfer?.setData(\"files\", String(selected));\n    const dragend_handler = (e) => $$invalidate(0, selected.length = 0, selected);\n    function input_change_handler() {\n      selected = get_binding_group_value($$binding_groups[0], this.__value, this.checked);\n      $$invalidate(0, selected);\n    }\n    const error_handler = () => redirect(\"/files\");\n    $$self.$capture_state = () => ({\n      redirect,\n      fragment: fragment2,\n      paramable,\n      files,\n      collections,\n      records,\n      selection,\n      s,\n      Await: Await_default,\n      Icon: Icon_default,\n      Toast: Toast_default,\n      Upload: upload_default,\n      selected,\n      route,\n      promise: promise2,\n      deleteFiles,\n      match,\n      createURL,\n      $route,\n      $collections,\n      $fragment,\n      $files\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"selected\" in $$props2) $$invalidate(0, selected = $$props2.selected);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      selected,\n      $fragment,\n      $files,\n      route,\n      promise2,\n      deleteFiles,\n      match,\n      createURL,\n      close_handler,\n      dragstart_handler,\n      dragend_handler,\n      input_change_handler,\n      $$binding_groups,\n      error_handler\n    ];\n  }\n  var file27, func, Page3, page_default3;\n  var init_page5 = __esm({\n    \"src/client/routes/files/page.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_upload2();\n      init_Toast();\n      init_Icon();\n      init_Await();\n      init_utils2();\n      init_selection();\n      init_data();\n      init_files();\n      init_src();\n      init_page4();\n      file27 = \"src/client/routes/files/page.svelte\";\n      func = (a, b) => a.localeCompare(b);\n      Page3 = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance29, create_fragment29, safe_not_equal, {});\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Page\",\n            options: options2,\n            id: create_fragment29.name\n          });\n        }\n      };\n      page_default3 = Page3;\n    }\n  });\n\n  // fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/users/page.esbuild-svelte-fake-css\n  var init_page6 = __esm({\n    \"fakecss:/Users/valexr/Desktop/Jsonik/src/client/routes/users/page.esbuild-svelte-fake-css\"() {\n    }\n  });\n\n  // src/client/routes/users/page.svelte\n  var page_exports4 = {};\n  __export(page_exports4, {\n    default: () => page_default4\n  });\n  function create_fragment30(ctx) {\n    let h1;\n    let t1;\n    let section;\n    let article;\n    let p;\n    let t3;\n    let button;\n    let icon;\n    let t4;\n    let current;\n    icon = new Icon_default({\n      props: { icon: \"user-plus\" },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        h1 = element(\"h1\");\n        h1.textContent = \"Users\";\n        t1 = space();\n        section = element(\"section\");\n        article = element(\"article\");\n        p = element(\"p\");\n        p.textContent = 'aria-busy=\"true\"';\n        t3 = space();\n        button = element(\"button\");\n        create_component(icon.$$.fragment);\n        t4 = text(\" Add user\");\n        attr_dev(h1, \"aria-busy\", \"true\");\n        add_location(h1, file28, 4, 0, 97);\n        attr_dev(p, \"aria-busy\", \"true\");\n        add_location(p, file28, 8, 8, 162);\n        add_location(article, file28, 7, 4, 144);\n        add_location(section, file28, 6, 0, 130);\n        attr_dev(button, \"id\", \"addUser\");\n        attr_dev(button, \"class\", \"pos-sticky svelte-5un1ps\");\n        add_location(button, file28, 12, 0, 230);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, h1, anchor);\n        insert_dev(target, t1, anchor);\n        insert_dev(target, section, anchor);\n        append_dev(section, article);\n        append_dev(article, p);\n        insert_dev(target, t3, anchor);\n        insert_dev(target, button, anchor);\n        mount_component(icon, button, null);\n        append_dev(button, t4);\n        current = true;\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(h1);\n          detach_dev(t1);\n          detach_dev(section);\n          detach_dev(t3);\n          detach_dev(button);\n        }\n        destroy_component(icon);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment30.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance30($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Page\", slots, []);\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Page> was created with unknown prop '${key}'`);\n    });\n    $$self.$capture_state = () => ({ Icon: Icon_default });\n    return [];\n  }\n  var file28, Page4, page_default4;\n  var init_page7 = __esm({\n    \"src/client/routes/users/page.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Icon();\n      init_page6();\n      file28 = \"src/client/routes/users/page.svelte\";\n      Page4 = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance30, create_fragment30, safe_not_equal, {});\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Page\",\n            options: options2,\n            id: create_fragment30.name\n          });\n        }\n      };\n      page_default4 = Page4;\n    }\n  });\n\n  // src/client/stores/logs.ts\n  function createLogs() {\n    const { set, subscribe: subscribe2, update: update2, get: getStore } = getable({ docs: [], total: 0 });\n    return {\n      update: update2,\n      subscribe: subscribe2,\n      async get(query3) {\n        const { q, limit, page: page2 } = query3 || {};\n        const logs2 = await get(`/logs/data?q=${q || \"\"}&limit=${limit || \"\"}&page=${page2 || \"\"}`);\n        set(logs2);\n      },\n      async getTotal() {\n        return await get(\"/logs/data\");\n      },\n      getID: (id) => getStore().docs.find((l) => l.id === id)\n      // async rename(file: string, name: string) {\n      //     name = await patch(`/data/files/${file}?name=${name}`);\n      //     update(state => uniq(state.map(f => (f === file ? name : f))))\n      // },\n      // async delete(file: string) {\n      //     file = await del(`/data/files/${file}`)\n      //     update(state => state.filter(s => s !== file))\n      // }\n    };\n  }\n  var logs;\n  var init_logs = __esm({\n    \"src/client/stores/logs.ts\"() {\n      \"use strict\";\n      init_reload();\n      init_getable();\n      init_methods();\n      logs = createLogs();\n    }\n  });\n\n  // src/client/routes/logs/page.svelte\n  var page_exports5 = {};\n  __export(page_exports5, {\n    default: () => page_default5\n  });\n  function get_if_ctx2(ctx) {\n    const child_ctx = ctx.slice();\n    const constants_0 = Object.keys(\n      /*$logs*/\n      child_ctx[3]?.docs.at(-1) || {}\n    ).slice(1).filter((n) => n !== \"message\").map((k) => ({ name: k }));\n    child_ctx[5] = constants_0;\n    const constants_1 = (\n      /*$logs*/\n      child_ctx[3].docs\n    );\n    child_ctx[6] = constants_1;\n    return child_ctx;\n  }\n  function create_if_block15(ctx) {\n    let table;\n    let current;\n    table = new Table_default({\n      props: {\n        data: {\n          thead: (\n            /*thead*/\n            ctx[5]\n          ),\n          tbody: (\n            /*tbody*/\n            ctx[6]\n          )\n        },\n        current: (\n          /*getRecord*/\n          ctx[4]\n        )\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(table.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(table, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const table_changes = {};\n        if (dirty & /*$logs*/\n        8) table_changes.data = {\n          thead: (\n            /*thead*/\n            ctx2[5]\n          ),\n          tbody: (\n            /*tbody*/\n            ctx2[6]\n          )\n        };\n        table.$set(table_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(table.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(table.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(table, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block15.name,\n      type: \"if\",\n      source: \"(21:8) {#if $logs.docs.length}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot_15(ctx) {\n    let code;\n    let current;\n    code = new Code_default({\n      props: {\n        input: JSON.stringify(logs.getID(\n          /*fragmentID*/\n          ctx[0]\n        ), null, 2)\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(code.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(code, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const code_changes = {};\n        if (dirty & /*fragmentID*/\n        1) code_changes.input = JSON.stringify(logs.getID(\n          /*fragmentID*/\n          ctx2[0]\n        ), null, 2);\n        code.$set(code_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(code.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(code.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(code, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot_15.name,\n      type: \"slot\",\n      source: \"(31:4) <Aside open={$fragment === `#log-${fragmentID}`} right>\",\n      ctx\n    });\n    return block2;\n  }\n  function create_header_slot4(ctx) {\n    let h3;\n    let t0;\n    let t1;\n    const block2 = {\n      c: function create() {\n        h3 = element(\"h3\");\n        t0 = text(\"Record \");\n        t1 = text(\n          /*fragmentID*/\n          ctx[0]\n        );\n        attr_dev(h3, \"slot\", \"header\");\n        add_location(h3, file29, 33, 8, 1105);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, h3, anchor);\n        append_dev(h3, t0);\n        append_dev(h3, t1);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*fragmentID*/\n        1) set_data_dev(\n          t1,\n          /*fragmentID*/\n          ctx2[0]\n        );\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(h3);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_header_slot4.name,\n      type: \"slot\",\n      source: \"(32:8) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot13(ctx) {\n    let section;\n    let t;\n    let aside;\n    let current;\n    let if_block = (\n      /*$logs*/\n      ctx[3].docs.length && create_if_block15(get_if_ctx2(ctx))\n    );\n    aside = new Aside_default({\n      props: {\n        open: (\n          /*$fragment*/\n          ctx[1] === `#log-${/*fragmentID*/\n          ctx[0]}`\n        ),\n        right: true,\n        $$slots: {\n          header: [create_header_slot4],\n          default: [create_default_slot_15]\n        },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        section = element(\"section\");\n        if (if_block) if_block.c();\n        t = space();\n        create_component(aside.$$.fragment);\n        attr_dev(section, \"class\", \"scroll-x\");\n        add_location(section, file29, 21, 4, 658);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, section, anchor);\n        if (if_block) if_block.m(section, null);\n        insert_dev(target, t, anchor);\n        mount_component(aside, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*$logs*/\n          ctx2[3].docs.length\n        ) {\n          if (if_block) {\n            if_block.p(get_if_ctx2(ctx2), dirty);\n            if (dirty & /*$logs*/\n            8) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block15(get_if_ctx2(ctx2));\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(section, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n        const aside_changes = {};\n        if (dirty & /*$fragment, fragmentID*/\n        3) aside_changes.open = /*$fragment*/\n        ctx2[1] === `#log-${/*fragmentID*/\n        ctx2[0]}`;\n        if (dirty & /*$$scope, fragmentID*/\n        129) {\n          aside_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        aside.$set(aside_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        transition_in(aside.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        transition_out(aside.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(section);\n          detach_dev(t);\n        }\n        if (if_block) if_block.d();\n        destroy_component(aside, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot13.name,\n      type: \"slot\",\n      source: \"(19:0) <Await promise={logs.get($query)} notify>\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment31(ctx) {\n    let await_1;\n    let current;\n    await_1 = new Await_default({\n      props: {\n        promise: logs.get(\n          /*$query*/\n          ctx[2]\n        ),\n        notify: true,\n        $$slots: { default: [create_default_slot13] },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(await_1.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(await_1, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const await_1_changes = {};\n        if (dirty & /*$query*/\n        4) await_1_changes.promise = logs.get(\n          /*$query*/\n          ctx2[2]\n        );\n        if (dirty & /*$$scope, $fragment, fragmentID, $logs*/\n        139) {\n          await_1_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        await_1.$set(await_1_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(await_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(await_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(await_1, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment31.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance31($$self, $$props, $$invalidate) {\n    let $fragment;\n    let $query;\n    let $logs;\n    validate_store(fragment2, \"fragment\");\n    component_subscribe($$self, fragment2, ($$value) => $$invalidate(1, $fragment = $$value));\n    validate_store(query2, \"query\");\n    component_subscribe($$self, query2, ($$value) => $$invalidate(2, $query = $$value));\n    validate_store(logs, \"logs\");\n    component_subscribe($$self, logs, ($$value) => $$invalidate(3, $logs = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Page\", slots, []);\n    \"use strict\";\n    let fragmentID = Number($fragment.split(\"-\")[1]);\n    function getRecord(id) {\n      fragment2.set(`#log-${id}`);\n      $$invalidate(0, fragmentID = id);\n    }\n    const writable_props = [];\n    Object_15.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Page> was created with unknown prop '${key}'`);\n    });\n    $$self.$capture_state = () => ({\n      fragment: fragment2,\n      query: query2,\n      get,\n      logs,\n      date,\n      Await: Await_default,\n      Aside: Aside_default,\n      Table: Table_default,\n      Code: Code_default,\n      fragmentID,\n      getRecord,\n      $fragment,\n      $query,\n      $logs\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"fragmentID\" in $$props2) $$invalidate(0, fragmentID = $$props2.fragmentID);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [fragmentID, $fragment, $query, $logs, getRecord];\n  }\n  var Object_15, file29, Page5, page_default5;\n  var init_page8 = __esm({\n    \"src/client/routes/logs/page.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      init_Code();\n      init_Table();\n      init_Aside();\n      init_Await();\n      init_time();\n      init_logs();\n      init_methods();\n      init_src();\n      ({ Object: Object_15 } = globals);\n      file29 = \"src/client/routes/logs/page.svelte\";\n      Page5 = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance31, create_fragment31, safe_not_equal, {});\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Page\",\n            options: options2,\n            id: create_fragment31.name\n          });\n        }\n      };\n      page_default5 = Page5;\n    }\n  });\n\n  // src/client/routes/settings/page.svelte\n  var page_exports6 = {};\n  __export(page_exports6, {\n    default: () => page_default6\n  });\n  function create_fragment32(ctx) {\n    let h1;\n    let t1;\n    let section;\n    let article;\n    let p;\n    const block2 = {\n      c: function create() {\n        h1 = element(\"h1\");\n        h1.textContent = \"Settings\";\n        t1 = space();\n        section = element(\"section\");\n        article = element(\"article\");\n        p = element(\"p\");\n        p.textContent = 'aria-busy=\"true\"';\n        add_location(h1, file30, 0, 0, 0);\n        attr_dev(p, \"aria-busy\", \"true\");\n        add_location(p, file30, 4, 8, 51);\n        add_location(article, file30, 3, 4, 33);\n        add_location(section, file30, 2, 0, 19);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, h1, anchor);\n        insert_dev(target, t1, anchor);\n        insert_dev(target, section, anchor);\n        append_dev(section, article);\n        append_dev(article, p);\n      },\n      p: noop,\n      i: noop,\n      o: noop,\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(h1);\n          detach_dev(t1);\n          detach_dev(section);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment32.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance32($$self, $$props) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Page\", slots, []);\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Page> was created with unknown prop '${key}'`);\n    });\n    return [];\n  }\n  var file30, Page6, page_default6;\n  var init_page9 = __esm({\n    \"src/client/routes/settings/page.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      file30 = \"src/client/routes/settings/page.svelte\";\n      Page6 = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance32, create_fragment32, safe_not_equal, {});\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"Page\",\n            options: options2,\n            id: create_fragment32.name\n          });\n        }\n      };\n      page_default6 = Page6;\n    }\n  });\n\n  // src/client/routes/404.svelte\n  var __exports = {};\n  __export(__exports, {\n    default: () => __default\n  });\n  function create_fragment33(ctx) {\n    let section;\n    let h1;\n    let t1;\n    let p;\n    const block2 = {\n      c: function create() {\n        section = element(\"section\");\n        h1 = element(\"h1\");\n        h1.textContent = \"404\";\n        t1 = space();\n        p = element(\"p\");\n        p.textContent = \"Page not found\";\n        attr_dev(h1, \"class\", \"text-center\");\n        add_location(h1, file31, 7, 4, 117);\n        attr_dev(p, \"class\", \"text-center\");\n        add_location(p, file31, 8, 4, 154);\n        add_location(section, file31, 6, 0, 103);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, section, anchor);\n        append_dev(section, h1);\n        append_dev(section, t1);\n        append_dev(section, p);\n      },\n      p: noop,\n      i: noop,\n      o: noop,\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(section);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment33.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance33($$self, $$props) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"_404\", slots, []);\n    \"use strict\";\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<_404> was created with unknown prop '${key}'`);\n    });\n    return [];\n  }\n  var file31, _404, __default;\n  var init__ = __esm({\n    \"src/client/routes/404.svelte\"() {\n      \"use strict\";\n      init_reload();\n      init_internal();\n      init_disclose_version();\n      file31 = \"src/client/routes/404.svelte\";\n      _404 = class extends SvelteComponentDev {\n        constructor(options2) {\n          super(options2);\n          init(this, options2, instance33, create_fragment33, safe_not_equal, {});\n          dispatch_dev(\"SvelteRegisterComponent\", {\n            component: this,\n            tagName: \"_404\",\n            options: options2,\n            id: create_fragment33.name\n          });\n        }\n      };\n      __default = _404;\n    }\n  });\n\n  // src/client/app.ts\n  init_reload();\n\n  // package.json\n  var name = \"jsonik\";\n  var repository = {\n    type: \"git\",\n    url: \"https://github.com/Valexr/jsonik.git\"\n  };\n\n  // src/client/App.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n\n  // src/client/components/LightBox/Modal.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n  init_Icon();\n  init_Dialog();\n  init_files();\n  init_data();\n  init_src();\n  var file4 = \"src/client/components/LightBox/Modal.svelte\";\n  function create_default_slot2(ctx) {\n    let figure;\n    let img;\n    let img_src_value;\n    const block2 = {\n      c: function create() {\n        figure = element(\"figure\");\n        img = element(\"img\");\n        if (!src_url_equal(img.src, img_src_value = /*createURL*/\n        ctx[3](\n          /*filename*/\n          ctx[1]\n        ))) attr_dev(img, \"src\", img_src_value);\n        attr_dev(\n          img,\n          \"alt\",\n          /*filename*/\n          ctx[1]\n        );\n        add_location(img, file4, 41, 8, 984);\n        add_location(figure, file4, 40, 4, 967);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, figure, anchor);\n        append_dev(figure, img);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*filename*/\n        2 && !src_url_equal(img.src, img_src_value = /*createURL*/\n        ctx2[3](\n          /*filename*/\n          ctx2[1]\n        ))) {\n          attr_dev(img, \"src\", img_src_value);\n        }\n        if (dirty & /*filename*/\n        2) {\n          attr_dev(\n            img,\n            \"alt\",\n            /*filename*/\n            ctx2[1]\n          );\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(figure);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot2.name,\n      type: \"slot\",\n      source: '(27:0) <Dialog     on:close={close}     on:submit={deleteFile}     open={$fragment === `#file-${filename}`}     from=\\\\\"center\\\\\"     img >',\n      ctx\n    });\n    return block2;\n  }\n  function create_footer_slot(ctx) {\n    let nav;\n    let span;\n    let t0;\n    let t1;\n    let button0;\n    let icon0;\n    let t2;\n    let button1;\n    let icon1;\n    let current;\n    let mounted;\n    let dispose;\n    icon0 = new Icon_default({ props: { icon: \"trash\" }, $$inline: true });\n    icon1 = new Icon_default({ $$inline: true });\n    const block2 = {\n      c: function create() {\n        nav = element(\"nav\");\n        span = element(\"span\");\n        t0 = text(\n          /*filename*/\n          ctx[1]\n        );\n        t1 = space();\n        button0 = element(\"button\");\n        create_component(icon0.$$.fragment);\n        t2 = space();\n        button1 = element(\"button\");\n        create_component(icon1.$$.fragment);\n        attr_dev(span, \"class\", \"scroll-x svelte-1nxttb1\");\n        add_location(span, file4, 44, 8, 1120);\n        attr_dev(button0, \"type\", \"submit\");\n        attr_dev(button0, \"class\", \"box link text-error\");\n        add_location(button0, file4, 45, 8, 1169);\n        attr_dev(button1, \"type\", \"reset\");\n        attr_dev(button1, \"class\", \"box link\");\n        add_location(button1, file4, 48, 8, 1280);\n        attr_dev(nav, \"class\", \"cols col-fit align-center nowrap svelte-1nxttb1\");\n        attr_dev(nav, \"slot\", \"footer\");\n        add_location(nav, file4, 43, 4, 1051);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, nav, anchor);\n        append_dev(nav, span);\n        append_dev(span, t0);\n        append_dev(nav, t1);\n        append_dev(nav, button0);\n        mount_component(icon0, button0, null);\n        append_dev(nav, t2);\n        append_dev(nav, button1);\n        mount_component(icon1, button1, null);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(button1, \"click\", stop_propagation(\n            /*click_handler*/\n            ctx[5]\n          ), false, false, true, false);\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (!current || dirty & /*filename*/\n        2) set_data_dev(\n          t0,\n          /*filename*/\n          ctx2[1]\n        );\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon0.$$.fragment, local);\n        transition_in(icon1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon0.$$.fragment, local);\n        transition_out(icon1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(nav);\n        }\n        destroy_component(icon0);\n        destroy_component(icon1);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_footer_slot.name,\n      type: \"slot\",\n      source: \"(37:4) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment4(ctx) {\n    let dialog;\n    let current;\n    dialog = new Dialog_default({\n      props: {\n        open: (\n          /*$fragment*/\n          ctx[0] === `#file-${/*filename*/\n          ctx[1]}`\n        ),\n        from: \"center\",\n        img: true,\n        $$slots: {\n          footer: [create_footer_slot],\n          default: [create_default_slot2]\n        },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    dialog.$on(\"close\", close);\n    dialog.$on(\n      \"submit\",\n      /*deleteFile*/\n      ctx[4]\n    );\n    const block2 = {\n      c: function create() {\n        create_component(dialog.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(dialog, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const dialog_changes = {};\n        if (dirty & /*$fragment, filename*/\n        3) dialog_changes.open = /*$fragment*/\n        ctx2[0] === `#file-${/*filename*/\n        ctx2[1]}`;\n        if (dirty & /*$$scope, filename*/\n        514) {\n          dialog_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        dialog.$set(dialog_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(dialog.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(dialog.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(dialog, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment4.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function close() {\n    fragment2.set(\"\");\n  }\n  function instance4($$self, $$props, $$invalidate) {\n    let _;\n    let filename;\n    let $route;\n    let $collections;\n    let $fragment;\n    validate_store(collections, \"collections\");\n    component_subscribe($$self, collections, ($$value) => $$invalidate(8, $collections = $$value));\n    validate_store(fragment2, \"fragment\");\n    component_subscribe($$self, fragment2, ($$value) => $$invalidate(0, $fragment = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Modal\", slots, []);\n    \"use strict\";\n    const route = paramable(\"/:folder/:collection\");\n    validate_store(route, \"route\");\n    component_subscribe($$self, route, (value) => $$invalidate(7, $route = value));\n    function createURL(filename2) {\n      if (filename2) {\n        return `/api/files/${$route.collection || \"\"}/${filename2}`;\n      }\n    }\n    async function deleteFile() {\n      if ($collections.includes($route.collection)) {\n        await records.deleteFiles($route.collection, [filename]);\n      }\n      await files.delete($route.collection, [filename]);\n    }\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Modal> was created with unknown prop '${key}'`);\n    });\n    function click_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    $$self.$capture_state = () => ({\n      fragment: fragment2,\n      paramable,\n      records,\n      collections,\n      files,\n      Dialog: Dialog_default,\n      Icon: Icon_default,\n      route,\n      createURL,\n      deleteFile,\n      close,\n      filename,\n      _,\n      $route,\n      $collections,\n      $fragment\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"filename\" in $$props2) $$invalidate(1, filename = $$props2.filename);\n      if (\"_\" in $$props2) _ = $$props2._;\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    $$self.$$.update = () => {\n      if ($$self.$$.dirty & /*$fragment*/\n      1) {\n        $: $$invalidate(1, [_, filename] = $fragment.split(\"#file-\"), filename);\n      }\n    };\n    return [$fragment, filename, route, createURL, deleteFile, click_handler];\n  }\n  var Modal = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance4, create_fragment4, safe_not_equal, {});\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Modal\",\n        options: options2,\n        id: create_fragment4.name\n      });\n    }\n  };\n  var Modal_default = Modal;\n\n  // src/client/App.svelte\n  init_Toaster2();\n\n  // src/client/components/Router.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n\n  // src/client/assets/favicon.png\n  var favicon_default = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsSAAALEgHS3X78AAAL6UlEQVR4nO1dCY4TRxStwMCwD4hNIEQmdQEmJ8jkBMwNmJwg5AQMNxhOEDhBhhswJwhcoGIQYkcwYt+jZ+oHx9hj99+q2vaTWiyS2+2uV3//v3748uVLmGF6sWO29tONGQGmHDMCTDlmBJhyzE37CxiGlNJiCGEpX4fzn8NwM4TwPP95M8bYqe4HDcHMC8jIC74SQljO14LgdlshhBv52qiZEFNPgJTSaggB1y+GX3MrhLCeyfDc8HsaYyoJkFKCSL+YL8lObwpIho0QwlotUmHqCJBSwqKvOS/8IFyrgQhTQ4CU0nIWw+cqeBwCJMJ6jHGt1ANMPAGyuMcL/r2CxxkG2AirMcab3l880XGAlNJKds1qXvyQpdLfWT25YiIlQN71V0MI5yt4nKaAbXDRy1uYOAJUZORJAJWw7EGCiSFADuRcNfbnPeFCgomwAVJK2PH/TNDih2wX3MjqzAytlgCVunbaMJUErUwGebt2O3bsCPPz82Fubq579eLz58/h/fv34d27d92/G+BcVm0rFjdvnQTIrh12/Y+W34OFXlhYCHv37g27d+8e6zMfP34Mb968Ca9fvw6vXr3SfqTLFgGj1hDAy7XDgh85ciTs2bNHdB+QYWtrK7x48UJTMvwaY7yhdbPQFgJ4uHbY8SdOnBAvfD9AhGfPnnWJoIDbqEvQtAeqJoCXawdRj10PXW+Ft2/fhgcPHmhIgysxRrWIYbUEyK7dJcvvgG7Hrh9Xx0uBxb93717XaBRCTRVURwAP1w47nXa9N5RIsBljXNZ49GoI4OXawcg7fvz4d+6cJ5RIoCIFqogEemTtsOux8KdOnSq6+PQsp0+flqoeFZewqATwcu3279/fXXxLI48DSABIAoFh+JO0oqjYG8muXcdy8bHTT5482b1qW/yQjVChHSL2BtwlgNeu93DttHD37l2uPbAVYxQli1zfTkppKdfKmy0+dhX069GjR1ux+MCxY8e4H13I75QNN2uoZ/HNonnY8SVcOykQfQRxmVKADGgWXAhgvfg1uHZSQGU9fvyYcxdRPMD8jVkuPkQ8djxengcQ10dMHxf+ju8H+Q4cOND1NCTA55kEEIXJTY3AbPB1LBYfLwx63mvXI6GDa7vnkbqa9+/f76aTGfiZW1Ju/fbUdz4FdKQ7blxALz969Gikfkb+H/48Ak1cwBZgEmCRaweYESAnc1Tj+Z6uHRYTOx45/XGBxYN6OHjwIOs7BZHBpdxz2BgmBMh6Xy2TZ5WrHwakbrHroeebAoThEmDnzp3mv60fVhLgqtaNPF077PqnT5+KijckCR6BPcMOBqkTIPfbi0W/d64eOhxWuFFh51gQEIAdDLKQAOIsFUQoDD0PQMxj1xsUcbYCqgTIu19UrQvXzsuvh76Goae96zudTtdL2bdvXyNvRaFSqDG0JYAoO+UV1MGuh7hnulwjAUJRwAhiHRINv2uU9yIgIrswRI0A2fJn6368JA9jb1RARxtUFYyLfuMwXf/hwwe35yJoSoBV9kPMzXVFvyXGDehYAhIBtgakwSCJgIYSb2gSgN26BGvfKrjDCehYgp4HZOiPbQhUUlkVkMU/y/hDMsUqwCMJ6FgDz4RyMIpu4t8CG4BdFqYlAdgpSQu9jxcJI68Nrh0kE3a+IAq4JakL1CIAKxCBII/27q8hoNMUQrtENFhKiwCLnA9xY+aDYO3aVQxWEoigRQBWUQL0vwasAjotgag5pGgNlTTO77Xr4abu2rXru///9OlTUbcS3cLS2YJiAuRevsaQ7n6FpoqhwIIjhIsLJB3louJZQEJ4Hc6G57r0BsUkgNTvV2q1/h9AykOHDjWuNgJJcMGlo7pBqCUHlSROuxcjgET8U1Gm5rOgNl/DI4H0oJwGSGBIhGsagyJaWUetqXetCk6oYhmejpGdotIcOrUE8OolwP1RKIqaA8Vw9GWtMfPFCCAR4YLqWfdeAgKSXVA1zNr/XmxpGH8EDQKw3BAJAWCkcVK63r0E/aDAl5AEqsfOiFNw3IfBYEUusJOaWOrY9dQmXrp9DCQQpr4v5OFZKtDKwd5q+gFYxhIpAP09jicBUX/27Fm3RpJxgGcSPo/awEgtArAMEollTGNWhulyGHk1t4kL28hWtIZIa8lDVs8/KmAkCSG8QCwwjDpE4HobNr3KybmgFreHDx9y7rCQC3DEgSCtrcFKSNCiSYGXSfV2kAi1Lz4BakAQElcZHq1CgJyQYDm5tZRqlYIgCHVeQw1oKkdWXlo7rNs2IKYh8EzEwyKLE4D68WoHlXejhx8XfHmlAdASj0A0HyhoD4hIKXW4xaHw0Wty1Qijqoo1ehgR2sakMAbEI2O1/SO2VYodVZsqgJF6586dbe0UqkuQPLuAPOKAkDYB1rnGIHaaRY6fAywm3DNc4zwPVSFLwPQGxKemqBIgh4XZRYqWVT7jArsd4rhpZQ+CWiVmA0jDwqoEyA9zQXIPDZHK/V4sPAxSLgEl5WACT6AeAmhNBqHFQI2dNcjIE4xrbTU0u4OXNY92oZn6loOhtFvH2jKatheauVGTM/Dp5K1hHbUcWE0FqdGNHQXN5lCzg516fXG8ZE68H/fAghud6dd9JkmtQSkXWEsCuJx73zt5ozfrh2tQcyUGLkCvU92+FajSSAIBAUS1gVoEMDnWdDvQji7ZAaxZX8itkJIWh2p0Bq20/Kx+FjTrCyGhmK6nOJWqIQFUji9rCyxmFQuSSqK+wDAjQDNYuaQCNVYFAViTwZD9I3esdljOKhbWQ4jPDRQRQHJeDYlQWPKlp3dtB+tZxcKRdWUJwI1D92a+4MKdOXPmPz+/liEPHrOK8ZsFu/9WDc2hLAkwSJRSI6XiUesseLWOQeIJd79K3qVIm8yw3Dd0LSxsLEAJIng1jFLtgxCi2UAE6S9VaU7oBxEBfjZF/ixtBM9jaCjJJQz9Xq+lO5g9Hm4c0DHvNHkD7pK210C9el7H0CicGh5q6w5uDM7LhlTQmioWjF27QUDqWankbVPj2HiClAAdyyxgP7Q8hNoPnxoB1bS7BgEaA7uBs/Oku3UCjqG5prn7QxtHxMBQaxo6JVvC8/Apg1nFWxZp9yISAKlP7m6mTuBx4X2usOHU0lXNySCEIgSQWMEQ31jQUXX41DquOY94OxhPLb0SY1Tx+/shJQArGyV9SVhULDBcwkH+tKdrF+yPoYHPb1ZxJe4N5PYDIv6vYYxBHZBEwYLDRvAS9zBmnzx5YhmkwuidZQvRT9B4Uzc4zSDQlRpnA9JMX084HUNjvvhBqTGEPR2kjePdsevRRDIJix+UVADyASwF6HkusBSOx9DA12efwNYUWnMCr3M+K8yHuwHJKLSJGy8+RMpvnosfFHsD2S6KQlrUDCAnTQMxVlebSKzFGNVOXR8XahNCUkrPueXhNaoCpwqlbnSvxMITNB1ldoqydBVQL6gz2eEMIqjNxZKLH5QlwOEcGWTXUsEt9Irc9QOLTWFcY9zOYV3VpA4XahIgG4OiQgXNyVtNQK6dw+Jfybq+isUPBlPCDufwsGh2jZdNQCPqHEh3K+96cSOHNlQJEL71Cv4lvY91Fs/phNHu4Q4xRpPZCRpQJ0D4SoINzvDoQdCu3oG4h6h3OGF0M+96leJNK1gRQEUV9ALGoWQQNMT8y5cvPRa+uGvXBCYECN/axv7Wvi8Vh4II8/PzAw92RAAHFwpPsOOx6E55h+tWhRtWMCNA+EoChDX/LP0jHVCVa9cEphUTWQz+YfkdFaA6164JTCUAIaV0VTpAskJU69o1gQsBwlcSwBW65PJltqjetWsCNwKEybAJWuHaNYErAcK3iaIbLRss1SrXrgncCRC+xQk2PNvKBGida9cERQhASCldzL1uNUqD1rp2TVB0unGMcT23mF8r+RwD0GrXrgmKSoBeZNtgrbBaABHXJsnIG4VqCEDIh06s5fGzXqph6haeUB0BCNlQXMmXSmaxDwjkrGsfx942VEuAfuQ6g6U8mXSJIR02c4by5rQvei9aQ4B+ZAlBM4oWB8wsJAOuM42ifVy0lgAz6KB9h9zMoIoZAaYcMwJMM0II/wJv+riuzREqgwAAAABJRU5ErkJggg==\";\n\n  // src/client/assets/favicon.ico\n  var favicon_default2 = \"data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAEAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADb29sH8/PzFuPj4wkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAObm5grf399+4ODg1d7e3uzf39/Z4ODggt/f3xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN/f3wjc3Nyw6enp/+vr6//t7e3/6enp/+bm5v/h4eHT3d3dTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADd3d1i5+fn/+7u7v/////////////////x8fH/5eXl/9/f3/7g4OCd3NzcFgAAAAAAAAAAAAAAAAAAAAAAAAAA3Nzcr+np6f//////+vr6/+np6f/4+Pj///////v7+//p6en/6Ojo/93d3crh4eERAAAAAAAAAAAAAAAAAAAAANzc3Ljp6en/9PT0/+Pj4//Z2dn/3d3d/+7u7v/+/v7//////+/v7//o6Oj/3d3dcgAAAAAAAAAAAAAAAAAAAADe3t575eXl/9zc3P/l5eX/7u7u/+np6f/c3Nz/4uLi//r6+v/+/v7/6enp/9zc3K0AAAAAAAAAAAAAAAAAAAAA3d3dTOHh4f/r6+v/////////////////9/f3/+jo6P/6+vr//f39/+jo6P/b29ujAAAAAAAAAAAAAAAAAAAAAN3d3Yno6Oj/+/v7//z8/P/l5eX/8vLy/////////////////+3t7f/k5OT/3NzcZgAAAAAAAAAAAAAAAAAAAADd3d2O6Ojo//r6+v/9/f3/5+fn/9vb2//l5eX/7Ozs/+Xl5f/c3Nz/5eXl/93d3Z8AAAAAAAAAAAAAAAAAAAAA3t7eTuTk5P/q6ur//v7+///////y8vL/39/f/9nZ2f/i4uL/9PT0/+rq6v/c3NzT////AwAAAAAAAAAAAAAAAMzMzAXd3d2l6Ojo/+fn5//39/f///////v7+//r6+v/+Pj4///////p6en/29vbyICAgAIAAAAAAAAAAAAAAAAAAAAA29vbB9/f33nf39/w5ubm/+3t7f/9/f3////////////w8PD/6enp/93d3XgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2NjYLt/f37bj4+P/6Ojo/+3t7f/r6+v/6enp/93d3brY2NgNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgIAC39/fYODg4MTe3t7g39/fzuDg4HzV1dUMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA6urqDP///wMAAAAAAAAAAAAAAAAAAAAAAAAAAPj/AADgPwAAwB8AAMAHAADAAwAAwAMAAMADAADAAwAAwAMAAMADAADAAQAAwAEAAOADAAD4AwAA/AcAAP+fAAAoAAAAIAAAAEAAAAABACAAAAAAAIAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8C39/fMODg4GLf399/39/ff9/f32Dj4+MtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3d3dU+Dg4MPe3t765ubm/+bm5v/m5ub/5ubm/9/f3/jh4eG439/fQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA6OjoC97e3pvi4uL/5OTk/97e3v/c3Nz/3Nzc/9zc3P/d3d3/3t7e/+Xl5f/g4OD64ODgktHR0RYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANXV1Qbd3d2s6Ojo/97e3v/c3Nz/3Nzc/+Hh4f/l5eX/5OTk/9/f3//c3Nz/3d3d/97e3v/m5ub/4eHh2t7e3lUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3Nzce+fn5//d3d3/3Nzc/+Pj4//09PT//f39////////////+/v7/+3t7f/e3t7/3Nzc/93d3f/i4uL/4eHh/9/f36ba2toiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANfX1yDe3t7v4ODg/9zc3P/k5OT//Pz8//////////////////////////////////j4+P/m5ub/3Nzc/9zc3P/e3t7/5ubm/+Dg4Ofd3d1p////AwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3Nzcdefn5//c3Nz/3t7e//n5+f////////////////////////////////////////////7+/v/x8fH/39/f/9zc3P/d3d3/4ODg/+Xl5f/g4OC02dnZGwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADf39+15OTk/9zc3P/n5+f/////////////////9/f3/+jo6P/x8fH//v7+///////////////////////6+vr/6Ojo/9zc3P/c3Nz/3d3d/+fn5//e3t7L2dnZFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzMzMBd3d3dHi4uL/3Nzc/+/v7//////////////////j4+P/29vb/9zc3P/l5eX/9/f3////////////////////////////8/Pz/+Hh4f/c3Nz/3d3d/+jo6P/d3d2cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADV1dUG3Nzc1OLi4v/c3Nz/7+/v///////5+fn/6+vr/97e3v/d3d3/3d3d/9zc3P/e3t7/7e3t//39/f//////////////////////+/v7/+Pj4//c3Nz/3t7e/97e3vnZ2dkvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADd3d295OTk/9zc3P/m5ub/7e3t/97e3v/c3Nz/3d3d/9zc3P/c3Nz/3d3d/93d3f/c3Nz/4+Pj//X19f//////////////////////+Pj4/97e3v/d3d3/5+fn/97e3n0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN3d3Ybn5+f/3d3d/93d3f/c3Nz/3d3d/9zc3P/e3t7/4uLi/+Li4v/f39//3Nzc/93d3f/c3Nz/3d3d/+rq6v/8/Pz/////////////////5ubm/9zc3P/l5eX/3NzcsQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4uLiLN7e3vLf39//3d3d/93d3f/d3d3/7Ozs//n5+f/+/v7//v7+//v7+//w8PD/4ODg/9zc3P/d3d3/29vb/+np6f/////////////////r6+v/3Nzc/+Pj4//e3t7CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3Nzcv+Tk5P/d3d3/3d3d//Pz8//////////////////////////////////7+/v/6enp/93d3f/b29v/6urq/////////////////+rq6v/c3Nz/5OTk/93d3boAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANzc3CTe3t7x39/f/9zc3P/t7e3/////////////////////////////////////////////////9vb2//Hx8f/9/f3////////////+/v7/4+Pj/9zc3P/m5ub/3t7ekgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3NzcXuXl5f/d3d3/3t7e//v7+/////////////39/f/u7u7/7e3t//z8/P////////////////////////////////////////////Ly8v/c3Nz/3d3d/+Li4vve3t5FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADe3t6C5+fn/9zc3P/j4+P/////////////////7+/v/9vb2//c3Nz/4eHh//Pz8//////////////////////////////////29vb/39/f/93d3f/f39//3d3d697e3hcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN3d3Yfm5ub/3Nzc/+Pj4//////////////////y8vL/3Nzc/9zc3P/c3Nz/3d3d/+jo6P/29vb//Pz8//z8/P/4+Pj/7Ozs/97e3v/c3Nz/3d3d/93d3f/l5eX/3d3dcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3t7ebebm5v/d3d3/39/f//v7+//////////////////09PT/4uLi/9zc3P/d3d3/3Nzc/93d3f/f39//39/f/93d3f/c3Nz/3Nzc/9zc3P/d3d3/3d3d/+Pj4//d3d3Kv7+/BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg4OA54ODg/d7e3v/c3Nz/7u7u///////////////////////8/Pz/6+vr/93d3f/c3Nz/3d3d/93d3f/d3d3/3d3d/9zc3P/e3t7/7e3t/+7u7v/c3Nz/39/f/97e3u3g4OAZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANXV1Qbc3NzK4+Pj/93d3f/e3t7/8vLy////////////////////////////9vb2/+Pj4//c3Nz/3d3d/93d3f/d3d3/6+vr//n5+f//////9vb2/9zc3P/e3t7/3Nzc+dvb2ysAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN3d3Uri4uL939/f/93d3f/d3d3/6urq//v7+////////////////////////f39/+3t7f/e3t7/29vb/9/f3//9/f3////////////29vb/3Nzc/97e3v/d3d313d3dJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANzc3Hzk5OT/4ODg/93d3f/c3Nz/4ODg//Pz8/////////////////////////////j4+P/s7Oz/9vb2/////////////////+7u7v/c3Nz/4ODg/93d3eHb29sOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN3d3Wnh4eHs5eXl/93d3f/c3Nz/3Nzc/+fn5//6+vr////////////////////////////////////////////8/Pz/4eHh/9zc3P/m5ub/3d3dpwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANnZ2Sjf39+u4uLi/+Hh4f/d3d3/3Nzc/9/f3//w8PD//v7+/////////////////////////////f39/+fn5//c3Nz/3t7e/+Hh4f3g4OBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADe3t5c4ODg3+bm5v/e3t7/3Nzc/9zc3P/l5eX/9fX1//39/f/+/v7//Pz8//T09P/k5OT/3Nzc/93d3f/o6Oj/3d3dnf///wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADi4uIa4ODgmuDg4P3j4+P/3d3d/9zc3P/c3Nz/4ODg/+Li4v/g4OD/3Nzc/9zc3P/e3t7/6Ojo/93d3b7Pz88QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ODgSeDg4NDn5+f/4uLi/97e3v/d3d3/3d3d/93d3f/f39//5OTk/+Li4v/e3t6k1dXVEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA29vbDt/f33jg4ODW39/f/OPj4//k5OT/4uLi/9/f3/Lh4eG54ODgUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANHR0Qvh4eEz3t7eVN3d3Vrj4+NI4ODgIQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//////gP///wA///wAD//4AAf/+AAB//AAAH/wAAA/8AAAH+AAAB/gAAAP8AAAD/AAAA/wAAAP+AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAH8AAAB/AAAAf4AAAH/AAAB/4AAA//AAAP/8AAD//gAB//+AA///wA////A///////\";\n\n  // src/client/routes/index.ts\n  init_reload();\n  init_store();\n  init_src();\n  var routes = [\n    {\n      match: \"/\",\n      component: () => Promise.resolve().then(() => (init_page(), page_exports)),\n      props: { title: \"Auth\", icon: \"key\" }\n    },\n    {\n      match: \"/data/:file?\",\n      component: () => Promise.resolve().then(() => (init_page3(), page_exports2)),\n      props: { title: \"Data\", icon: \"database\", menu: \"/data\" }\n    },\n    {\n      match: \"/files/:folder?\",\n      component: () => Promise.resolve().then(() => (init_page5(), page_exports3)),\n      props: { title: \"Files\", icon: \"hard-drive\", menu: \"/files\" }\n    },\n    {\n      match: \"/users/:role?\",\n      component: () => Promise.resolve().then(() => (init_page7(), page_exports4)),\n      props: { title: \"Users\", icon: \"users\", menu: \"/users\" }\n    },\n    {\n      match: \"/logs\",\n      component: () => Promise.resolve().then(() => (init_page8(), page_exports5)),\n      props: { title: \"Logs\", icon: \"clock\", menu: \"/logs\" }\n    },\n    {\n      match: \"/settings\",\n      component: () => Promise.resolve().then(() => (init_page9(), page_exports6)),\n      props: { title: \"Settings\", icon: \"settings\", menu: \"/settings\" }\n    },\n    {\n      match: \"*\",\n      component: () => Promise.resolve().then(() => (init__(), __exports)),\n      props: { title: \"404\", icon: \"alert-triangle\" }\n    }\n  ];\n  var page = derived(pattern, ($pattern, set) => {\n    const route = routes.find(({ match }) => $pattern(match));\n    set(route);\n  });\n\n  // src/client/components/Router.svelte\n  init_src();\n  var file32 = \"src/client/components/Router.svelte\";\n  function get_then_context(ctx) {\n    ctx[2] = ctx[3].default;\n  }\n  function create_catch_block(ctx) {\n    const block2 = {\n      c: noop,\n      m: noop,\n      i: noop,\n      o: noop,\n      d: noop\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_catch_block.name,\n      type: \"catch\",\n      source: '(1:0) <script lang=\\\\\"ts\\\\\" context=\\\\\"module\\\\\">import { click, prefs, path }',\n      ctx\n    });\n    return block2;\n  }\n  function create_then_block(ctx) {\n    get_then_context(ctx);\n    let route;\n    let current;\n    route = new /*Route*/\n    ctx[2]({ $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(route.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(route, target, anchor);\n        current = true;\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(route.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(route.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(route, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_then_block.name,\n      type: \"then\",\n      source: \"(19:50)      <Route /> {/await}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_pending_block(ctx) {\n    const block2 = {\n      c: noop,\n      m: noop,\n      i: noop,\n      o: noop,\n      d: noop\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_pending_block.name,\n      type: \"pending\",\n      source: '(1:0) <script lang=\\\\\"ts\\\\\" context=\\\\\"module\\\\\">import { click, prefs, path }',\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment34(ctx) {\n    let title_value;\n    let link0;\n    let link1;\n    let t;\n    let await_block_anchor;\n    let promise2;\n    let current;\n    let mounted;\n    let dispose;\n    document.title = title_value = /*name*/\n    ctx[0] + \" - \" + /*$page*/\n    ctx[1].props.title;\n    let info = {\n      ctx,\n      current: null,\n      token: null,\n      hasCatch: false,\n      pending: create_pending_block,\n      then: create_then_block,\n      catch: create_catch_block,\n      value: 3,\n      blocks: [, , ,]\n    };\n    handle_promise(promise2 = /*$page*/\n    ctx[1].component(), info);\n    const block2 = {\n      c: function create() {\n        link0 = element(\"link\");\n        link1 = element(\"link\");\n        t = space();\n        await_block_anchor = empty();\n        info.block.c();\n        attr_dev(link0, \"rel\", \"icon\");\n        attr_dev(link0, \"href\", favicon_default2);\n        add_location(link0, file32, 18, 4, 406);\n        attr_dev(link1, \"rel\", \"icon\");\n        attr_dev(link1, \"type\", \"image/png\");\n        attr_dev(link1, \"href\", favicon_default);\n        add_location(link1, file32, 19, 4, 441);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        append_dev(document.head, link0);\n        append_dev(document.head, link1);\n        insert_dev(target, t, anchor);\n        insert_dev(target, await_block_anchor, anchor);\n        info.block.m(target, info.anchor = anchor);\n        info.mount = () => await_block_anchor.parentNode;\n        info.anchor = await_block_anchor;\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(window, \"click\", click, false, false, false, false);\n          mounted = true;\n        }\n      },\n      p: function update2(new_ctx, [dirty]) {\n        ctx = new_ctx;\n        if ((!current || dirty & /*name, $page*/\n        3) && title_value !== (title_value = /*name*/\n        ctx[0] + \" - \" + /*$page*/\n        ctx[1].props.title)) {\n          document.title = title_value;\n        }\n        info.ctx = ctx;\n        dirty & /*$page*/\n        2 && promise2 !== (promise2 = /*$page*/\n        ctx[1].component()) && handle_promise(promise2, info);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(info.block);\n        current = true;\n      },\n      o: function outro(local) {\n        for (let i = 0; i < 3; i += 1) {\n          const block3 = info.blocks[i];\n          transition_out(block3);\n        }\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(t);\n          detach_dev(await_block_anchor);\n        }\n        detach_dev(link0);\n        detach_dev(link1);\n        info.block.d(detaching);\n        info.token = null;\n        info = null;\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment34.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance34($$self, $$props, $$invalidate) {\n    let $page;\n    validate_store(page, \"page\");\n    component_subscribe($$self, page, ($$value) => $$invalidate(1, $page = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Router\", slots, []);\n    let { name: name2 } = $$props;\n    $$self.$$.on_mount.push(function() {\n      if (name2 === void 0 && !(\"name\" in $$props || $$self.$$.bound[$$self.$$.props[\"name\"]])) {\n        console.warn(\"<Router> was created without expected prop 'name'\");\n      }\n    });\n    const writable_props = [\"name\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Router> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"name\" in $$props2) $$invalidate(0, name2 = $$props2.name);\n    };\n    $$self.$capture_state = () => ({\n      click,\n      prefs,\n      path: path2,\n      page,\n      ico: favicon_default2,\n      png: favicon_default,\n      name: name2,\n      $page\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"name\" in $$props2) $$invalidate(0, name2 = $$props2.name);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [name2, $page];\n  }\n  var Router = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance34, create_fragment34, safe_not_equal, { name: 0 });\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Router\",\n        options: options2,\n        id: create_fragment34.name\n      });\n    }\n    get name() {\n      throw new Error(\"<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set name(value) {\n      throw new Error(\"<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n  };\n  var Router_default = Router;\n\n  // src/client/views/Footer.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n\n  // src/client/components/Search.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n  init_src();\n  var file33 = \"src/client/components/Search.svelte\";\n  function create_fragment35(ctx) {\n    let form;\n    let fieldset;\n    let label0;\n    let input0;\n    let t0;\n    let label1;\n    let input1;\n    let input1_value_value;\n    let t1;\n    let label2;\n    let input2;\n    let input2_value_value;\n    let t2;\n    let button;\n    let mounted;\n    let dispose;\n    const block2 = {\n      c: function create() {\n        form = element(\"form\");\n        fieldset = element(\"fieldset\");\n        label0 = element(\"label\");\n        input0 = element(\"input\");\n        t0 = space();\n        label1 = element(\"label\");\n        input1 = element(\"input\");\n        t1 = space();\n        label2 = element(\"label\");\n        input2 = element(\"input\");\n        t2 = space();\n        button = element(\"button\");\n        attr_dev(input0, \"name\", \"q\");\n        attr_dev(input0, \"list\", \"items\");\n        attr_dev(input0, \"type\", \"search\");\n        attr_dev(input0, \"placeholder\", \"search\");\n        attr_dev(input0, \"pattern\", \"^[\\\\w|\\\\-|:]+$\");\n        attr_dev(input0, \"class\", \"svelte-1i670oi\");\n        toggle_class(\n          input0,\n          \"collapsed\",\n          /*collapsed*/\n          ctx[0] && !/*value*/\n          ctx[1]\n        );\n        add_location(input0, file33, 12, 12, 249);\n        attr_dev(label0, \"class\", \"svelte-1i670oi\");\n        add_location(label0, file33, 11, 8, 229);\n        attr_dev(input1, \"name\", \"limit\");\n        attr_dev(input1, \"class\", \"hidden\");\n        input1.value = input1_value_value = /*$query*/\n        ctx[2].limit;\n        add_location(input1, file33, 30, 12, 845);\n        attr_dev(label1, \"class\", \"svelte-1i670oi\");\n        add_location(label1, file33, 29, 8, 825);\n        attr_dev(input2, \"name\", \"page\");\n        attr_dev(input2, \"class\", \"hidden\");\n        input2.value = input2_value_value = /*$query*/\n        ctx[2].page;\n        add_location(input2, file33, 33, 12, 949);\n        attr_dev(label2, \"class\", \"svelte-1i670oi\");\n        add_location(label2, file33, 32, 8, 929);\n        add_location(fieldset, file33, 10, 4, 210);\n        attr_dev(button, \"class\", \"hidden\");\n        add_location(button, file33, 36, 4, 1043);\n        attr_dev(form, \"method\", \"GET\");\n        attr_dev(form, \"class\", \"svelte-1i670oi\");\n        add_location(form, file33, 9, 0, 167);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, form, anchor);\n        append_dev(form, fieldset);\n        append_dev(fieldset, label0);\n        append_dev(label0, input0);\n        set_input_value(\n          input0,\n          /*value*/\n          ctx[1]\n        );\n        append_dev(fieldset, t0);\n        append_dev(fieldset, label1);\n        append_dev(label1, input1);\n        append_dev(fieldset, t1);\n        append_dev(fieldset, label2);\n        append_dev(label2, input2);\n        append_dev(form, t2);\n        append_dev(form, button);\n        if (!mounted) {\n          dispose = [\n            listen_dev(\n              input0,\n              \"input\",\n              /*input0_input_handler*/\n              ctx[3]\n            ),\n            listen_dev(form, \"submit\", submit, false, false, false, false)\n          ];\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (dirty & /*value*/\n        2 && input0.value !== /*value*/\n        ctx2[1]) {\n          set_input_value(\n            input0,\n            /*value*/\n            ctx2[1]\n          );\n        }\n        if (dirty & /*collapsed, value*/\n        3) {\n          toggle_class(\n            input0,\n            \"collapsed\",\n            /*collapsed*/\n            ctx2[0] && !/*value*/\n            ctx2[1]\n          );\n        }\n        if (dirty & /*$query*/\n        4 && input1_value_value !== (input1_value_value = /*$query*/\n        ctx2[2].limit) && input1.value !== input1_value_value) {\n          prop_dev(input1, \"value\", input1_value_value);\n        }\n        if (dirty & /*$query*/\n        4 && input2_value_value !== (input2_value_value = /*$query*/\n        ctx2[2].page) && input2.value !== input2_value_value) {\n          prop_dev(input2, \"value\", input2_value_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(form);\n        }\n        mounted = false;\n        run_all(dispose);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment35.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance35($$self, $$props, $$invalidate) {\n    let $query;\n    validate_store(query2, \"query\");\n    component_subscribe($$self, query2, ($$value) => $$invalidate(2, $query = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Search\", slots, []);\n    let { collapsed = false } = $$props;\n    let value;\n    const writable_props = [\"collapsed\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Search> was created with unknown prop '${key}'`);\n    });\n    function input0_input_handler() {\n      value = this.value;\n      $$invalidate(1, value);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"collapsed\" in $$props2) $$invalidate(0, collapsed = $$props2.collapsed);\n    };\n    $$self.$capture_state = () => ({ submit, query: query2, collapsed, value, $query });\n    $$self.$inject_state = ($$props2) => {\n      if (\"collapsed\" in $$props2) $$invalidate(0, collapsed = $$props2.collapsed);\n      if (\"value\" in $$props2) $$invalidate(1, value = $$props2.value);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [collapsed, value, $query, input0_input_handler];\n  }\n  var Search = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance35, create_fragment35, safe_not_equal, { collapsed: 0 });\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Search\",\n        options: options2,\n        id: create_fragment35.name\n      });\n    }\n    get collapsed() {\n      throw new Error(\"<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set collapsed(value) {\n      throw new Error(\"<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n  };\n  var Search_default = Search;\n\n  // src/client/views/Footer.svelte\n  init_src();\n  var file34 = \"src/client/views/Footer.svelte\";\n  function create_else_block5(ctx) {\n    let p;\n    const block2 = {\n      c: function create() {\n        p = element(\"p\");\n        p.textContent = `\\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Jsonik`;\n        attr_dev(p, \"class\", \"text-center\");\n        add_location(p, file34, 9, 8, 244);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, p, anchor);\n      },\n      p: noop,\n      i: noop,\n      o: noop,\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(p);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_else_block5.name,\n      type: \"else\",\n      source: \"(8:4) {:else}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block16(ctx) {\n    let search2;\n    let current;\n    search2 = new Search_default({ $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(search2.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(search2, target, anchor);\n        current = true;\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(search2.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(search2.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(search2, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block16.name,\n      type: \"if\",\n      source: \"(6:4) {#if $path[0]}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment36(ctx) {\n    let footer;\n    let current_block_type_index;\n    let if_block;\n    let current;\n    const if_block_creators = [create_if_block16, create_else_block5];\n    const if_blocks = [];\n    function select_block_type(ctx2, dirty) {\n      if (\n        /*$path*/\n        ctx2[0][0]\n      ) return 0;\n      return 1;\n    }\n    current_block_type_index = select_block_type(ctx, -1);\n    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n    const block2 = {\n      c: function create() {\n        footer = element(\"footer\");\n        if_block.c();\n        attr_dev(footer, \"class\", \"pos-sticky container cols svelte-1aqpy8p\");\n        add_location(footer, file34, 5, 0, 143);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, footer, anchor);\n        if_blocks[current_block_type_index].m(footer, null);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        let previous_block_index = current_block_type_index;\n        current_block_type_index = select_block_type(ctx2, dirty);\n        if (current_block_type_index === previous_block_index) {\n          if_blocks[current_block_type_index].p(ctx2, dirty);\n        } else {\n          group_outros();\n          transition_out(if_blocks[previous_block_index], 1, 1, () => {\n            if_blocks[previous_block_index] = null;\n          });\n          check_outros();\n          if_block = if_blocks[current_block_type_index];\n          if (!if_block) {\n            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);\n            if_block.c();\n          } else {\n            if_block.p(ctx2, dirty);\n          }\n          transition_in(if_block, 1);\n          if_block.m(footer, null);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(footer);\n        }\n        if_blocks[current_block_type_index].d();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment36.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance36($$self, $$props, $$invalidate) {\n    let $path;\n    validate_store(path2, \"path\");\n    component_subscribe($$self, path2, ($$value) => $$invalidate(0, $path = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Footer\", slots, []);\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Footer> was created with unknown prop '${key}'`);\n    });\n    $$self.$capture_state = () => ({ path: path2, Search: Search_default, $path });\n    return [$path];\n  }\n  var Footer = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance36, create_fragment36, safe_not_equal, {});\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Footer\",\n        options: options2,\n        id: create_fragment36.name\n      });\n    }\n  };\n  var Footer_default = Footer;\n\n  // src/client/views/Main.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n\n  // src/client/routes/logs/nav.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n\n  // src/client/components/Paginator.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n  init_Icon();\n  init_runtime();\n  var { console: console_12 } = globals;\n  var file35 = \"src/client/components/Paginator.svelte\";\n  function get_each_context10(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[1] = list2[i];\n    return child_ctx;\n  }\n  function get_each_context_16(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[15] = list2[i];\n    child_ctx[17] = i;\n    return child_ctx;\n  }\n  function create_if_block17(ctx) {\n    let each_1_anchor;\n    let each_value_1 = ensure_array_like_dev(\n      /*spreaded*/\n      ctx[4](\n        /*pages*/\n        ctx[3]\n      )\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value_1.length; i += 1) {\n      each_blocks[i] = create_each_block_16(get_each_context_16(ctx, each_value_1, i));\n    }\n    const block2 = {\n      c: function create() {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        each_1_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(target, anchor);\n          }\n        }\n        insert_dev(target, each_1_anchor, anchor);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*spreaded, pages, active, cur, Number*/\n        89) {\n          each_value_1 = ensure_array_like_dev(\n            /*spreaded*/\n            ctx2[4](\n              /*pages*/\n              ctx2[3]\n            )\n          );\n          let i;\n          for (i = 0; i < each_value_1.length; i += 1) {\n            const child_ctx = get_each_context_16(ctx2, each_value_1, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n            } else {\n              each_blocks[i] = create_each_block_16(child_ctx);\n              each_blocks[i].c();\n              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n          for (; i < each_blocks.length; i += 1) {\n            each_blocks[i].d(1);\n          }\n          each_blocks.length = each_value_1.length;\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(each_1_anchor);\n        }\n        destroy_each(each_blocks, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block17.name,\n      type: \"if\",\n      source: \"(50:8) {#if pages.length}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_else_block6(ctx) {\n    let button;\n    let t_value = (\n      /*page*/\n      ctx[15] + \"\"\n    );\n    let t;\n    let button_disabled_value;\n    let mounted;\n    let dispose;\n    function click_handler() {\n      return (\n        /*click_handler*/\n        ctx[10](\n          /*page*/\n          ctx[15]\n        )\n      );\n    }\n    const block2 = {\n      c: function create() {\n        button = element(\"button\");\n        t = text(t_value);\n        attr_dev(button, \"class\", \"link svelte-zk2d7b\");\n        button.disabled = button_disabled_value = /*active*/\n        ctx[0] === /*page*/\n        ctx[15];\n        add_location(button, file35, 71, 24, 1893);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, button, anchor);\n        append_dev(button, t);\n        if (!mounted) {\n          dispose = listen_dev(button, \"click\", click_handler, false, false, false, false);\n          mounted = true;\n        }\n      },\n      p: function update2(new_ctx, dirty) {\n        ctx = new_ctx;\n        if (dirty & /*spreaded, pages*/\n        24 && t_value !== (t_value = /*page*/\n        ctx[15] + \"\")) set_data_dev(t, t_value);\n        if (dirty & /*active, spreaded, pages*/\n        25 && button_disabled_value !== (button_disabled_value = /*active*/\n        ctx[0] === /*page*/\n        ctx[15])) {\n          prop_dev(button, \"disabled\", button_disabled_value);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(button);\n        }\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_else_block6.name,\n      type: \"else\",\n      source: \"(55:20) {:else}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_18(ctx) {\n    let span;\n    const block2 = {\n      c: function create() {\n        span = element(\"span\");\n        span.textContent = \"...\";\n        add_location(span, file35, 69, 24, 1824);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, span, anchor);\n      },\n      p: noop,\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(span);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_18.name,\n      type: \"if\",\n      source: '(53:20) {#if typeof page === \\\\\"boolean\\\\\"}',\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block_16(ctx) {\n    let li;\n    let t;\n    function select_block_type(ctx2, dirty) {\n      if (typeof /*page*/\n      ctx2[15] === \"boolean\") return create_if_block_18;\n      return create_else_block6;\n    }\n    let current_block_type = select_block_type(ctx, -1);\n    let if_block = current_block_type(ctx);\n    const block2 = {\n      c: function create() {\n        li = element(\"li\");\n        if_block.c();\n        t = space();\n        attr_dev(li, \"class\", \"svelte-zk2d7b\");\n        add_location(li, file35, 67, 16, 1743);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, li, anchor);\n        if_block.m(li, null);\n        append_dev(li, t);\n      },\n      p: function update2(ctx2, dirty) {\n        if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {\n          if_block.p(ctx2, dirty);\n        } else {\n          if_block.d(1);\n          if_block = current_block_type(ctx2);\n          if (if_block) {\n            if_block.c();\n            if_block.m(li, t);\n          }\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(li);\n        }\n        if_block.d();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block_16.name,\n      type: \"each\",\n      source: \"(51:12) {#each spreaded(pages) as page, i}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block10(ctx) {\n    let option;\n    let t_value = (\n      /*limit*/\n      ctx[1] + \"\"\n    );\n    let t;\n    let option_value_value;\n    const block2 = {\n      c: function create() {\n        option = element(\"option\");\n        t = text(t_value);\n        option.selected = true;\n        option.__value = option_value_value = /*limit*/\n        ctx[1];\n        set_input_value(option, option.__value);\n        add_location(option, file35, 94, 12, 2561);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, option, anchor);\n        append_dev(option, t);\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*limits*/\n        4 && t_value !== (t_value = /*limit*/\n        ctx2[1] + \"\")) set_data_dev(t, t_value);\n        if (dirty & /*limits*/\n        4 && option_value_value !== (option_value_value = /*limit*/\n        ctx2[1])) {\n          prop_dev(option, \"__value\", option_value_value);\n          set_input_value(option, option.__value);\n        }\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(option);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block10.name,\n      type: \"each\",\n      source: \"(78:8) {#each limits as limit}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment37(ctx) {\n    let nav;\n    let ul;\n    let li0;\n    let button0;\n    let icon0;\n    let button0_disabled_value;\n    let t0;\n    let t1;\n    let li1;\n    let button1;\n    let icon1;\n    let button1_disabled_value;\n    let spreading_action;\n    let t2;\n    let select;\n    let current;\n    let mounted;\n    let dispose;\n    icon0 = new Icon_default({\n      props: { icon: \"arrow-left\" },\n      $$inline: true\n    });\n    let if_block = (\n      /*pages*/\n      ctx[3].length && create_if_block17(ctx)\n    );\n    icon1 = new Icon_default({\n      props: { icon: \"arrow-right\" },\n      $$inline: true\n    });\n    let each_value = ensure_array_like_dev(\n      /*limits*/\n      ctx[2]\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block10(get_each_context10(ctx, each_value, i));\n    }\n    const block2 = {\n      c: function create() {\n        nav = element(\"nav\");\n        ul = element(\"ul\");\n        li0 = element(\"li\");\n        button0 = element(\"button\");\n        create_component(icon0.$$.fragment);\n        t0 = space();\n        if (if_block) if_block.c();\n        t1 = space();\n        li1 = element(\"li\");\n        button1 = element(\"button\");\n        create_component(icon1.$$.fragment);\n        t2 = space();\n        select = element(\"select\");\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        attr_dev(button0, \"class\", \"box svelte-zk2d7b\");\n        button0.disabled = button0_disabled_value = /*active*/\n        ctx[0] === 1;\n        add_location(button0, file35, 61, 12, 1513);\n        attr_dev(li0, \"class\", \"svelte-zk2d7b\");\n        add_location(li0, file35, 60, 8, 1496);\n        attr_dev(button1, \"class\", \"box svelte-zk2d7b\");\n        button1.disabled = button1_disabled_value = /*active*/\n        ctx[0] === /*pages*/\n        ctx[3].length;\n        add_location(button1, file35, 83, 12, 2262);\n        attr_dev(li1, \"class\", \"svelte-zk2d7b\");\n        add_location(li1, file35, 82, 8, 2245);\n        attr_dev(ul, \"class\", \"paginator cols col-fit svelte-zk2d7b\");\n        attr_dev(ul, \"role\", \"navigation\");\n        add_location(ul, file35, 59, 4, 1420);\n        attr_dev(select, \"class\", \"svelte-zk2d7b\");\n        if (\n          /*limit*/\n          ctx[1] === void 0\n        ) add_render_callback(() => (\n          /*select_change_handler*/\n          ctx[11].call(select)\n        ));\n        add_location(select, file35, 92, 4, 2489);\n        attr_dev(nav, \"class\", \"cols\");\n        add_location(nav, file35, 58, 0, 1397);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, nav, anchor);\n        append_dev(nav, ul);\n        append_dev(ul, li0);\n        append_dev(li0, button0);\n        mount_component(icon0, button0, null);\n        append_dev(ul, t0);\n        if (if_block) if_block.m(ul, null);\n        append_dev(ul, t1);\n        append_dev(ul, li1);\n        append_dev(li1, button1);\n        mount_component(icon1, button1, null);\n        append_dev(nav, t2);\n        append_dev(nav, select);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(select, null);\n          }\n        }\n        select_option(\n          select,\n          /*limit*/\n          ctx[1],\n          true\n        );\n        current = true;\n        if (!mounted) {\n          dispose = [\n            listen_dev(\n              button0,\n              \"click\",\n              /*prev*/\n              ctx[5],\n              false,\n              false,\n              false,\n              false\n            ),\n            listen_dev(\n              button1,\n              \"click\",\n              /*next*/\n              ctx[7],\n              false,\n              false,\n              false,\n              false\n            ),\n            action_destroyer(spreading_action = spreading.call(null, ul)),\n            listen_dev(\n              select,\n              \"change\",\n              /*select_change_handler*/\n              ctx[11]\n            )\n          ];\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (!current || dirty & /*active*/\n        1 && button0_disabled_value !== (button0_disabled_value = /*active*/\n        ctx2[0] === 1)) {\n          prop_dev(button0, \"disabled\", button0_disabled_value);\n        }\n        if (\n          /*pages*/\n          ctx2[3].length\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n          } else {\n            if_block = create_if_block17(ctx2);\n            if_block.c();\n            if_block.m(ul, t1);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n        if (!current || dirty & /*active, pages*/\n        9 && button1_disabled_value !== (button1_disabled_value = /*active*/\n        ctx2[0] === /*pages*/\n        ctx2[3].length)) {\n          prop_dev(button1, \"disabled\", button1_disabled_value);\n        }\n        if (dirty & /*limits*/\n        4) {\n          each_value = ensure_array_like_dev(\n            /*limits*/\n            ctx2[2]\n          );\n          let i;\n          for (i = 0; i < each_value.length; i += 1) {\n            const child_ctx = get_each_context10(ctx2, each_value, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n            } else {\n              each_blocks[i] = create_each_block10(child_ctx);\n              each_blocks[i].c();\n              each_blocks[i].m(select, null);\n            }\n          }\n          for (; i < each_blocks.length; i += 1) {\n            each_blocks[i].d(1);\n          }\n          each_blocks.length = each_value.length;\n        }\n        if (dirty & /*limit, limits*/\n        6) {\n          select_option(\n            select,\n            /*limit*/\n            ctx2[1]\n          );\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon0.$$.fragment, local);\n        transition_in(icon1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon0.$$.fragment, local);\n        transition_out(icon1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(nav);\n        }\n        destroy_component(icon0);\n        if (if_block) if_block.d();\n        destroy_component(icon1);\n        destroy_each(each_blocks, detaching);\n        mounted = false;\n        run_all(dispose);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment37.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function spreading(ul) {\n    console.log(ul.offsetWidth);\n    const RO = new ResizeObserver(() => {\n      const { offsetWidth } = ul;\n    });\n    RO.observe(ul);\n    return {\n      destroy() {\n        RO.disconnect();\n      }\n    };\n  }\n  function instance37($$self, $$props, $$invalidate) {\n    let pages;\n    let spreaded;\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Paginator\", slots, []);\n    const dispatch2 = createEventDispatcher();\n    let { total = 10 } = $$props;\n    let { limit = 10 } = $$props;\n    let { limits = [10, 20, 30, 40, 50, 100] } = $$props;\n    let { active: active2 = 1 } = $$props;\n    let { spread = 3 } = $$props;\n    const prev = () => (active2 > 1 && $$invalidate(0, active2--, active2), dispatch2(\"prev\", active2));\n    const cur = (i) => ($$invalidate(0, active2 = i), dispatch2(\"current\", i));\n    const next = () => (active2 < pages.length && $$invalidate(0, active2++, active2), dispatch2(\"next\", active2));\n    const writable_props = [\"total\", \"limit\", \"limits\", \"active\", \"spread\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console_12.warn(`<Paginator> was created with unknown prop '${key}'`);\n    });\n    const click_handler = (page2) => cur(Number(page2));\n    function select_change_handler() {\n      limit = select_value(this);\n      $$invalidate(1, limit);\n      $$invalidate(2, limits);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"total\" in $$props2) $$invalidate(8, total = $$props2.total);\n      if (\"limit\" in $$props2) $$invalidate(1, limit = $$props2.limit);\n      if (\"limits\" in $$props2) $$invalidate(2, limits = $$props2.limits);\n      if (\"active\" in $$props2) $$invalidate(0, active2 = $$props2.active);\n      if (\"spread\" in $$props2) $$invalidate(9, spread = $$props2.spread);\n    };\n    $$self.$capture_state = () => ({\n      Icon: Icon_default,\n      createEventDispatcher,\n      dispatch: dispatch2,\n      total,\n      limit,\n      limits,\n      active: active2,\n      spread,\n      prev,\n      cur,\n      next,\n      spreading,\n      pages,\n      spreaded\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"total\" in $$props2) $$invalidate(8, total = $$props2.total);\n      if (\"limit\" in $$props2) $$invalidate(1, limit = $$props2.limit);\n      if (\"limits\" in $$props2) $$invalidate(2, limits = $$props2.limits);\n      if (\"active\" in $$props2) $$invalidate(0, active2 = $$props2.active);\n      if (\"spread\" in $$props2) $$invalidate(9, spread = $$props2.spread);\n      if (\"pages\" in $$props2) $$invalidate(3, pages = $$props2.pages);\n      if (\"spreaded\" in $$props2) $$invalidate(4, spreaded = $$props2.spreaded);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    $$self.$$.update = () => {\n      if ($$self.$$.dirty & /*total, limit*/\n      258) {\n        $: $$invalidate(3, pages = Array.from({ length: Math.ceil(total / limit) }, (_, i) => i + 1));\n      }\n      if ($$self.$$.dirty & /*spread, active, pages*/\n      521) {\n        $: $$invalidate(4, spreaded = (items) => {\n          const half = Math.trunc(spread / 2);\n          const before2 = active2 - half;\n          const after2 = active2 + half;\n          const from = before2 >= 1 ? before2 - 1 : 1;\n          const around = items.slice(from, after2);\n          const visible = [1, pages.length, ...around];\n          const result = items.map((i) => !visible.includes(i) ? around.every((a) => a > i) : i);\n          const uniq3 = (a) => [...new Set(a)];\n          return spread ? uniq3(result) : items;\n        });\n      }\n    };\n    return [\n      active2,\n      limit,\n      limits,\n      pages,\n      spreaded,\n      prev,\n      cur,\n      next,\n      total,\n      spread,\n      click_handler,\n      select_change_handler\n    ];\n  }\n  var Paginator = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance37, create_fragment37, safe_not_equal, {\n        total: 8,\n        limit: 1,\n        limits: 2,\n        active: 0,\n        spread: 9\n      });\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Paginator\",\n        options: options2,\n        id: create_fragment37.name\n      });\n    }\n    get total() {\n      throw new Error(\"<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set total(value) {\n      throw new Error(\"<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    get limit() {\n      throw new Error(\"<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set limit(value) {\n      throw new Error(\"<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    get limits() {\n      throw new Error(\"<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set limits(value) {\n      throw new Error(\"<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    get active() {\n      throw new Error(\"<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set active(value) {\n      throw new Error(\"<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    get spread() {\n      throw new Error(\"<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set spread(value) {\n      throw new Error(\"<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n  };\n  var Paginator_default = Paginator;\n\n  // src/client/routes/logs/nav.svelte\n  init_logs();\n  init_src();\n  function create_fragment38(ctx) {\n    let paginator;\n    let updating_limit;\n    let updating_active;\n    let current;\n    function paginator_limit_binding(value) {\n      ctx[2](value);\n    }\n    function paginator_active_binding(value) {\n      ctx[3](value);\n    }\n    let paginator_props = { total: (\n      /*$logs*/\n      ctx[1].total\n    ), spread: 3 };\n    if (\n      /*$query*/\n      ctx[0].limit !== void 0\n    ) {\n      paginator_props.limit = /*$query*/\n      ctx[0].limit;\n    }\n    if (\n      /*$query*/\n      ctx[0].page !== void 0\n    ) {\n      paginator_props.active = /*$query*/\n      ctx[0].page;\n    }\n    paginator = new Paginator_default({ props: paginator_props, $$inline: true });\n    binding_callbacks.push(() => bind(paginator, \"limit\", paginator_limit_binding));\n    binding_callbacks.push(() => bind(paginator, \"active\", paginator_active_binding));\n    const block2 = {\n      c: function create() {\n        create_component(paginator.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(paginator, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const paginator_changes = {};\n        if (dirty & /*$logs*/\n        2) paginator_changes.total = /*$logs*/\n        ctx2[1].total;\n        if (!updating_limit && dirty & /*$query*/\n        1) {\n          updating_limit = true;\n          paginator_changes.limit = /*$query*/\n          ctx2[0].limit;\n          add_flush_callback(() => updating_limit = false);\n        }\n        if (!updating_active && dirty & /*$query*/\n        1) {\n          updating_active = true;\n          paginator_changes.active = /*$query*/\n          ctx2[0].page;\n          add_flush_callback(() => updating_active = false);\n        }\n        paginator.$set(paginator_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(paginator.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(paginator.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(paginator, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment38.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance38($$self, $$props, $$invalidate) {\n    let $query;\n    let $logs;\n    validate_store(query2, \"query\");\n    component_subscribe($$self, query2, ($$value) => $$invalidate(0, $query = $$value));\n    validate_store(logs, \"logs\");\n    component_subscribe($$self, logs, ($$value) => $$invalidate(1, $logs = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Nav\", slots, []);\n    \"use strict\";\n    query2.set({\n      limit: $query.limit || 100,\n      page: $query.page || 1\n    });\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Nav> was created with unknown prop '${key}'`);\n    });\n    function paginator_limit_binding(value) {\n      if ($$self.$$.not_equal($query.limit, value)) {\n        $query.limit = value;\n        query2.set($query);\n      }\n    }\n    function paginator_active_binding(value) {\n      if ($$self.$$.not_equal($query.page, value)) {\n        $query.page = value;\n        query2.set($query);\n      }\n    }\n    $$self.$capture_state = () => ({ query: query2, logs, Paginator: Paginator_default, $query, $logs });\n    return [$query, $logs, paginator_limit_binding, paginator_active_binding];\n  }\n  var Nav = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance38, create_fragment38, safe_not_equal, {});\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Nav\",\n        options: options2,\n        id: create_fragment38.name\n      });\n    }\n  };\n  var nav_default = Nav;\n\n  // src/client/routes/users/nav.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n\n  // src/client/routes/users/role.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n\n  // src/client/routes/users/input.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n  init_Form();\n  init_src();\n  var file36 = \"src/client/routes/users/input.svelte\";\n  function create_default_slot14(ctx) {\n    let fieldset;\n    let label;\n    let input;\n    let input_autofocus_value;\n    let close_action;\n    let mounted;\n    let dispose;\n    const block2 = {\n      c: function create() {\n        fieldset = element(\"fieldset\");\n        label = element(\"label\");\n        input = element(\"input\");\n        attr_dev(input, \"name\", \"value\");\n        input.autofocus = input_autofocus_value = true;\n        input.required = /*required*/\n        ctx[1];\n        input.value = /*value*/\n        ctx[0];\n        attr_dev(\n          input,\n          \"pattern\",\n          /*pattern*/\n          ctx[2]\n        );\n        attr_dev(\n          input,\n          \"placeholder\",\n          /*placeholder*/\n          ctx[3]\n        );\n        add_location(input, file36, 34, 12, 865);\n        attr_dev(label, \"class\", \"svelte-4oyeew\");\n        add_location(label, file36, 32, 8, 795);\n        attr_dev(fieldset, \"class\", \"svelte-4oyeew\");\n        add_location(fieldset, file36, 31, 4, 776);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, fieldset, anchor);\n        append_dev(fieldset, label);\n        append_dev(label, input);\n        if (true) input.focus();\n        if (!mounted) {\n          dispose = action_destroyer(close_action = close2.call(\n            null,\n            input,\n            /*onclose*/\n            ctx[4]\n          ));\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*required*/\n        2) {\n          prop_dev(\n            input,\n            \"required\",\n            /*required*/\n            ctx2[1]\n          );\n        }\n        if (dirty & /*value*/\n        1 && input.value !== /*value*/\n        ctx2[0]) {\n          prop_dev(\n            input,\n            \"value\",\n            /*value*/\n            ctx2[0]\n          );\n        }\n        if (dirty & /*pattern*/\n        4) {\n          attr_dev(\n            input,\n            \"pattern\",\n            /*pattern*/\n            ctx2[2]\n          );\n        }\n        if (dirty & /*placeholder*/\n        8) {\n          attr_dev(\n            input,\n            \"placeholder\",\n            /*placeholder*/\n            ctx2[3]\n          );\n        }\n        if (close_action && is_function(close_action.update) && dirty & /*onclose*/\n        16) close_action.update.call(\n          null,\n          /*onclose*/\n          ctx2[4]\n        );\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(fieldset);\n        }\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot14.name,\n      type: \"slot\",\n      source: \"(28:0) <Form on:submit>\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment39(ctx) {\n    let form;\n    let current;\n    form = new Form_default({\n      props: {\n        $$slots: { default: [create_default_slot14] },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    form.$on(\n      \"submit\",\n      /*submit_handler*/\n      ctx[5]\n    );\n    const block2 = {\n      c: function create() {\n        create_component(form.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(form, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const form_changes = {};\n        if (dirty & /*$$scope, required, value, pattern, placeholder, onclose*/\n        95) {\n          form_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        form.$set(form_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(form.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(form.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(form, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment39.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function close2(node, onclose) {\n    function update2(onclose2) {\n      node.onblur = () => onclose2 ? onclose2() : fragment2.set(\"\");\n      node.onkeydown = (e) => {\n        if (e.key === \"Escape\") {\n          e.preventDefault();\n          e.stopPropagation();\n          onclose2 ? onclose2() : fragment2.set(\"\");\n        }\n      };\n    }\n    update2(onclose);\n    return { update: update2 };\n  }\n  function instance39($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Input\", slots, []);\n    let { value = \"\" } = $$props;\n    let { required = false } = $$props;\n    let { pattern: pattern2 = \"^[\\\\w|\\\\-]+$\" } = $$props;\n    let { placeholder = \"Role name\" } = $$props;\n    let { onclose = void 0 } = $$props;\n    const writable_props = [\"value\", \"required\", \"pattern\", \"placeholder\", \"onclose\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Input> was created with unknown prop '${key}'`);\n    });\n    function submit_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"value\" in $$props2) $$invalidate(0, value = $$props2.value);\n      if (\"required\" in $$props2) $$invalidate(1, required = $$props2.required);\n      if (\"pattern\" in $$props2) $$invalidate(2, pattern2 = $$props2.pattern);\n      if (\"placeholder\" in $$props2) $$invalidate(3, placeholder = $$props2.placeholder);\n      if (\"onclose\" in $$props2) $$invalidate(4, onclose = $$props2.onclose);\n    };\n    $$self.$capture_state = () => ({\n      fragment: fragment2,\n      Form: Form_default,\n      value,\n      required,\n      pattern: pattern2,\n      placeholder,\n      onclose,\n      close: close2\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"value\" in $$props2) $$invalidate(0, value = $$props2.value);\n      if (\"required\" in $$props2) $$invalidate(1, required = $$props2.required);\n      if (\"pattern\" in $$props2) $$invalidate(2, pattern2 = $$props2.pattern);\n      if (\"placeholder\" in $$props2) $$invalidate(3, placeholder = $$props2.placeholder);\n      if (\"onclose\" in $$props2) $$invalidate(4, onclose = $$props2.onclose);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [value, required, pattern2, placeholder, onclose, submit_handler];\n  }\n  var Input2 = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance39, create_fragment39, safe_not_equal, {\n        value: 0,\n        required: 1,\n        pattern: 2,\n        placeholder: 3,\n        onclose: 4\n      });\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Input\",\n        options: options2,\n        id: create_fragment39.name\n      });\n    }\n    get value() {\n      throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set value(value) {\n      throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    get required() {\n      throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set required(value) {\n      throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    get pattern() {\n      throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set pattern(value) {\n      throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    get placeholder() {\n      throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set placeholder(value) {\n      throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    get onclose() {\n      throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set onclose(value) {\n      throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n  };\n  var input_default2 = Input2;\n\n  // src/client/routes/users/role.svelte\n  init_Icon();\n  init_data();\n  init_files();\n  init_src();\n  var file37 = \"src/client/routes/users/role.svelte\";\n  function create_else_block7(ctx) {\n    let a;\n    let t0;\n    let span;\n    let t1;\n    let t2;\n    let a_href_value;\n    let a_aria_disabled_value;\n    let current;\n    let if_block0 = (\n      /*$path*/\n      ctx[2][1] === /*role*/\n      ctx[0] && create_if_block_25(ctx)\n    );\n    let if_block1 = (\n      /*$path*/\n      ctx[2][1] === /*role*/\n      ctx[0] && create_if_block_19(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        a = element(\"a\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        span = element(\"span\");\n        t1 = text(\n          /*role*/\n          ctx[0]\n        );\n        t2 = space();\n        if (if_block1) if_block1.c();\n        add_location(span, file37, 47, 8, 1270);\n        attr_dev(\n          a,\n          \"id\",\n          /*role*/\n          ctx[0]\n        );\n        attr_dev(a, \"tabindex\", \"0\");\n        attr_dev(a, \"href\", a_href_value = \"/users/\" + /*role*/\n        ctx[0]);\n        attr_dev(a, \"role\", \"button\");\n        attr_dev(a, \"aria-disabled\", a_aria_disabled_value = /*$path*/\n        ctx[2][1] === /*role*/\n        ctx[0]);\n        attr_dev(a, \"draggable\", \"false\");\n        add_location(a, file37, 34, 4, 915);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, a, anchor);\n        if (if_block0) if_block0.m(a, null);\n        append_dev(a, t0);\n        append_dev(a, span);\n        append_dev(span, t1);\n        append_dev(a, t2);\n        if (if_block1) if_block1.m(a, null);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*$path*/\n          ctx2[2][1] === /*role*/\n          ctx2[0]\n        ) {\n          if (if_block0) {\n            if_block0.p(ctx2, dirty);\n            if (dirty & /*$path, role*/\n            5) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_25(ctx2);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(a, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, () => {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if (!current || dirty & /*role*/\n        1) set_data_dev(\n          t1,\n          /*role*/\n          ctx2[0]\n        );\n        if (\n          /*$path*/\n          ctx2[2][1] === /*role*/\n          ctx2[0]\n        ) {\n          if (if_block1) {\n            if_block1.p(ctx2, dirty);\n            if (dirty & /*$path, role*/\n            5) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_19(ctx2);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(a, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, () => {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n        if (!current || dirty & /*role*/\n        1) {\n          attr_dev(\n            a,\n            \"id\",\n            /*role*/\n            ctx2[0]\n          );\n        }\n        if (!current || dirty & /*role*/\n        1 && a_href_value !== (a_href_value = \"/users/\" + /*role*/\n        ctx2[0])) {\n          attr_dev(a, \"href\", a_href_value);\n        }\n        if (!current || dirty & /*$path, role*/\n        5 && a_aria_disabled_value !== (a_aria_disabled_value = /*$path*/\n        ctx2[2][1] === /*role*/\n        ctx2[0])) {\n          attr_dev(a, \"aria-disabled\", a_aria_disabled_value);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(a);\n        }\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_else_block7.name,\n      type: \"else\",\n      source: \"(29:0) {:else}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block18(ctx) {\n    let input;\n    let current;\n    input = new input_default2({\n      props: { value: (\n        /*role*/\n        ctx[0]\n      ) },\n      $$inline: true\n    });\n    input.$on(\n      \"submit\",\n      /*renameFolder*/\n      ctx[3]\n    );\n    const block2 = {\n      c: function create() {\n        create_component(input.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(input, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const input_changes = {};\n        if (dirty & /*role*/\n        1) input_changes.value = /*role*/\n        ctx2[0];\n        input.$set(input_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(input.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(input.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(input, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block18.name,\n      type: \"if\",\n      source: \"(27:0) {#if $fragment === `#rename-${role}`}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_25(ctx) {\n    let button;\n    let icon;\n    let current;\n    let mounted;\n    let dispose;\n    icon = new Icon_default({ props: { icon: \"edit\" }, $$inline: true });\n    const block2 = {\n      c: function create() {\n        button = element(\"button\");\n        create_component(icon.$$.fragment);\n        attr_dev(button, \"class\", \"box link\");\n        add_location(button, file37, 43, 12, 1126);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, button, anchor);\n        mount_component(icon, button, null);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(button, \"click\", prevent_default(\n            /*editFolder*/\n            ctx[5]\n          ), false, true, false, false);\n          mounted = true;\n        }\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(button);\n        }\n        destroy_component(icon);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_25.name,\n      type: \"if\",\n      source: \"(38:8) {#if $path[1] === role}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_19(ctx) {\n    let button;\n    let icon;\n    let current;\n    let mounted;\n    let dispose;\n    icon = new Icon_default({ props: { icon: \"trash\" }, $$inline: true });\n    const block2 = {\n      c: function create() {\n        button = element(\"button\");\n        create_component(icon.$$.fragment);\n        attr_dev(button, \"class\", \"box link text-error\");\n        add_location(button, file37, 49, 12, 1334);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, button, anchor);\n        mount_component(icon, button, null);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            button,\n            \"click\",\n            /*click_handler*/\n            ctx[6],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(button);\n        }\n        destroy_component(icon);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_19.name,\n      type: \"if\",\n      source: \"(44:8) {#if $path[1] === role}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment40(ctx) {\n    let current_block_type_index;\n    let if_block;\n    let if_block_anchor;\n    let current;\n    const if_block_creators = [create_if_block18, create_else_block7];\n    const if_blocks = [];\n    function select_block_type(ctx2, dirty) {\n      if (\n        /*$fragment*/\n        ctx2[1] === `#rename-${/*role*/\n        ctx2[0]}`\n      ) return 0;\n      return 1;\n    }\n    current_block_type_index = select_block_type(ctx, -1);\n    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n    const block2 = {\n      c: function create() {\n        if_block.c();\n        if_block_anchor = empty();\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        if_blocks[current_block_type_index].m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        let previous_block_index = current_block_type_index;\n        current_block_type_index = select_block_type(ctx2, dirty);\n        if (current_block_type_index === previous_block_index) {\n          if_blocks[current_block_type_index].p(ctx2, dirty);\n        } else {\n          group_outros();\n          transition_out(if_blocks[previous_block_index], 1, 1, () => {\n            if_blocks[previous_block_index] = null;\n          });\n          check_outros();\n          if_block = if_blocks[current_block_type_index];\n          if (!if_block) {\n            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);\n            if_block.c();\n          } else {\n            if_block.p(ctx2, dirty);\n          }\n          transition_in(if_block, 1);\n          if_block.m(if_block_anchor.parentNode, if_block_anchor);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if_blocks[current_block_type_index].d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment40.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance40($$self, $$props, $$invalidate) {\n    let $files;\n    let $collections;\n    let $fragment;\n    let $path;\n    validate_store(files, \"files\");\n    component_subscribe($$self, files, ($$value) => $$invalidate(7, $files = $$value));\n    validate_store(collections, \"collections\");\n    component_subscribe($$self, collections, ($$value) => $$invalidate(8, $collections = $$value));\n    validate_store(fragment2, \"fragment\");\n    component_subscribe($$self, fragment2, ($$value) => $$invalidate(1, $fragment = $$value));\n    validate_store(path2, \"path\");\n    component_subscribe($$self, path2, ($$value) => $$invalidate(2, $path = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Role\", slots, []);\n    let { role } = $$props;\n    async function renameFolder(e) {\n      const data = new FormData(e.target);\n      const name2 = data.get(\"value\");\n      await folders.rename(String(role), String(name2));\n      redirect(`/files/${name2}`);\n    }\n    async function deleteFolder(folder) {\n      if ($collections.includes(folder)) {\n        await records.deleteFiles(folder, $files);\n      }\n      await folders.delete(folder);\n      redirect(\"/files\");\n    }\n    function editFolder() {\n      fragment2.set(`#rename-${role}`);\n    }\n    $$self.$$.on_mount.push(function() {\n      if (role === void 0 && !(\"role\" in $$props || $$self.$$.bound[$$self.$$.props[\"role\"]])) {\n        console.warn(\"<Role> was created without expected prop 'role'\");\n      }\n    });\n    const writable_props = [\"role\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Role> was created with unknown prop '${key}'`);\n    });\n    const click_handler = () => deleteFolder(role);\n    $$self.$$set = ($$props2) => {\n      if (\"role\" in $$props2) $$invalidate(0, role = $$props2.role);\n    };\n    $$self.$capture_state = () => ({\n      fragment: fragment2,\n      path: path2,\n      redirect,\n      folders,\n      files,\n      collections,\n      records,\n      Icon: Icon_default,\n      Input: input_default2,\n      role,\n      renameFolder,\n      deleteFolder,\n      editFolder,\n      $files,\n      $collections,\n      $fragment,\n      $path\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"role\" in $$props2) $$invalidate(0, role = $$props2.role);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [role, $fragment, $path, renameFolder, deleteFolder, editFolder, click_handler];\n  }\n  var Role = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance40, create_fragment40, safe_not_equal, { role: 0 });\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Role\",\n        options: options2,\n        id: create_fragment40.name\n      });\n    }\n    get role() {\n      throw new Error(\"<Role>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set role(value) {\n      throw new Error(\"<Role>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n  };\n  var role_default = Role;\n\n  // src/client/routes/users/nav.svelte\n  init_Icon();\n  init_Await();\n  init_actions();\n  init_files();\n  init_src();\n  var file38 = \"src/client/routes/users/nav.svelte\";\n  function get_each_context11(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[3] = list2[i];\n    return child_ctx;\n  }\n  function create_if_block19(ctx) {\n    let input;\n    let current;\n    input = new input_default2({\n      props: { required: true },\n      $$inline: true\n    });\n    input.$on(\"submit\", addFolder);\n    const block2 = {\n      c: function create() {\n        create_component(input.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(input, target, anchor);\n        current = true;\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(input.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(input.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(input, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block19.name,\n      type: \"if\",\n      source: '(72:8) {#if $fragment === \\\\\"#add-role\\\\\"}',\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block11(ctx) {\n    let role_1;\n    let current;\n    role_1 = new role_default({\n      props: { role: (\n        /*role*/\n        ctx[3]\n      ) },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(role_1.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(role_1, target, anchor);\n        current = true;\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(role_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(role_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(role_1, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block11.name,\n      type: \"each\",\n      source: \"(75:8) {#each roles as role}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot15(ctx) {\n    let nav;\n    let a0;\n    let icon;\n    let t0;\n    let a1;\n    let t1;\n    let a1_aria_disabled_value;\n    let t2;\n    let t3;\n    let scrollIntoView_action;\n    let drop_action;\n    let current;\n    let mounted;\n    let dispose;\n    icon = new Icon_default({\n      props: { icon: \"plus\", size: 20 },\n      $$inline: true\n    });\n    let if_block = (\n      /*$fragment*/\n      ctx[1] === \"#add-role\" && create_if_block19(ctx)\n    );\n    let each_value = ensure_array_like_dev(\n      /*roles*/\n      ctx[2]\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block11(get_each_context11(ctx, each_value, i));\n    }\n    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {\n      each_blocks[i] = null;\n    });\n    const block2 = {\n      c: function create() {\n        nav = element(\"nav\");\n        a0 = element(\"a\");\n        create_component(icon.$$.fragment);\n        t0 = space();\n        a1 = element(\"a\");\n        t1 = text(\"/\");\n        t2 = space();\n        if (if_block) if_block.c();\n        t3 = space();\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        attr_dev(a0, \"href\", \"#add-role\");\n        attr_dev(a0, \"role\", \"button\");\n        attr_dev(a0, \"class\", \"box outline pos-sticky svelte-1mx47zj\");\n        attr_dev(a0, \"draggable\", \"false\");\n        add_location(a0, file38, 61, 8, 1951);\n        attr_dev(a1, \"href\", \"/users\");\n        attr_dev(a1, \"tabindex\", \"0\");\n        attr_dev(a1, \"role\", \"button\");\n        attr_dev(a1, \"class\", \"box\");\n        attr_dev(a1, \"aria-disabled\", a1_aria_disabled_value = !/*$path*/\n        ctx[0][1]);\n        attr_dev(a1, \"draggable\", \"false\");\n        add_location(a1, file38, 69, 8, 2156);\n        attr_dev(nav, \"class\", \"cols col-fit nowrap justify-start scroll-x\");\n        add_location(nav, file38, 56, 4, 1807);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, nav, anchor);\n        append_dev(nav, a0);\n        mount_component(icon, a0, null);\n        append_dev(nav, t0);\n        append_dev(nav, a1);\n        append_dev(a1, t1);\n        append_dev(nav, t2);\n        if (if_block) if_block.m(nav, null);\n        append_dev(nav, t3);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(nav, null);\n          }\n        }\n        current = true;\n        if (!mounted) {\n          dispose = [\n            action_destroyer(scrollIntoView_action = scrollIntoView.call(\n              null,\n              nav,\n              /*$path*/\n              ctx[0][0]\n            )),\n            action_destroyer(drop_action = drop2.call(\n              null,\n              nav,\n              /*$path*/\n              ctx[0][1]\n            ))\n          ];\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (!current || dirty & /*$path*/\n        1 && a1_aria_disabled_value !== (a1_aria_disabled_value = !/*$path*/\n        ctx2[0][1])) {\n          attr_dev(a1, \"aria-disabled\", a1_aria_disabled_value);\n        }\n        if (\n          /*$fragment*/\n          ctx2[1] === \"#add-role\"\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty & /*$fragment*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block19(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(nav, t3);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*roles*/\n        4) {\n          each_value = ensure_array_like_dev(\n            /*roles*/\n            ctx2[2]\n          );\n          let i;\n          for (i = 0; i < each_value.length; i += 1) {\n            const child_ctx = get_each_context11(ctx2, each_value, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n              transition_in(each_blocks[i], 1);\n            } else {\n              each_blocks[i] = create_each_block11(child_ctx);\n              each_blocks[i].c();\n              transition_in(each_blocks[i], 1);\n              each_blocks[i].m(nav, null);\n            }\n          }\n          group_outros();\n          for (i = each_value.length; i < each_blocks.length; i += 1) {\n            out(i);\n          }\n          check_outros();\n        }\n        if (scrollIntoView_action && is_function(scrollIntoView_action.update) && dirty & /*$path*/\n        1) scrollIntoView_action.update.call(\n          null,\n          /*$path*/\n          ctx2[0][0]\n        );\n        if (drop_action && is_function(drop_action.update) && dirty & /*$path*/\n        1) drop_action.update.call(\n          null,\n          /*$path*/\n          ctx2[0][1]\n        );\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        transition_in(if_block);\n        for (let i = 0; i < each_value.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        transition_out(if_block);\n        each_blocks = each_blocks.filter(Boolean);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(nav);\n        }\n        destroy_component(icon);\n        if (if_block) if_block.d();\n        destroy_each(each_blocks, detaching);\n        mounted = false;\n        run_all(dispose);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot15.name,\n      type: \"slot\",\n      source: \"(50:0) <Await promise={folders.get()} notify>\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment41(ctx) {\n    let await_1;\n    let current;\n    await_1 = new Await_default({\n      props: {\n        promise: folders.get(),\n        notify: true,\n        $$slots: { default: [create_default_slot15] },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(await_1.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(await_1, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const await_1_changes = {};\n        if (dirty & /*$$scope, $path, $fragment*/\n        67) {\n          await_1_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        await_1.$set(await_1_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(await_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(await_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(await_1, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment41.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  async function addFolder(e) {\n    const data = new FormData(e.target);\n    const folder = data.get(\"value\");\n    await folders.add(String(folder));\n    goto(`/files/${folder}`);\n  }\n  function drop2(node, from) {\n    const update2 = (from2) => {\n      const selectors = 'a[href^=\"/files\"]:not([aria-disabled=\"true\"])';\n      const anchors = node.querySelectorAll(selectors);\n      const focused = (a, val) => val ? a.focus() : a.blur();\n      Array.from(anchors).forEach((a) => {\n        a.ondragover = (e) => {\n          const { dataTransfer, currentTarget } = e;\n          e.stopPropagation();\n          e.preventDefault();\n          focused(a, true);\n        };\n        a.ondragleave = (e) => focused(a, false);\n        a.ondrop = async (e) => {\n          const { dataTransfer, currentTarget } = e;\n          const { id: to } = currentTarget;\n          const fileList = dataTransfer?.getData(\"files\").split(\",\") || [];\n          const promises = fileList.map((file48) => {\n            return files.move(from2, file48, to);\n          });\n          await Promise.all(promises);\n          focused(a, false);\n        };\n      });\n    };\n    update2(from);\n    return { update: update2 };\n  }\n  function instance41($$self, $$props, $$invalidate) {\n    let $path;\n    let $fragment;\n    validate_store(path2, \"path\");\n    component_subscribe($$self, path2, ($$value) => $$invalidate(0, $path = $$value));\n    validate_store(fragment2, \"fragment\");\n    component_subscribe($$self, fragment2, ($$value) => $$invalidate(1, $fragment = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Nav\", slots, []);\n    \"use strict\";\n    const roles = [\"admin\", \"editor\", \"publisher\"];\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Nav> was created with unknown prop '${key}'`);\n    });\n    $$self.$capture_state = () => ({\n      fragment: fragment2,\n      path: path2,\n      goto,\n      folders,\n      files,\n      scrollIntoView,\n      Await: Await_default,\n      Icon: Icon_default,\n      Input: input_default2,\n      Role: role_default,\n      roles,\n      addFolder,\n      drop: drop2,\n      $path,\n      $fragment\n    });\n    return [$path, $fragment, roles];\n  }\n  var Nav2 = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance41, create_fragment41, safe_not_equal, {});\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Nav\",\n        options: options2,\n        id: create_fragment41.name\n      });\n    }\n  };\n  var nav_default2 = Nav2;\n\n  // src/client/routes/files/nav.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n\n  // src/client/routes/files/folder.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n\n  // src/client/routes/files/input.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n  init_Form();\n  init_src();\n  var file39 = \"src/client/routes/files/input.svelte\";\n  function create_default_slot16(ctx) {\n    let fieldset;\n    let label;\n    let input;\n    let input_autofocus_value;\n    let close_action;\n    let mounted;\n    let dispose;\n    const block2 = {\n      c: function create() {\n        fieldset = element(\"fieldset\");\n        label = element(\"label\");\n        input = element(\"input\");\n        attr_dev(input, \"name\", \"value\");\n        input.autofocus = input_autofocus_value = true;\n        input.required = /*required*/\n        ctx[1];\n        input.value = /*value*/\n        ctx[0];\n        attr_dev(\n          input,\n          \"pattern\",\n          /*pattern*/\n          ctx[2]\n        );\n        attr_dev(\n          input,\n          \"placeholder\",\n          /*placeholder*/\n          ctx[3]\n        );\n        add_location(input, file39, 34, 12, 867);\n        attr_dev(label, \"class\", \"svelte-4oyeew\");\n        add_location(label, file39, 32, 8, 797);\n        attr_dev(fieldset, \"class\", \"svelte-4oyeew\");\n        add_location(fieldset, file39, 31, 4, 778);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, fieldset, anchor);\n        append_dev(fieldset, label);\n        append_dev(label, input);\n        if (true) input.focus();\n        if (!mounted) {\n          dispose = action_destroyer(close_action = close3.call(\n            null,\n            input,\n            /*onclose*/\n            ctx[4]\n          ));\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*required*/\n        2) {\n          prop_dev(\n            input,\n            \"required\",\n            /*required*/\n            ctx2[1]\n          );\n        }\n        if (dirty & /*value*/\n        1 && input.value !== /*value*/\n        ctx2[0]) {\n          prop_dev(\n            input,\n            \"value\",\n            /*value*/\n            ctx2[0]\n          );\n        }\n        if (dirty & /*pattern*/\n        4) {\n          attr_dev(\n            input,\n            \"pattern\",\n            /*pattern*/\n            ctx2[2]\n          );\n        }\n        if (dirty & /*placeholder*/\n        8) {\n          attr_dev(\n            input,\n            \"placeholder\",\n            /*placeholder*/\n            ctx2[3]\n          );\n        }\n        if (close_action && is_function(close_action.update) && dirty & /*onclose*/\n        16) close_action.update.call(\n          null,\n          /*onclose*/\n          ctx2[4]\n        );\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(fieldset);\n        }\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot16.name,\n      type: \"slot\",\n      source: \"(28:0) <Form on:submit>\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment42(ctx) {\n    let form;\n    let current;\n    form = new Form_default({\n      props: {\n        $$slots: { default: [create_default_slot16] },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    form.$on(\n      \"submit\",\n      /*submit_handler*/\n      ctx[5]\n    );\n    const block2 = {\n      c: function create() {\n        create_component(form.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(form, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const form_changes = {};\n        if (dirty & /*$$scope, required, value, pattern, placeholder, onclose*/\n        95) {\n          form_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        form.$set(form_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(form.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(form.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(form, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment42.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function close3(node, onclose) {\n    function update2(onclose2) {\n      node.onblur = () => onclose2 ? onclose2() : fragment2.set(\"\");\n      node.onkeydown = (e) => {\n        if (e.key === \"Escape\") {\n          e.preventDefault();\n          e.stopPropagation();\n          onclose2 ? onclose2() : fragment2.set(\"\");\n        }\n      };\n    }\n    update2(onclose);\n    return { update: update2 };\n  }\n  function instance42($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Input\", slots, []);\n    let { value = \"\" } = $$props;\n    let { required = false } = $$props;\n    let { pattern: pattern2 = \"^[\\\\w|\\\\-]+$\" } = $$props;\n    let { placeholder = \"Folder name\" } = $$props;\n    let { onclose = void 0 } = $$props;\n    const writable_props = [\"value\", \"required\", \"pattern\", \"placeholder\", \"onclose\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Input> was created with unknown prop '${key}'`);\n    });\n    function submit_handler(event) {\n      bubble.call(this, $$self, event);\n    }\n    $$self.$$set = ($$props2) => {\n      if (\"value\" in $$props2) $$invalidate(0, value = $$props2.value);\n      if (\"required\" in $$props2) $$invalidate(1, required = $$props2.required);\n      if (\"pattern\" in $$props2) $$invalidate(2, pattern2 = $$props2.pattern);\n      if (\"placeholder\" in $$props2) $$invalidate(3, placeholder = $$props2.placeholder);\n      if (\"onclose\" in $$props2) $$invalidate(4, onclose = $$props2.onclose);\n    };\n    $$self.$capture_state = () => ({\n      fragment: fragment2,\n      Form: Form_default,\n      value,\n      required,\n      pattern: pattern2,\n      placeholder,\n      onclose,\n      close: close3\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"value\" in $$props2) $$invalidate(0, value = $$props2.value);\n      if (\"required\" in $$props2) $$invalidate(1, required = $$props2.required);\n      if (\"pattern\" in $$props2) $$invalidate(2, pattern2 = $$props2.pattern);\n      if (\"placeholder\" in $$props2) $$invalidate(3, placeholder = $$props2.placeholder);\n      if (\"onclose\" in $$props2) $$invalidate(4, onclose = $$props2.onclose);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [value, required, pattern2, placeholder, onclose, submit_handler];\n  }\n  var Input3 = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance42, create_fragment42, safe_not_equal, {\n        value: 0,\n        required: 1,\n        pattern: 2,\n        placeholder: 3,\n        onclose: 4\n      });\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Input\",\n        options: options2,\n        id: create_fragment42.name\n      });\n    }\n    get value() {\n      throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set value(value) {\n      throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    get required() {\n      throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set required(value) {\n      throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    get pattern() {\n      throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set pattern(value) {\n      throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    get placeholder() {\n      throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set placeholder(value) {\n      throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    get onclose() {\n      throw new Error(\"<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set onclose(value) {\n      throw new Error(\"<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n  };\n  var input_default3 = Input3;\n\n  // src/client/routes/files/folder.svelte\n  init_Icon();\n  init_data();\n  init_files();\n  init_src();\n  var file40 = \"src/client/routes/files/folder.svelte\";\n  function create_else_block8(ctx) {\n    let a;\n    let t0;\n    let span;\n    let t1;\n    let t2;\n    let a_href_value;\n    let a_aria_disabled_value;\n    let current;\n    let if_block0 = (\n      /*$path*/\n      ctx[2][1] === /*folder*/\n      ctx[0] && create_if_block_26(ctx)\n    );\n    let if_block1 = (\n      /*$path*/\n      ctx[2][1] === /*folder*/\n      ctx[0] && create_if_block_110(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        a = element(\"a\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        span = element(\"span\");\n        t1 = text(\n          /*folder*/\n          ctx[0]\n        );\n        t2 = space();\n        if (if_block1) if_block1.c();\n        add_location(span, file40, 47, 8, 1288);\n        attr_dev(\n          a,\n          \"id\",\n          /*folder*/\n          ctx[0]\n        );\n        attr_dev(a, \"tabindex\", \"0\");\n        attr_dev(a, \"href\", a_href_value = \"/files/\" + /*folder*/\n        ctx[0]);\n        attr_dev(a, \"role\", \"button\");\n        attr_dev(a, \"aria-disabled\", a_aria_disabled_value = /*$path*/\n        ctx[2][1] === /*folder*/\n        ctx[0]);\n        attr_dev(a, \"draggable\", \"false\");\n        add_location(a, file40, 34, 4, 925);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, a, anchor);\n        if (if_block0) if_block0.m(a, null);\n        append_dev(a, t0);\n        append_dev(a, span);\n        append_dev(span, t1);\n        append_dev(a, t2);\n        if (if_block1) if_block1.m(a, null);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*$path*/\n          ctx2[2][1] === /*folder*/\n          ctx2[0]\n        ) {\n          if (if_block0) {\n            if_block0.p(ctx2, dirty);\n            if (dirty & /*$path, folder*/\n            5) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_26(ctx2);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(a, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, () => {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if (!current || dirty & /*folder*/\n        1) set_data_dev(\n          t1,\n          /*folder*/\n          ctx2[0]\n        );\n        if (\n          /*$path*/\n          ctx2[2][1] === /*folder*/\n          ctx2[0]\n        ) {\n          if (if_block1) {\n            if_block1.p(ctx2, dirty);\n            if (dirty & /*$path, folder*/\n            5) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_110(ctx2);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(a, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, () => {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n        if (!current || dirty & /*folder*/\n        1) {\n          attr_dev(\n            a,\n            \"id\",\n            /*folder*/\n            ctx2[0]\n          );\n        }\n        if (!current || dirty & /*folder*/\n        1 && a_href_value !== (a_href_value = \"/files/\" + /*folder*/\n        ctx2[0])) {\n          attr_dev(a, \"href\", a_href_value);\n        }\n        if (!current || dirty & /*$path, folder*/\n        5 && a_aria_disabled_value !== (a_aria_disabled_value = /*$path*/\n        ctx2[2][1] === /*folder*/\n        ctx2[0])) {\n          attr_dev(a, \"aria-disabled\", a_aria_disabled_value);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(a);\n        }\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_else_block8.name,\n      type: \"else\",\n      source: \"(29:0) {:else}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block20(ctx) {\n    let input;\n    let current;\n    input = new input_default3({\n      props: { value: (\n        /*folder*/\n        ctx[0]\n      ) },\n      $$inline: true\n    });\n    input.$on(\n      \"submit\",\n      /*renameFolder*/\n      ctx[3]\n    );\n    const block2 = {\n      c: function create() {\n        create_component(input.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(input, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const input_changes = {};\n        if (dirty & /*folder*/\n        1) input_changes.value = /*folder*/\n        ctx2[0];\n        input.$set(input_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(input.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(input.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(input, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block20.name,\n      type: \"if\",\n      source: \"(27:0) {#if $fragment === `#rename-${folder}`}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_26(ctx) {\n    let button;\n    let icon;\n    let current;\n    let mounted;\n    let dispose;\n    icon = new Icon_default({ props: { icon: \"edit\" }, $$inline: true });\n    const block2 = {\n      c: function create() {\n        button = element(\"button\");\n        create_component(icon.$$.fragment);\n        attr_dev(button, \"class\", \"box link\");\n        add_location(button, file40, 43, 12, 1144);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, button, anchor);\n        mount_component(icon, button, null);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(button, \"click\", prevent_default(\n            /*editFolder*/\n            ctx[5]\n          ), false, true, false, false);\n          mounted = true;\n        }\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(button);\n        }\n        destroy_component(icon);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_26.name,\n      type: \"if\",\n      source: \"(38:8) {#if $path[1] === folder}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_110(ctx) {\n    let button;\n    let icon;\n    let current;\n    let mounted;\n    let dispose;\n    icon = new Icon_default({ props: { icon: \"trash\" }, $$inline: true });\n    const block2 = {\n      c: function create() {\n        button = element(\"button\");\n        create_component(icon.$$.fragment);\n        attr_dev(button, \"class\", \"box link text-error\");\n        add_location(button, file40, 49, 12, 1356);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, button, anchor);\n        mount_component(icon, button, null);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            button,\n            \"click\",\n            /*click_handler*/\n            ctx[6],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(button);\n        }\n        destroy_component(icon);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_110.name,\n      type: \"if\",\n      source: \"(44:8) {#if $path[1] === folder}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment43(ctx) {\n    let current_block_type_index;\n    let if_block;\n    let if_block_anchor;\n    let current;\n    const if_block_creators = [create_if_block20, create_else_block8];\n    const if_blocks = [];\n    function select_block_type(ctx2, dirty) {\n      if (\n        /*$fragment*/\n        ctx2[1] === `#rename-${/*folder*/\n        ctx2[0]}`\n      ) return 0;\n      return 1;\n    }\n    current_block_type_index = select_block_type(ctx, -1);\n    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n    const block2 = {\n      c: function create() {\n        if_block.c();\n        if_block_anchor = empty();\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        if_blocks[current_block_type_index].m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        let previous_block_index = current_block_type_index;\n        current_block_type_index = select_block_type(ctx2, dirty);\n        if (current_block_type_index === previous_block_index) {\n          if_blocks[current_block_type_index].p(ctx2, dirty);\n        } else {\n          group_outros();\n          transition_out(if_blocks[previous_block_index], 1, 1, () => {\n            if_blocks[previous_block_index] = null;\n          });\n          check_outros();\n          if_block = if_blocks[current_block_type_index];\n          if (!if_block) {\n            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);\n            if_block.c();\n          } else {\n            if_block.p(ctx2, dirty);\n          }\n          transition_in(if_block, 1);\n          if_block.m(if_block_anchor.parentNode, if_block_anchor);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if_blocks[current_block_type_index].d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment43.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance43($$self, $$props, $$invalidate) {\n    let $files;\n    let $collections;\n    let $fragment;\n    let $path;\n    validate_store(files, \"files\");\n    component_subscribe($$self, files, ($$value) => $$invalidate(7, $files = $$value));\n    validate_store(collections, \"collections\");\n    component_subscribe($$self, collections, ($$value) => $$invalidate(8, $collections = $$value));\n    validate_store(fragment2, \"fragment\");\n    component_subscribe($$self, fragment2, ($$value) => $$invalidate(1, $fragment = $$value));\n    validate_store(path2, \"path\");\n    component_subscribe($$self, path2, ($$value) => $$invalidate(2, $path = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Folder\", slots, []);\n    let { folder } = $$props;\n    async function renameFolder(e) {\n      const data = new FormData(e.target);\n      const name2 = data.get(\"value\");\n      await folders.rename(String(folder), String(name2));\n      redirect(`/files/${name2}`);\n    }\n    async function deleteFolder(folder2) {\n      if ($collections.includes(folder2)) {\n        await records.deleteFiles(folder2, $files);\n      }\n      await folders.delete(folder2);\n      redirect(\"/files\");\n    }\n    function editFolder() {\n      fragment2.set(`#rename-${folder}`);\n    }\n    $$self.$$.on_mount.push(function() {\n      if (folder === void 0 && !(\"folder\" in $$props || $$self.$$.bound[$$self.$$.props[\"folder\"]])) {\n        console.warn(\"<Folder> was created without expected prop 'folder'\");\n      }\n    });\n    const writable_props = [\"folder\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Folder> was created with unknown prop '${key}'`);\n    });\n    const click_handler = () => deleteFolder(folder);\n    $$self.$$set = ($$props2) => {\n      if (\"folder\" in $$props2) $$invalidate(0, folder = $$props2.folder);\n    };\n    $$self.$capture_state = () => ({\n      fragment: fragment2,\n      path: path2,\n      redirect,\n      folders,\n      files,\n      collections,\n      records,\n      Icon: Icon_default,\n      Input: input_default3,\n      folder,\n      renameFolder,\n      deleteFolder,\n      editFolder,\n      $files,\n      $collections,\n      $fragment,\n      $path\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"folder\" in $$props2) $$invalidate(0, folder = $$props2.folder);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [\n      folder,\n      $fragment,\n      $path,\n      renameFolder,\n      deleteFolder,\n      editFolder,\n      click_handler\n    ];\n  }\n  var Folder = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance43, create_fragment43, safe_not_equal, { folder: 0 });\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Folder\",\n        options: options2,\n        id: create_fragment43.name\n      });\n    }\n    get folder() {\n      throw new Error(\"<Folder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set folder(value) {\n      throw new Error(\"<Folder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n  };\n  var folder_default = Folder;\n\n  // src/client/routes/files/nav.svelte\n  init_Icon();\n  init_Await();\n  init_actions();\n  init_files();\n  init_src();\n  var file41 = \"src/client/routes/files/nav.svelte\";\n  function get_each_context12(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[3] = list2[i];\n    return child_ctx;\n  }\n  function create_if_block21(ctx) {\n    let input;\n    let current;\n    input = new input_default3({\n      props: { required: true },\n      $$inline: true\n    });\n    input.$on(\"submit\", addFolder2);\n    const block2 = {\n      c: function create() {\n        create_component(input.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(input, target, anchor);\n        current = true;\n      },\n      p: noop,\n      i: function intro(local) {\n        if (current) return;\n        transition_in(input.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(input.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(input, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block21.name,\n      type: \"if\",\n      source: '(71:8) {#if $fragment === \\\\\"#add-folder\\\\\"}',\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block12(ctx) {\n    let folder_1;\n    let current;\n    folder_1 = new folder_default({\n      props: { folder: (\n        /*folder*/\n        ctx[3]\n      ) },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(folder_1.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(folder_1, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const folder_1_changes = {};\n        if (dirty & /*$folders*/\n        4) folder_1_changes.folder = /*folder*/\n        ctx2[3];\n        folder_1.$set(folder_1_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(folder_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(folder_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(folder_1, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block12.name,\n      type: \"each\",\n      source: \"(74:8) {#each $folders as folder}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot17(ctx) {\n    let nav;\n    let a0;\n    let icon;\n    let t0;\n    let a1;\n    let t1;\n    let a1_aria_disabled_value;\n    let t2;\n    let t3;\n    let scrollIntoView_action;\n    let drop_action;\n    let current;\n    let mounted;\n    let dispose;\n    icon = new Icon_default({\n      props: { icon: \"folder-plus\", size: 20 },\n      $$inline: true\n    });\n    let if_block = (\n      /*$fragment*/\n      ctx[1] === \"#add-folder\" && create_if_block21(ctx)\n    );\n    let each_value = ensure_array_like_dev(\n      /*$folders*/\n      ctx[2]\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block12(get_each_context12(ctx, each_value, i));\n    }\n    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {\n      each_blocks[i] = null;\n    });\n    const block2 = {\n      c: function create() {\n        nav = element(\"nav\");\n        a0 = element(\"a\");\n        create_component(icon.$$.fragment);\n        t0 = space();\n        a1 = element(\"a\");\n        t1 = text(\"/\");\n        t2 = space();\n        if (if_block) if_block.c();\n        t3 = space();\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        attr_dev(a0, \"href\", \"#add-folder\");\n        attr_dev(a0, \"role\", \"button\");\n        attr_dev(a0, \"class\", \"box outline pos-sticky svelte-kcwsun\");\n        attr_dev(a0, \"draggable\", \"false\");\n        add_location(a0, file41, 60, 8, 1907);\n        attr_dev(a1, \"href\", \"/files\");\n        attr_dev(a1, \"tabindex\", \"0\");\n        attr_dev(a1, \"role\", \"button\");\n        attr_dev(a1, \"class\", \"box\");\n        attr_dev(a1, \"aria-disabled\", a1_aria_disabled_value = !/*$path*/\n        ctx[0][1]);\n        attr_dev(a1, \"draggable\", \"false\");\n        add_location(a1, file41, 68, 8, 2121);\n        attr_dev(nav, \"class\", \"cols col-fit nowrap justify-start scroll-x\");\n        add_location(nav, file41, 55, 4, 1763);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, nav, anchor);\n        append_dev(nav, a0);\n        mount_component(icon, a0, null);\n        append_dev(nav, t0);\n        append_dev(nav, a1);\n        append_dev(a1, t1);\n        append_dev(nav, t2);\n        if (if_block) if_block.m(nav, null);\n        append_dev(nav, t3);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(nav, null);\n          }\n        }\n        current = true;\n        if (!mounted) {\n          dispose = [\n            action_destroyer(scrollIntoView_action = scrollIntoView.call(\n              null,\n              nav,\n              /*$path*/\n              ctx[0][0]\n            )),\n            action_destroyer(drop_action = drop3.call(\n              null,\n              nav,\n              /*$path*/\n              ctx[0][1]\n            ))\n          ];\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (!current || dirty & /*$path*/\n        1 && a1_aria_disabled_value !== (a1_aria_disabled_value = !/*$path*/\n        ctx2[0][1])) {\n          attr_dev(a1, \"aria-disabled\", a1_aria_disabled_value);\n        }\n        if (\n          /*$fragment*/\n          ctx2[1] === \"#add-folder\"\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty & /*$fragment*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block21(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(nav, t3);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*$folders*/\n        4) {\n          each_value = ensure_array_like_dev(\n            /*$folders*/\n            ctx2[2]\n          );\n          let i;\n          for (i = 0; i < each_value.length; i += 1) {\n            const child_ctx = get_each_context12(ctx2, each_value, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n              transition_in(each_blocks[i], 1);\n            } else {\n              each_blocks[i] = create_each_block12(child_ctx);\n              each_blocks[i].c();\n              transition_in(each_blocks[i], 1);\n              each_blocks[i].m(nav, null);\n            }\n          }\n          group_outros();\n          for (i = each_value.length; i < each_blocks.length; i += 1) {\n            out(i);\n          }\n          check_outros();\n        }\n        if (scrollIntoView_action && is_function(scrollIntoView_action.update) && dirty & /*$path*/\n        1) scrollIntoView_action.update.call(\n          null,\n          /*$path*/\n          ctx2[0][0]\n        );\n        if (drop_action && is_function(drop_action.update) && dirty & /*$path*/\n        1) drop_action.update.call(\n          null,\n          /*$path*/\n          ctx2[0][1]\n        );\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        transition_in(if_block);\n        for (let i = 0; i < each_value.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        transition_out(if_block);\n        each_blocks = each_blocks.filter(Boolean);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(nav);\n        }\n        destroy_component(icon);\n        if (if_block) if_block.d();\n        destroy_each(each_blocks, detaching);\n        mounted = false;\n        run_all(dispose);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot17.name,\n      type: \"slot\",\n      source: \"(49:0) <Await promise={folders.get()} notify>\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment44(ctx) {\n    let await_1;\n    let current;\n    await_1 = new Await_default({\n      props: {\n        promise: folders.get(),\n        notify: true,\n        $$slots: { default: [create_default_slot17] },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(await_1.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(await_1, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const await_1_changes = {};\n        if (dirty & /*$$scope, $path, $folders, $fragment*/\n        71) {\n          await_1_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        await_1.$set(await_1_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(await_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(await_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(await_1, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment44.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  async function addFolder2(e) {\n    const data = new FormData(e.target);\n    const folder = data.get(\"value\");\n    await folders.add(String(folder));\n    goto(`/files/${folder}`);\n  }\n  function drop3(node, from) {\n    const update2 = (from2) => {\n      const selectors = 'a[href^=\"/files\"]:not([aria-disabled=\"true\"])';\n      const anchors = node.querySelectorAll(selectors);\n      const focused = (a, val) => val ? a.focus() : a.blur();\n      Array.from(anchors).forEach((a) => {\n        a.ondragover = (e) => {\n          const { dataTransfer, currentTarget } = e;\n          e.stopPropagation();\n          e.preventDefault();\n          focused(a, true);\n        };\n        a.ondragleave = (e) => focused(a, false);\n        a.ondrop = async (e) => {\n          const { dataTransfer, currentTarget } = e;\n          const { id: to } = currentTarget;\n          const fileList = dataTransfer?.getData(\"files\").split(\",\") || [];\n          const promises = fileList.map((file48) => {\n            return files.move(from2, file48, to);\n          });\n          await Promise.all(promises);\n          focused(a, false);\n        };\n      });\n    };\n    update2(from);\n    return { update: update2 };\n  }\n  function instance44($$self, $$props, $$invalidate) {\n    let $path;\n    let $fragment;\n    let $folders;\n    validate_store(path2, \"path\");\n    component_subscribe($$self, path2, ($$value) => $$invalidate(0, $path = $$value));\n    validate_store(fragment2, \"fragment\");\n    component_subscribe($$self, fragment2, ($$value) => $$invalidate(1, $fragment = $$value));\n    validate_store(folders, \"folders\");\n    component_subscribe($$self, folders, ($$value) => $$invalidate(2, $folders = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Nav\", slots, []);\n    \"use strict\";\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Nav> was created with unknown prop '${key}'`);\n    });\n    $$self.$capture_state = () => ({\n      fragment: fragment2,\n      path: path2,\n      goto,\n      folders,\n      files,\n      scrollIntoView,\n      Await: Await_default,\n      Icon: Icon_default,\n      Input: input_default3,\n      Folder: folder_default,\n      addFolder: addFolder2,\n      drop: drop3,\n      $path,\n      $fragment,\n      $folders\n    });\n    return [$path, $fragment, $folders];\n  }\n  var Nav3 = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance44, create_fragment44, safe_not_equal, {});\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Nav\",\n        options: options2,\n        id: create_fragment44.name\n      });\n    }\n  };\n  var nav_default3 = Nav3;\n\n  // src/client/routes/data/nav.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n\n  // src/client/routes/data/nav/file.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n  init_Icon();\n  init_files();\n  init_data();\n  init_src();\n  var file42 = \"src/client/routes/data/nav/file.svelte\";\n  function create_if_block_111(ctx) {\n    let a;\n    let icon;\n    let current;\n    icon = new Icon_default({ props: { icon: \"edit\" }, $$inline: true });\n    const block2 = {\n      c: function create() {\n        a = element(\"a\");\n        create_component(icon.$$.fragment);\n        attr_dev(a, \"href\", \"#edit-collection\");\n        attr_dev(a, \"draggable\", \"false\");\n        attr_dev(a, \"role\", \"button\");\n        attr_dev(\n          a,\n          \"id\",\n          /*collection*/\n          ctx[0]\n        );\n        attr_dev(a, \"class\", \"box link\");\n        add_location(a, file42, 24, 8, 631);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, a, anchor);\n        mount_component(icon, a, null);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (!current || dirty & /*collection*/\n        1) {\n          attr_dev(\n            a,\n            \"id\",\n            /*collection*/\n            ctx2[0]\n          );\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(a);\n        }\n        destroy_component(icon);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_111.name,\n      type: \"if\",\n      source: \"(21:4) {#if $path[1] === collection}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block22(ctx) {\n    let button;\n    let icon;\n    let current;\n    let mounted;\n    let dispose;\n    icon = new Icon_default({ props: { icon: \"trash\" }, $$inline: true });\n    const block2 = {\n      c: function create() {\n        button = element(\"button\");\n        create_component(icon.$$.fragment);\n        attr_dev(\n          button,\n          \"id\",\n          /*collection*/\n          ctx[0]\n        );\n        attr_dev(button, \"class\", \"box link text-error\");\n        add_location(button, file42, 36, 8, 921);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, button, anchor);\n        mount_component(icon, button, null);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            button,\n            \"click\",\n            /*deleteCollection*/\n            ctx[2],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (!current || dirty & /*collection*/\n        1) {\n          attr_dev(\n            button,\n            \"id\",\n            /*collection*/\n            ctx2[0]\n          );\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(button);\n        }\n        destroy_component(icon);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block22.name,\n      type: \"if\",\n      source: \"(33:4) {#if $path[1] === collection}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment45(ctx) {\n    let a;\n    let t0;\n    let span;\n    let t1;\n    let t2;\n    let a_href_value;\n    let a_aria_disabled_value;\n    let current;\n    let if_block0 = (\n      /*$path*/\n      ctx[1][1] === /*collection*/\n      ctx[0] && create_if_block_111(ctx)\n    );\n    let if_block1 = (\n      /*$path*/\n      ctx[1][1] === /*collection*/\n      ctx[0] && create_if_block22(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        a = element(\"a\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        span = element(\"span\");\n        t1 = text(\n          /*collection*/\n          ctx[0]\n        );\n        t2 = space();\n        if (if_block1) if_block1.c();\n        add_location(span, file42, 34, 4, 853);\n        attr_dev(a, \"href\", a_href_value = \"/data/\" + /*collection*/\n        ctx[0]);\n        attr_dev(a, \"role\", \"button\");\n        attr_dev(a, \"draggable\", \"false\");\n        attr_dev(a, \"aria-disabled\", a_aria_disabled_value = /*$path*/\n        ctx[1][1] === /*collection*/\n        ctx[0]);\n        add_location(a, file42, 17, 0, 470);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, a, anchor);\n        if (if_block0) if_block0.m(a, null);\n        append_dev(a, t0);\n        append_dev(a, span);\n        append_dev(span, t1);\n        append_dev(a, t2);\n        if (if_block1) if_block1.m(a, null);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (\n          /*$path*/\n          ctx2[1][1] === /*collection*/\n          ctx2[0]\n        ) {\n          if (if_block0) {\n            if_block0.p(ctx2, dirty);\n            if (dirty & /*$path, collection*/\n            3) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_111(ctx2);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(a, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, () => {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if (!current || dirty & /*collection*/\n        1) set_data_dev(\n          t1,\n          /*collection*/\n          ctx2[0]\n        );\n        if (\n          /*$path*/\n          ctx2[1][1] === /*collection*/\n          ctx2[0]\n        ) {\n          if (if_block1) {\n            if_block1.p(ctx2, dirty);\n            if (dirty & /*$path, collection*/\n            3) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block22(ctx2);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(a, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, () => {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n        if (!current || dirty & /*collection*/\n        1 && a_href_value !== (a_href_value = \"/data/\" + /*collection*/\n        ctx2[0])) {\n          attr_dev(a, \"href\", a_href_value);\n        }\n        if (!current || dirty & /*$path, collection*/\n        3 && a_aria_disabled_value !== (a_aria_disabled_value = /*$path*/\n        ctx2[1][1] === /*collection*/\n        ctx2[0])) {\n          attr_dev(a, \"aria-disabled\", a_aria_disabled_value);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(a);\n        }\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment45.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance45($$self, $$props, $$invalidate) {\n    let $collections;\n    let $path;\n    validate_store(collections, \"collections\");\n    component_subscribe($$self, collections, ($$value) => $$invalidate(3, $collections = $$value));\n    validate_store(path2, \"path\");\n    component_subscribe($$self, path2, ($$value) => $$invalidate(1, $path = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"File\", slots, []);\n    let { collection } = $$props;\n    async function deleteCollection() {\n      await folders.delete(collection);\n      await collections.delete(collection);\n      redirect(`/data/${$collections.at(-1) || \"\"}`);\n    }\n    $$self.$$.on_mount.push(function() {\n      if (collection === void 0 && !(\"collection\" in $$props || $$self.$$.bound[$$self.$$.props[\"collection\"]])) {\n        console.warn(\"<File> was created without expected prop 'collection'\");\n      }\n    });\n    const writable_props = [\"collection\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<File> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"collection\" in $$props2) $$invalidate(0, collection = $$props2.collection);\n    };\n    $$self.$capture_state = () => ({\n      path: path2,\n      redirect,\n      collections,\n      folders,\n      Icon: Icon_default,\n      collection,\n      deleteCollection,\n      $collections,\n      $path\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"collection\" in $$props2) $$invalidate(0, collection = $$props2.collection);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [collection, $path, deleteCollection];\n  }\n  var File2 = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance45, create_fragment45, safe_not_equal, { collection: 0 });\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"File\",\n        options: options2,\n        id: create_fragment45.name\n      });\n    }\n    get collection() {\n      throw new Error(\"<File>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set collection(value) {\n      throw new Error(\"<File>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n  };\n  var file_default2 = File2;\n\n  // src/client/routes/data/nav.svelte\n  init_Icon();\n  init_Await();\n  init_actions();\n  init_data();\n  init_src();\n  var file43 = \"src/client/routes/data/nav.svelte\";\n  function get_each_context13(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[2] = list2[i];\n    return child_ctx;\n  }\n  function create_if_block23(ctx) {\n    let a;\n    let icon;\n    let a_aria_disabled_value;\n    let current;\n    icon = new Icon_default({\n      props: { icon: \"plus-square\", size: 20 },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        a = element(\"a\");\n        create_component(icon.$$.fragment);\n        attr_dev(a, \"href\", \"/data\");\n        attr_dev(a, \"role\", \"button\");\n        attr_dev(a, \"draggable\", \"false\");\n        attr_dev(a, \"class\", \"pos-sticky box svelte-1hu73eg\");\n        attr_dev(a, \"aria-disabled\", a_aria_disabled_value = !/*$path*/\n        ctx[0][1]);\n        add_location(a, file43, 15, 12, 531);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, a, anchor);\n        mount_component(icon, a, null);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (!current || dirty & /*$path*/\n        1 && a_aria_disabled_value !== (a_aria_disabled_value = !/*$path*/\n        ctx2[0][1])) {\n          attr_dev(a, \"aria-disabled\", a_aria_disabled_value);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(a);\n        }\n        destroy_component(icon);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block23.name,\n      type: \"if\",\n      source: \"(14:8) {#if $collections.length}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block13(ctx) {\n    let file_13;\n    let current;\n    file_13 = new file_default2({\n      props: { collection: (\n        /*collection*/\n        ctx[2]\n      ) },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(file_13.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(file_13, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const file_1_changes = {};\n        if (dirty & /*$collections*/\n        2) file_1_changes.collection = /*collection*/\n        ctx2[2];\n        file_13.$set(file_1_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(file_13.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(file_13.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(file_13, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block13.name,\n      type: \"each\",\n      source: \"(25:8) {#each $collections as collection}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot18(ctx) {\n    let nav;\n    let t;\n    let scrollIntoView_action;\n    let current;\n    let mounted;\n    let dispose;\n    let if_block = (\n      /*$collections*/\n      ctx[1].length && create_if_block23(ctx)\n    );\n    let each_value = ensure_array_like_dev(\n      /*$collections*/\n      ctx[1]\n    );\n    let each_blocks = [];\n    for (let i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block13(get_each_context13(ctx, each_value, i));\n    }\n    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {\n      each_blocks[i] = null;\n    });\n    const block2 = {\n      c: function create() {\n        nav = element(\"nav\");\n        if (if_block) if_block.c();\n        t = space();\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        attr_dev(nav, \"class\", \"cols col-fit nowrap justify-start scroll-x\");\n        add_location(nav, file43, 10, 4, 377);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, nav, anchor);\n        if (if_block) if_block.m(nav, null);\n        append_dev(nav, t);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(nav, null);\n          }\n        }\n        current = true;\n        if (!mounted) {\n          dispose = action_destroyer(scrollIntoView_action = scrollIntoView.call(\n            null,\n            nav,\n            /*$path*/\n            ctx[0][0]\n          ));\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*$collections*/\n          ctx2[1].length\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty & /*$collections*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block23(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(nav, t);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*$collections*/\n        2) {\n          each_value = ensure_array_like_dev(\n            /*$collections*/\n            ctx2[1]\n          );\n          let i;\n          for (i = 0; i < each_value.length; i += 1) {\n            const child_ctx = get_each_context13(ctx2, each_value, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n              transition_in(each_blocks[i], 1);\n            } else {\n              each_blocks[i] = create_each_block13(child_ctx);\n              each_blocks[i].c();\n              transition_in(each_blocks[i], 1);\n              each_blocks[i].m(nav, null);\n            }\n          }\n          group_outros();\n          for (i = each_value.length; i < each_blocks.length; i += 1) {\n            out(i);\n          }\n          check_outros();\n        }\n        if (scrollIntoView_action && is_function(scrollIntoView_action.update) && dirty & /*$path*/\n        1) scrollIntoView_action.update.call(\n          null,\n          /*$path*/\n          ctx2[0][0]\n        );\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        for (let i = 0; i < each_value.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        each_blocks = each_blocks.filter(Boolean);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(nav);\n        }\n        if (if_block) if_block.d();\n        destroy_each(each_blocks, detaching);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot18.name,\n      type: \"slot\",\n      source: \"(9:0) <Await promise={collections.get()}>\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment46(ctx) {\n    let await_1;\n    let current;\n    await_1 = new Await_default({\n      props: {\n        promise: collections.get(),\n        $$slots: { default: [create_default_slot18] },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(await_1.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(await_1, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const await_1_changes = {};\n        if (dirty & /*$$scope, $path, $collections*/\n        35) {\n          await_1_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        await_1.$set(await_1_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(await_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(await_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(await_1, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment46.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance46($$self, $$props, $$invalidate) {\n    let $path;\n    let $collections;\n    validate_store(path2, \"path\");\n    component_subscribe($$self, path2, ($$value) => $$invalidate(0, $path = $$value));\n    validate_store(collections, \"collections\");\n    component_subscribe($$self, collections, ($$value) => $$invalidate(1, $collections = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Nav\", slots, []);\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Nav> was created with unknown prop '${key}'`);\n    });\n    $$self.$capture_state = () => ({\n      path: path2,\n      collections,\n      scrollIntoView,\n      Await: Await_default,\n      Icon: Icon_default,\n      File: file_default2,\n      $path,\n      $collections\n    });\n    return [$path, $collections];\n  }\n  var Nav4 = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance46, create_fragment46, safe_not_equal, {});\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Nav\",\n        options: options2,\n        id: create_fragment46.name\n      });\n    }\n  };\n  var nav_default4 = Nav4;\n\n  // src/client/views/Main.svelte\n  init_src();\n  var file44 = \"src/client/views/Main.svelte\";\n  function create_if_block_35(ctx) {\n    let logsnav;\n    let current;\n    logsnav = new nav_default({ $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(logsnav.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(logsnav, target, anchor);\n        current = true;\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(logsnav.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(logsnav.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(logsnav, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_35.name,\n      type: \"if\",\n      source: \"(19:37) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_27(ctx) {\n    let usersnav;\n    let current;\n    usersnav = new nav_default2({ $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(usersnav.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(usersnav, target, anchor);\n        current = true;\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(usersnav.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(usersnav.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(usersnav, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_27.name,\n      type: \"if\",\n      source: \"(17:38) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block_112(ctx) {\n    let filesnav;\n    let current;\n    filesnav = new nav_default3({ $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(filesnav.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(filesnav, target, anchor);\n        current = true;\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(filesnav.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(filesnav.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(filesnav, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block_112.name,\n      type: \"if\",\n      source: \"(15:38) \",\n      ctx\n    });\n    return block2;\n  }\n  function create_if_block24(ctx) {\n    let datanav;\n    let current;\n    datanav = new nav_default4({ $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(datanav.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(datanav, target, anchor);\n        current = true;\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(datanav.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(datanav.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(datanav, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block24.name,\n      type: \"if\",\n      source: '(13:4) {#if $route.path === \\\\\"data\\\\\"}',\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment47(ctx) {\n    let main;\n    let current_block_type_index;\n    let if_block;\n    let t;\n    let current;\n    const if_block_creators = [create_if_block24, create_if_block_112, create_if_block_27, create_if_block_35];\n    const if_blocks = [];\n    function select_block_type(ctx2, dirty) {\n      if (\n        /*$route*/\n        ctx2[0].path === \"data\"\n      ) return 0;\n      if (\n        /*$route*/\n        ctx2[0].path === \"files\"\n      ) return 1;\n      if (\n        /*$route*/\n        ctx2[0].path === \"users\"\n      ) return 2;\n      if (\n        /*$route*/\n        ctx2[0].path === \"logs\"\n      ) return 3;\n      return -1;\n    }\n    if (~(current_block_type_index = select_block_type(ctx, -1))) {\n      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n    }\n    const default_slot_template = (\n      /*#slots*/\n      ctx[3].default\n    );\n    const default_slot = create_slot(\n      default_slot_template,\n      ctx,\n      /*$$scope*/\n      ctx[2],\n      null\n    );\n    const block2 = {\n      c: function create() {\n        main = element(\"main\");\n        if (if_block) if_block.c();\n        t = space();\n        if (default_slot) default_slot.c();\n        attr_dev(main, \"class\", \"container svelte-11vk0bu\");\n        toggle_class(main, \"grid\", !/*$route*/\n        ctx[0].path);\n        add_location(main, file44, 12, 0, 400);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, main, anchor);\n        if (~current_block_type_index) {\n          if_blocks[current_block_type_index].m(main, null);\n        }\n        append_dev(main, t);\n        if (default_slot) {\n          default_slot.m(main, null);\n        }\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        let previous_block_index = current_block_type_index;\n        current_block_type_index = select_block_type(ctx2, dirty);\n        if (current_block_type_index !== previous_block_index) {\n          if (if_block) {\n            group_outros();\n            transition_out(if_blocks[previous_block_index], 1, 1, () => {\n              if_blocks[previous_block_index] = null;\n            });\n            check_outros();\n          }\n          if (~current_block_type_index) {\n            if_block = if_blocks[current_block_type_index];\n            if (!if_block) {\n              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);\n              if_block.c();\n            } else {\n            }\n            transition_in(if_block, 1);\n            if_block.m(main, t);\n          } else {\n            if_block = null;\n          }\n        }\n        if (default_slot) {\n          if (default_slot.p && (!current || dirty & /*$$scope*/\n          4)) {\n            update_slot_base(\n              default_slot,\n              default_slot_template,\n              ctx2,\n              /*$$scope*/\n              ctx2[2],\n              !current ? get_all_dirty_from_scope(\n                /*$$scope*/\n                ctx2[2]\n              ) : get_slot_changes(\n                default_slot_template,\n                /*$$scope*/\n                ctx2[2],\n                dirty,\n                null\n              ),\n              null\n            );\n          }\n        }\n        if (!current || dirty & /*$route*/\n        1) {\n          toggle_class(main, \"grid\", !/*$route*/\n          ctx2[0].path);\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        transition_in(default_slot, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        transition_out(default_slot, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(main);\n        }\n        if (~current_block_type_index) {\n          if_blocks[current_block_type_index].d();\n        }\n        if (default_slot) default_slot.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment47.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance47($$self, $$props, $$invalidate) {\n    let $route;\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Main\", slots, [\"default\"]);\n    \"use strict\";\n    const route = paramable(\"/:path/:folder?\");\n    validate_store(route, \"route\");\n    component_subscribe($$self, route, (value) => $$invalidate(0, $route = value));\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Main> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n    };\n    $$self.$capture_state = () => ({\n      paramable,\n      DataNav: nav_default4,\n      FilesNav: nav_default3,\n      UsersNav: nav_default2,\n      LogsNav: nav_default,\n      route,\n      $route\n    });\n    return [$route, route, $$scope, slots];\n  }\n  var Main = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance47, create_fragment47, safe_not_equal, {});\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Main\",\n        options: options2,\n        id: create_fragment47.name\n      });\n    }\n  };\n  var Main_default = Main;\n\n  // src/client/views/Header.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n\n  // src/client/views/Menu.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n  init_Details();\n  init_Icon();\n  init_src();\n  var file45 = \"src/client/views/Menu.svelte\";\n  function get_each_context14(ctx, list2, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[6] = list2[i].match;\n    child_ctx[7] = list2[i].props.title;\n    child_ctx[8] = list2[i].props.menu;\n    child_ctx[9] = list2[i].props.icon;\n    return child_ctx;\n  }\n  function create_if_block25(ctx) {\n    let ul;\n    let current;\n    let each_value = ensure_array_like_dev(routes.filter(func2));\n    let each_blocks = [];\n    for (let i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block14(get_each_context14(ctx, each_value, i));\n    }\n    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {\n      each_blocks[i] = null;\n    });\n    const block2 = {\n      c: function create() {\n        ul = element(\"ul\");\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n        attr_dev(ul, \"role\", \"listbox\");\n        add_location(ul, file45, 24, 12, 627);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, ul, anchor);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          if (each_blocks[i]) {\n            each_blocks[i].m(ul, null);\n          }\n        }\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (dirty & /*$pattern, open*/\n        9) {\n          each_value = ensure_array_like_dev(routes.filter(func2));\n          let i;\n          for (i = 0; i < each_value.length; i += 1) {\n            const child_ctx = get_each_context14(ctx2, each_value, i);\n            if (each_blocks[i]) {\n              each_blocks[i].p(child_ctx, dirty);\n              transition_in(each_blocks[i], 1);\n            } else {\n              each_blocks[i] = create_each_block14(child_ctx);\n              each_blocks[i].c();\n              transition_in(each_blocks[i], 1);\n              each_blocks[i].m(ul, null);\n            }\n          }\n          group_outros();\n          for (i = each_value.length; i < each_blocks.length; i += 1) {\n            out(i);\n          }\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        for (let i = 0; i < each_value.length; i += 1) {\n          transition_in(each_blocks[i]);\n        }\n        current = true;\n      },\n      o: function outro(local) {\n        each_blocks = each_blocks.filter(Boolean);\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          transition_out(each_blocks[i]);\n        }\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(ul);\n        }\n        destroy_each(each_blocks, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_if_block25.name,\n      type: \"if\",\n      source: \"(23:8) {#if $path[0]}\",\n      ctx\n    });\n    return block2;\n  }\n  function create_each_block14(ctx) {\n    let li;\n    let a;\n    let icon_1;\n    let t0;\n    let t1;\n    let a_href_value;\n    let t2;\n    let current;\n    let mounted;\n    let dispose;\n    icon_1 = new Icon_default({\n      props: { icon: (\n        /*icon*/\n        ctx[9]\n      ) },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        li = element(\"li\");\n        a = element(\"a\");\n        create_component(icon_1.$$.fragment);\n        t0 = space();\n        t1 = text(\n          /*title*/\n          ctx[7]\n        );\n        t2 = space();\n        attr_dev(a, \"href\", a_href_value = /*menu*/\n        ctx[8]);\n        add_location(a, file45, 27, 24, 829);\n        toggle_class(\n          li,\n          \"active\",\n          /*$pattern*/\n          ctx[3](\n            /*match*/\n            ctx[6]\n          )\n        );\n        add_location(li, file45, 26, 20, 769);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, li, anchor);\n        append_dev(li, a);\n        mount_component(icon_1, a, null);\n        append_dev(a, t0);\n        append_dev(a, t1);\n        append_dev(li, t2);\n        current = true;\n        if (!mounted) {\n          dispose = listen_dev(\n            a,\n            \"click\",\n            /*click_handler*/\n            ctx[4],\n            false,\n            false,\n            false,\n            false\n          );\n          mounted = true;\n        }\n      },\n      p: function update2(ctx2, dirty) {\n        if (!current || dirty & /*$pattern*/\n        8) {\n          toggle_class(\n            li,\n            \"active\",\n            /*$pattern*/\n            ctx2[3](\n              /*match*/\n              ctx2[6]\n            )\n          );\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(li);\n        }\n        destroy_component(icon_1);\n        mounted = false;\n        dispose();\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_each_block14.name,\n      type: \"each\",\n      source: \"(25:16) {#each routes.filter((r) => r.props.menu) as { match, props: { title, menu, icon }\",\n      ctx\n    });\n    return block2;\n  }\n  function create_default_slot19(ctx) {\n    let if_block_anchor;\n    let current;\n    let if_block = (\n      /*$path*/\n      ctx[1][0] && create_if_block25(ctx)\n    );\n    const block2 = {\n      c: function create() {\n        if (if_block) if_block.c();\n        if_block_anchor = empty();\n      },\n      m: function mount(target, anchor) {\n        if (if_block) if_block.m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        if (\n          /*$path*/\n          ctx2[1][0]\n        ) {\n          if (if_block) {\n            if_block.p(ctx2, dirty);\n            if (dirty & /*$path*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block25(ctx2);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(if_block_anchor.parentNode, if_block_anchor);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, () => {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(if_block_anchor);\n        }\n        if (if_block) if_block.d(detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot19.name,\n      type: \"slot\",\n      source: `(12:4) <Details         bind:open         role=\\\\\"list\\\\\"         button         class=\\\\\"link {!$path[0] ? 'clear' : ''}\\\\\"     >`,\n      ctx\n    });\n    return block2;\n  }\n  function create_summary_slot3(ctx) {\n    let icon_1;\n    let t0;\n    let t1_value = (\n      /*$page*/\n      ctx[2].props.title + \"\"\n    );\n    let t1;\n    let current;\n    icon_1 = new Icon_default({\n      props: { icon: (\n        /*$page*/\n        ctx[2].props.icon\n      ) },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(icon_1.$$.fragment);\n        t0 = space();\n        t1 = text(t1_value);\n      },\n      m: function mount(target, anchor) {\n        mount_component(icon_1, target, anchor);\n        insert_dev(target, t0, anchor);\n        insert_dev(target, t1, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const icon_1_changes = {};\n        if (dirty & /*$page*/\n        4) icon_1_changes.icon = /*$page*/\n        ctx2[2].props.icon;\n        icon_1.$set(icon_1_changes);\n        if ((!current || dirty & /*$page*/\n        4) && t1_value !== (t1_value = /*$page*/\n        ctx2[2].props.title + \"\")) set_data_dev(t1, t1_value);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(icon_1.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(icon_1.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(t0);\n          detach_dev(t1);\n        }\n        destroy_component(icon_1, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_summary_slot3.name,\n      type: \"slot\",\n      source: '(18:8) <svelte:fragment slot=\\\\\"summary\\\\\">',\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment48(ctx) {\n    let menu_1;\n    let details;\n    let updating_open;\n    let current;\n    function details_open_binding(value) {\n      ctx[5](value);\n    }\n    let details_props = {\n      role: \"list\",\n      button: true,\n      class: \"link \" + (!/*$path*/\n      ctx[1][0] ? \"clear\" : \"\"),\n      $$slots: {\n        summary: [create_summary_slot3],\n        default: [create_default_slot19]\n      },\n      $$scope: { ctx }\n    };\n    if (\n      /*open*/\n      ctx[0] !== void 0\n    ) {\n      details_props.open = /*open*/\n      ctx[0];\n    }\n    details = new Details_default({ props: details_props, $$inline: true });\n    binding_callbacks.push(() => bind(details, \"open\", details_open_binding));\n    const block2 = {\n      c: function create() {\n        menu_1 = element(\"menu\");\n        create_component(details.$$.fragment);\n        add_location(menu_1, file45, 11, 0, 319);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, menu_1, anchor);\n        mount_component(details, menu_1, null);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const details_changes = {};\n        if (dirty & /*$path*/\n        2) details_changes.class = \"link \" + (!/*$path*/\n        ctx2[1][0] ? \"clear\" : \"\");\n        if (dirty & /*$$scope, $page, $pattern, open, $path*/\n        4111) {\n          details_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        if (!updating_open && dirty & /*open*/\n        1) {\n          updating_open = true;\n          details_changes.open = /*open*/\n          ctx2[0];\n          add_flush_callback(() => updating_open = false);\n        }\n        details.$set(details_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(details.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(details.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(menu_1);\n        }\n        destroy_component(details);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment48.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  var func2 = (r) => r.props.menu;\n  function instance48($$self, $$props, $$invalidate) {\n    let $path;\n    let $page;\n    let $pattern;\n    validate_store(path2, \"path\");\n    component_subscribe($$self, path2, ($$value) => $$invalidate(1, $path = $$value));\n    validate_store(page, \"page\");\n    component_subscribe($$self, page, ($$value) => $$invalidate(2, $page = $$value));\n    validate_store(pattern, \"pattern\");\n    component_subscribe($$self, pattern, ($$value) => $$invalidate(3, $pattern = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Menu\", slots, []);\n    \"use strict\";\n    let open = false;\n    const writable_props = [];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Menu> was created with unknown prop '${key}'`);\n    });\n    const click_handler = () => $$invalidate(0, open = false);\n    function details_open_binding(value) {\n      open = value;\n      $$invalidate(0, open);\n    }\n    $$self.$capture_state = () => ({\n      pattern,\n      path: path2,\n      routes,\n      page,\n      Icon: Icon_default,\n      Details: Details_default,\n      open,\n      $path,\n      $page,\n      $pattern\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"open\" in $$props2) $$invalidate(0, open = $$props2.open);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [open, $path, $page, $pattern, click_handler, details_open_binding];\n  }\n  var Menu = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance48, create_fragment48, safe_not_equal, {});\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Menu\",\n        options: options2,\n        id: create_fragment48.name\n      });\n    }\n  };\n  var Menu_default = Menu;\n\n  // src/client/views/Header.svelte\n  init_Icon();\n\n  // src/client/components/Logo.svelte\n  init_reload();\n  init_internal();\n  init_disclose_version();\n  init_Icon();\n  var file46 = \"src/client/components/Logo.svelte\";\n  function create_fragment49(ctx) {\n    let a;\n    let svg;\n    let path3;\n    let a_href_value;\n    const block2 = {\n      c: function create() {\n        a = element(\"a\");\n        svg = svg_element(\"svg\");\n        path3 = svg_element(\"path\");\n        attr_dev(path3, \"d\", \"M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12\");\n        attr_dev(path3, \"fill\", \"currentColor\");\n        add_location(path3, file46, 17, 8, 351);\n        attr_dev(svg, \"width\", \"24\");\n        attr_dev(svg, \"height\", \"24\");\n        attr_dev(svg, \"fill\", \"none\");\n        attr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n        add_location(svg, file46, 16, 4, 267);\n        attr_dev(a, \"href\", a_href_value = /*repository*/\n        ctx[0].url);\n        attr_dev(a, \"target\", \"_blank\");\n        attr_dev(a, \"rel\", \"noreferrer\");\n        attr_dev(a, \"role\", \"button\");\n        attr_dev(a, \"class\", \"action link\");\n        add_location(a, file46, 9, 0, 149);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, a, anchor);\n        append_dev(a, svg);\n        append_dev(svg, path3);\n      },\n      p: function update2(ctx2, [dirty]) {\n        if (dirty & /*repository*/\n        1 && a_href_value !== (a_href_value = /*repository*/\n        ctx2[0].url)) {\n          attr_dev(a, \"href\", a_href_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(a);\n        }\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment49.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance49($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Logo\", slots, []);\n    let { repository: repository2 } = $$props;\n    $$self.$$.on_mount.push(function() {\n      if (repository2 === void 0 && !(\"repository\" in $$props || $$self.$$.bound[$$self.$$.props[\"repository\"]])) {\n        console.warn(\"<Logo> was created without expected prop 'repository'\");\n      }\n    });\n    const writable_props = [\"repository\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Logo> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"repository\" in $$props2) $$invalidate(0, repository2 = $$props2.repository);\n    };\n    $$self.$capture_state = () => ({ Icon: Icon_default, repository: repository2 });\n    $$self.$inject_state = ($$props2) => {\n      if (\"repository\" in $$props2) $$invalidate(0, repository2 = $$props2.repository);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [repository2];\n  }\n  var Logo = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance49, create_fragment49, safe_not_equal, { repository: 0 });\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Logo\",\n        options: options2,\n        id: create_fragment49.name\n      });\n    }\n    get repository() {\n      throw new Error(\"<Logo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set repository(value) {\n      throw new Error(\"<Logo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n  };\n  var Logo_default = Logo;\n\n  // src/client/views/Header.svelte\n  init_src();\n  var file47 = \"src/client/views/Header.svelte\";\n  function create_fragment50(ctx) {\n    let header;\n    let logo;\n    let t0;\n    let menu;\n    let t1;\n    let a;\n    let icon;\n    let current;\n    logo = new Logo_default({\n      props: { repository: (\n        /*repository*/\n        ctx[0]\n      ) },\n      $$inline: true\n    });\n    menu = new Menu_default({ $$inline: true });\n    icon = new Icon_default({\n      props: { icon: \"power\", size: 20 },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        header = element(\"header\");\n        create_component(logo.$$.fragment);\n        t0 = space();\n        create_component(menu.$$.fragment);\n        t1 = space();\n        a = element(\"a\");\n        create_component(icon.$$.fragment);\n        attr_dev(a, \"href\", \"/\");\n        attr_dev(a, \"role\", \"button\");\n        attr_dev(a, \"class\", \"link action\");\n        add_location(a, file47, 15, 4, 412);\n        attr_dev(header, \"class\", \"cols col-fit align-center pos-sticky\");\n        toggle_class(\n          header,\n          \"bg-active\",\n          /*$path*/\n          ctx[1][0]\n        );\n        add_location(header, file47, 12, 0, 288);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, header, anchor);\n        mount_component(logo, header, null);\n        append_dev(header, t0);\n        mount_component(menu, header, null);\n        append_dev(header, t1);\n        append_dev(header, a);\n        mount_component(icon, a, null);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const logo_changes = {};\n        if (dirty & /*repository*/\n        1) logo_changes.repository = /*repository*/\n        ctx2[0];\n        logo.$set(logo_changes);\n        if (!current || dirty & /*$path*/\n        2) {\n          toggle_class(\n            header,\n            \"bg-active\",\n            /*$path*/\n            ctx2[1][0]\n          );\n        }\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(logo.$$.fragment, local);\n        transition_in(menu.$$.fragment, local);\n        transition_in(icon.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(logo.$$.fragment, local);\n        transition_out(menu.$$.fragment, local);\n        transition_out(icon.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(header);\n        }\n        destroy_component(logo);\n        destroy_component(menu);\n        destroy_component(icon);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment50.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance50($$self, $$props, $$invalidate) {\n    let $path;\n    validate_store(path2, \"path\");\n    component_subscribe($$self, path2, ($$value) => $$invalidate(1, $path = $$value));\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"Header\", slots, []);\n    let { repository: repository2 } = $$props;\n    $$self.$$.on_mount.push(function() {\n      if (repository2 === void 0 && !(\"repository\" in $$props || $$self.$$.bound[$$self.$$.props[\"repository\"]])) {\n        console.warn(\"<Header> was created without expected prop 'repository'\");\n      }\n    });\n    const writable_props = [\"repository\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<Header> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"repository\" in $$props2) $$invalidate(0, repository2 = $$props2.repository);\n    };\n    $$self.$capture_state = () => ({\n      path: path2,\n      Logo: Logo_default,\n      Icon: Icon_default,\n      Menu: Menu_default,\n      repository: repository2,\n      $path\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"repository\" in $$props2) $$invalidate(0, repository2 = $$props2.repository);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [repository2, $path];\n  }\n  var Header = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance50, create_fragment50, safe_not_equal, { repository: 0 });\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Header\",\n        options: options2,\n        id: create_fragment50.name\n      });\n    }\n    get repository() {\n      throw new Error(\"<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set repository(value) {\n      throw new Error(\"<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n  };\n  var Header_default = Header;\n\n  // src/client/App.svelte\n  function create_default_slot20(ctx) {\n    let router;\n    let current;\n    router = new Router_default({\n      props: { name: (\n        /*name*/\n        ctx[0]\n      ) },\n      $$inline: true\n    });\n    const block2 = {\n      c: function create() {\n        create_component(router.$$.fragment);\n      },\n      m: function mount(target, anchor) {\n        mount_component(router, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, dirty) {\n        const router_changes = {};\n        if (dirty & /*name*/\n        1) router_changes.name = /*name*/\n        ctx2[0];\n        router.$set(router_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(router.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(router.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        destroy_component(router, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_default_slot20.name,\n      type: \"slot\",\n      source: \"(14:0) <Main>\",\n      ctx\n    });\n    return block2;\n  }\n  function create_fragment51(ctx) {\n    let header;\n    let t0;\n    let main;\n    let t1;\n    let footer;\n    let t2;\n    let lightbox;\n    let t3;\n    let toaster;\n    let current;\n    header = new Header_default({\n      props: { repository: (\n        /*repository*/\n        ctx[1]\n      ) },\n      $$inline: true\n    });\n    main = new Main_default({\n      props: {\n        $$slots: { default: [create_default_slot20] },\n        $$scope: { ctx }\n      },\n      $$inline: true\n    });\n    footer = new Footer_default({ $$inline: true });\n    lightbox = new Modal_default({ $$inline: true });\n    toaster = new Toaster_default({ $$inline: true });\n    const block2 = {\n      c: function create() {\n        create_component(header.$$.fragment);\n        t0 = space();\n        create_component(main.$$.fragment);\n        t1 = space();\n        create_component(footer.$$.fragment);\n        t2 = space();\n        create_component(lightbox.$$.fragment);\n        t3 = space();\n        create_component(toaster.$$.fragment);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        mount_component(header, target, anchor);\n        insert_dev(target, t0, anchor);\n        mount_component(main, target, anchor);\n        insert_dev(target, t1, anchor);\n        mount_component(footer, target, anchor);\n        insert_dev(target, t2, anchor);\n        mount_component(lightbox, target, anchor);\n        insert_dev(target, t3, anchor);\n        mount_component(toaster, target, anchor);\n        current = true;\n      },\n      p: function update2(ctx2, [dirty]) {\n        const header_changes = {};\n        if (dirty & /*repository*/\n        2) header_changes.repository = /*repository*/\n        ctx2[1];\n        header.$set(header_changes);\n        const main_changes = {};\n        if (dirty & /*$$scope, name*/\n        5) {\n          main_changes.$$scope = { dirty, ctx: ctx2 };\n        }\n        main.$set(main_changes);\n      },\n      i: function intro(local) {\n        if (current) return;\n        transition_in(header.$$.fragment, local);\n        transition_in(main.$$.fragment, local);\n        transition_in(footer.$$.fragment, local);\n        transition_in(lightbox.$$.fragment, local);\n        transition_in(toaster.$$.fragment, local);\n        current = true;\n      },\n      o: function outro(local) {\n        transition_out(header.$$.fragment, local);\n        transition_out(main.$$.fragment, local);\n        transition_out(footer.$$.fragment, local);\n        transition_out(lightbox.$$.fragment, local);\n        transition_out(toaster.$$.fragment, local);\n        current = false;\n      },\n      d: function destroy(detaching) {\n        if (detaching) {\n          detach_dev(t0);\n          detach_dev(t1);\n          detach_dev(t2);\n          detach_dev(t3);\n        }\n        destroy_component(header, detaching);\n        destroy_component(main, detaching);\n        destroy_component(footer, detaching);\n        destroy_component(lightbox, detaching);\n        destroy_component(toaster, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block: block2,\n      id: create_fragment51.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block2;\n  }\n  function instance51($$self, $$props, $$invalidate) {\n    let { $$slots: slots = {}, $$scope } = $$props;\n    validate_slots(\"App\", slots, []);\n    let { name: name2 } = $$props;\n    let { repository: repository2 } = $$props;\n    $$self.$$.on_mount.push(function() {\n      if (name2 === void 0 && !(\"name\" in $$props || $$self.$$.bound[$$self.$$.props[\"name\"]])) {\n        console.warn(\"<App> was created without expected prop 'name'\");\n      }\n      if (repository2 === void 0 && !(\"repository\" in $$props || $$self.$$.bound[$$self.$$.props[\"repository\"]])) {\n        console.warn(\"<App> was created without expected prop 'repository'\");\n      }\n    });\n    const writable_props = [\"name\", \"repository\"];\n    Object.keys($$props).forEach((key) => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== \"$$\" && key !== \"slot\") console.warn(`<App> was created with unknown prop '${key}'`);\n    });\n    $$self.$$set = ($$props2) => {\n      if (\"name\" in $$props2) $$invalidate(0, name2 = $$props2.name);\n      if (\"repository\" in $$props2) $$invalidate(1, repository2 = $$props2.repository);\n    };\n    $$self.$capture_state = () => ({\n      Header: Header_default,\n      Main: Main_default,\n      Footer: Footer_default,\n      Router: Router_default,\n      Toaster: Toaster_default,\n      LightBox: Modal_default,\n      name: name2,\n      repository: repository2\n    });\n    $$self.$inject_state = ($$props2) => {\n      if (\"name\" in $$props2) $$invalidate(0, name2 = $$props2.name);\n      if (\"repository\" in $$props2) $$invalidate(1, repository2 = $$props2.repository);\n    };\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n    return [name2, repository2];\n  }\n  var App = class extends SvelteComponentDev {\n    constructor(options2) {\n      super(options2);\n      init(this, options2, instance51, create_fragment51, safe_not_equal, { name: 0, repository: 1 });\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"App\",\n        options: options2,\n        id: create_fragment51.name\n      });\n    }\n    get name() {\n      throw new Error(\"<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set name(value) {\n      throw new Error(\"<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    get repository() {\n      throw new Error(\"<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n    set repository(value) {\n      throw new Error(\"<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    }\n  };\n  var App_default = App;\n\n  // src/client/app.ts\n  var app_default = new App_default({\n    target: document.body,\n    props: { name, repository }\n  });\n})();\n</script></body></html>"